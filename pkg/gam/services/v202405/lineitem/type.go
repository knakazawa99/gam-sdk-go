// Code generated by gamwsdl/main.go. DO NOT EDIT.
package lineitem

import (
	"github.com/knakazawa99/gam-sdk-go/pkg/gam/requestbody"
	gamxml "github.com/knakazawa99/gam-sdk-go/pkg/xml"
)

// ObjectValue
//
// Contains an object value.
// <p>
// <b>This object is experimental!
// <code>ObjectValue</code> is an experimental, innovative, and rapidly
// changing new feature for Ad Manager. Unfortunately, being on the bleeding edge means that
// we may make backwards-incompatible changes to
// <code>ObjectValue</code>. We will inform the community when this feature
// is no longer experimental.</b>
//

type ObjectValue struct {
}

// ActivateLineItems
//
// The action used for activating {@link LineItem} objects.
//

type ActivateLineItems struct {
}

func NewActivateLineItems() (requestbody.PerformAction, error) {
	return &ActivateLineItems{}, nil
}
func (a ActivateLineItems) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ActivateLineItems) GetActionType() string {
	return "ActivateLineItems"
}

// AdUnitTargeting
//
// Represents targeted or excluded ad units.
//

type AdUnitTargeting struct {

	// AdUnitId
	//
	// Included or excluded ad unit id.
	//

	AdUnitId *string `xml:"adUnitId"`

	// IncludeDescendants
	//
	// Whether or not all descendants are included (or excluded) as part of including (or excluding)
	// this ad unit. By default, the value is {@code true} which means targeting this ad unit will
	// target all of its descendants.
	//

	IncludeDescendants *bool `xml:"includeDescendants"`
}

// ApiError
//
// The API error base class that provides details about an error that occurred
// while processing a service request.
//
// <p>The OGNL field path is provided for parsers to identify the request data
// element that may have caused the error.</p>
//

type ApiError struct {
	Reason string `xml:"reason"`
}

// ApiException
//
// Exception class for holding a list of service errors.
//

type ApiException struct {
	Reason string `xml:"reason"`
}

// TechnologyTargeting
//
// Provides {@link LineItem} objects the ability to target or exclude technologies.
//

type TechnologyTargeting struct {

	// BandwidthGroupTargeting
	//
	// The bandwidth groups being targeted by the {@link LineItem}.
	//

	BandwidthGroupTargeting *BandwidthGroupTargeting `xml:"bandwidthGroupTargeting"`

	// BrowserTargeting
	//
	// The browsers being targeted by the {@link LineItem}.
	//

	BrowserTargeting *BrowserTargeting `xml:"browserTargeting"`

	// BrowserLanguageTargeting
	//
	// The languages of browsers being targeted by the {@link LineItem}.
	//

	BrowserLanguageTargeting *BrowserLanguageTargeting `xml:"browserLanguageTargeting"`

	// DeviceCapabilityTargeting
	//
	// The device capabilities being targeted by the {@link LineItem}.
	//

	DeviceCapabilityTargeting *DeviceCapabilityTargeting `xml:"deviceCapabilityTargeting"`

	// DeviceCategoryTargeting
	//
	// The device categories being targeted by the {@link LineItem}.
	//

	DeviceCategoryTargeting *DeviceCategoryTargeting `xml:"deviceCategoryTargeting"`

	// DeviceManufacturerTargeting
	//
	// The device manufacturers being targeted by the {@link LineItem}.
	//

	DeviceManufacturerTargeting *DeviceManufacturerTargeting `xml:"deviceManufacturerTargeting"`

	// MobileCarrierTargeting
	//
	// The mobile carriers being targeted by the {@link LineItem}.
	//

	MobileCarrierTargeting *MobileCarrierTargeting `xml:"mobileCarrierTargeting"`

	// MobileDeviceTargeting
	//
	// The mobile devices being targeted by the {@link LineItem}.
	//

	MobileDeviceTargeting *MobileDeviceTargeting `xml:"mobileDeviceTargeting"`

	// MobileDeviceSubmodelTargeting
	//
	// The mobile device submodels being targeted by the {@link LineItem}.
	//

	MobileDeviceSubmodelTargeting *MobileDeviceSubmodelTargeting `xml:"mobileDeviceSubmodelTargeting"`

	// OperatingSystemTargeting
	//
	// The operating systems being targeted by the {@link LineItem}.
	//

	OperatingSystemTargeting *OperatingSystemTargeting `xml:"operatingSystemTargeting"`

	// OperatingSystemVersionTargeting
	//
	// The operating system versions being targeted by the {@link LineItem}.
	//

	OperatingSystemVersionTargeting *OperatingSystemVersionTargeting `xml:"operatingSystemVersionTargeting"`
}

// ApiVersionError
//
// Errors related to the usage of API versions.
//

type ApiVersionError struct {
	Reason string `xml:"reason"`
}

// ApplicationException
//
// Base class for exceptions.
//

type ApplicationException struct {
	Reason string `xml:"reason"`
}

// AppliedLabel
//
// Represents a {@link Label} that can be applied to an entity. To negate an inherited label, create
// an {@code AppliedLabel} with {@code labelId} as the inherited label's ID and {@code isNegated}
// set to true.
//

type AppliedLabel struct {

	// LabelId
	//
	// The ID of a created {@link Label}.
	//

	LabelId *int64 `xml:"labelId"`

	// IsNegated
	//
	// {@code isNegated} should be set to {@code true} to negate the effects of {@code labelId}.
	//

	IsNegated *bool `xml:"isNegated"`
}

// ArchiveLineItems
//
// The action used for archiving {@link LineItem} objects.
//

type ArchiveLineItems struct {
}

func NewArchiveLineItems() (requestbody.PerformAction, error) {
	return &ArchiveLineItems{}, nil
}
func (a ArchiveLineItems) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ArchiveLineItems) GetActionType() string {
	return "ArchiveLineItems"
}

// AssetError
//
// Lists all errors associated with assets.
//

type AssetError struct {
	Reason string `xml:"reason"`
}

// AudienceExtensionError
//
// Errors associated with audience extension enabled line items
//

type AudienceExtensionError struct {
	Reason string `xml:"reason"`
}

// AuthenticationError
//
// An error for an exception that occurred when authenticating.
//

type AuthenticationError struct {
	Reason string `xml:"reason"`
}

// BandwidthGroup
//
// Represents a group of bandwidths that are logically organized by some well known generic names
// such as 'Cable' or 'DSL'.
//

type BandwidthGroup struct {
}

// BandwidthGroupTargeting
//
// Represents bandwidth groups that are being targeted or excluded by the {@link LineItem}.
//

type BandwidthGroupTargeting struct {

	// IsTargeted
	//
	// Indicates whether bandwidth groups should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//

	IsTargeted *bool `xml:"isTargeted"`

	// BandwidthGroups
	//
	// The bandwidth groups that are being targeted or excluded by the {@link LineItem}.
	//

	BandwidthGroups []*Technology `xml:"bandwidthGroups"`
}

// BaseCustomFieldValue
//
// The value of a {@link CustomField} for a particular entity.
//

type BaseCustomFieldValue struct {

	// CustomFieldId
	//
	// Id of the {@code CustomField} to which this value belongs. This attribute is required.
	//

	CustomFieldId *int64 `xml:"customFieldId"`
}

// BooleanValue
//
// Contains a boolean value.
//

type BooleanValue struct {

	// Value
	//
	// The boolean value.
	//

	Value *bool `xml:"value"`
}

// Browser
//
// Represents an internet browser.
//

type Browser struct {

	// Technology
	*Technology

	// MajorVersion
	//
	// Browser major version.
	//

	MajorVersion *string `xml:"majorVersion"`

	// MinorVersion
	//
	// Browser minor version.
	//

	MinorVersion *string `xml:"minorVersion"`
}

// BrowserLanguage
//
// Represents a Browser's language.
//

type BrowserLanguage struct {
}

// BrowserLanguageTargeting
//
// Represents browser languages that are being targeted or excluded by the {@link LineItem}.
//

type BrowserLanguageTargeting struct {

	// IsTargeted
	//
	// Indicates whether browsers languages should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//

	IsTargeted *bool `xml:"isTargeted"`

	// BrowserLanguages
	//
	// Browser languages that are being targeted or excluded by the {@link LineItem}.
	//

	BrowserLanguages []*Technology `xml:"browserLanguages"`
}

// BrowserTargeting
//
// Represents browsers that are being targeted or excluded by the {@link LineItem}.
//

type BrowserTargeting struct {

	// IsTargeted
	//
	// Indicates whether browsers should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//

	IsTargeted *bool `xml:"isTargeted"`

	// Browsers
	//
	// Browsers that are being targeted or excluded by the {@link LineItem}.
	//

	Browsers []*Technology `xml:"browsers"`
}

// BuyerUserListTargeting
//
// The {@code BuyerUserListTargeting} associated with a programmatic {@link LineItem} or {@link
// ProposalLineItem} object.
//

type BuyerUserListTargeting struct {

	// HasBuyerUserListTargeting
	//
	// Whether the programmatic {@code LineItem} or {@code ProposalLineItem} object has buyer user
	// list targeting.
	//

	HasBuyerUserListTargeting *bool `xml:"hasBuyerUserListTargeting"`
}

// ClickTrackingLineItemError
//
// Click tracking is a special line item type with a number of unique errors as
// described below.
//

type ClickTrackingLineItemError struct {
	Reason string `xml:"reason"`
}

// CollectionSizeError
//
// Error for the size of the collection being too large
//

type CollectionSizeError struct {
	Reason string `xml:"reason"`
}

// CommonError
//
// A place for common errors that can be used across services.
//

type CommonError struct {
	Reason string `xml:"reason"`
}

// CompanyCreditStatusError
//
// Lists all errors due to {@link Company#creditStatus}.
//

type CompanyCreditStatusError struct {
	Reason string `xml:"reason"`
}

// ContentTargeting
//
// Used to target {@link LineItem}s to specific videos on a publisher's site.
//

type ContentTargeting struct {

	// TargetedContentIds
	//
	// The IDs of content being targeted by the {@code LineItem}.
	//

	TargetedContentIds []*int64 `xml:"targetedContentIds"`

	// ExcludedContentIds
	//
	// The IDs of content being excluded by the {@code LineItem}.
	//

	ExcludedContentIds []*int64 `xml:"excludedContentIds"`

	// TargetedVideoContentBundleIds
	//
	// A list of video content bundles, represented by {@link ContentBundle} IDs, that are being
	// targeted by the {@code LineItem}.
	//

	TargetedVideoContentBundleIds []*int64 `xml:"targetedVideoContentBundleIds"`

	// ExcludedVideoContentBundleIds
	//
	// A list of video content bundles, represented by {@link ContentBundle} IDs, that are being
	// excluded by the {@code LineItem}.
	//

	ExcludedVideoContentBundleIds []*int64 `xml:"excludedVideoContentBundleIds"`
}

// CreativeError
//
// Lists all errors associated with creatives.
//

type CreativeError struct {
	Reason string `xml:"reason"`
}

// CreativePlaceholder
//
// A {@code CreativePlaceholder} describes a slot that a creative is expected to fill. This is used
// primarily to help in forecasting, and also to validate that the correct creatives are associated
// with the line item. A {@code CreativePlaceholder} must contain a size, and it can optionally
// contain companions. Companions are only valid if the line item's environment type is {@link
// EnvironmentType#VIDEO_PLAYER}.
//

type CreativePlaceholder struct {

	// Size
	//
	// The dimensions that the creative is expected to have. This attribute is required.
	//

	Size *Size `xml:"size"`

	// CreativeTemplateId
	//
	// The native creative template ID.
	//
	// <p>This value is only required if {@link #creativeSizeType} is {@link CreativeSizeType#NATIVE}.
	//

	CreativeTemplateId *int64 `xml:"creativeTemplateId"`

	// Companions
	//
	// The companions that the creative is expected to have. This attribute can only be set if the
	// line item it belongs to has a {@link LineItem#environmentType} of {@link
	// EnvironmentType#VIDEO_PLAYER} or {@link LineItem#roadblockingType} of {@link
	// RoadblockingType#CREATIVE_SET}.
	//

	Companions []*CreativePlaceholder `xml:"companions"`

	// AppliedLabels
	//
	// The set of label frequency caps applied directly to this creative placeholder.
	//

	AppliedLabels []*AppliedLabel `xml:"appliedLabels"`

	// EffectiveAppliedLabels
	//
	// Contains the set of labels applied directly to this creative placeholder as well as those
	// inherited from the creative template from which this creative placeholder was instantiated.
	// This field is readonly and is assigned by Google.
	//

	EffectiveAppliedLabels []*AppliedLabel `xml:"effectiveAppliedLabels"`

	// ExpectedCreativeCount
	//
	// Expected number of creatives that will be uploaded corresponding to this creative placeholder.
	// This estimate is used to improve the accuracy of forecasting; for example, if label frequency
	// capping limits the number of times a creative may be served.
	//

	ExpectedCreativeCount *int `xml:"expectedCreativeCount"`

	// CreativeSizeType
	//
	// Describes the services of sizes a creative can be. By default, the creative's size is {@link
	// CreativeSizeType#PIXEL}, which is a dimension based size (width-height pair).
	//

	CreativeSizeType *CreativeSizeType `xml:"creativeSizeType"`

	// TargetingName
	//
	// The name of the {@link CreativeTargeting} for creatives this placeholder represents.
	//
	// <p>This attribute is optional. Specifying creative targeting here is for forecasting purposes
	// only and has no effect on serving. The same creative targeting should be specified on a {@link
	// LineItemCreativeAssociation} when associating a {@link Creative} with the {@link LineItem}.
	//

	TargetingName *string `xml:"targetingName"`

	// IsAmpOnly
	//
	// Indicate if the expected creative of this placeholder has an AMP only variant.
	//
	// <p>This attribute is optional. It is for forecasting purposes only and has no effect on
	// serving.
	//

	IsAmpOnly *bool `xml:"isAmpOnly"`
}

// CreativeTargeting
//
// Represents the creative targeting criteria for a {@link LineItem}.
//

type CreativeTargeting struct {

	// Name
	//
	// The name of this creative targeting. This attribute is required.
	//

	Name *string `xml:"name"`

	// Targeting
	//
	// The {@link Targeting} criteria of this creative targeting. This attribute is required.
	//

	Targeting *Targeting `xml:"targeting"`
}

// CrossSellError
//
// Lists all errors associated with cross selling.
//

type CrossSellError struct {
	Reason string `xml:"reason"`
}

// CurrencyCodeError
//
// Errors related to currency codes.
//

type CurrencyCodeError struct {
	Reason string `xml:"reason"`
}

// CustomCriteria
//
// A {@link CustomCriteria} object is used to perform custom criteria targeting on custom targeting
// keys of type {@link CustomTargetingKey.Type#PREDEFINED} or {@link
// CustomTargetingKey.Type#FREEFORM}.
//

type CustomCriteria struct {

	// CustomCriteriaLeaf
	*CustomCriteriaLeaf

	// KeyId
	//
	// The {@link CustomTargetingKey#id} of the {@link CustomTargetingKey} object that was created
	// using {@link CustomTargetingService}. This attribute is required.
	//

	KeyId *int64 `xml:"keyId"`

	// ValueIds
	//
	// The ids of {@link CustomTargetingValue} objects to target the custom targeting key with id
	// {@link CustomCriteria#keyId}. This attribute is required.
	//

	ValueIds []*int64 `xml:"valueIds"`

	// Operator
	//
	// The comparison operator. This attribute is required.
	//

	Operator *CustomCriteriaComparisonOperator `xml:"operator"`
}

// CustomCriteriaSet
//
// A {@link CustomCriteriaSet} comprises of a set of {@link CustomCriteriaNode} objects combined by
// the {@link CustomCriteriaSet.LogicalOperator#logicalOperator}. The custom criteria targeting tree
// is subject to the rules defined on {@link Targeting#customTargeting}.
//

type CustomCriteriaSet struct {

	// CustomCriteriaNode
	*CustomCriteriaNode

	// LogicalOperator
	//
	// The logical operator to be applied to {@link CustomCriteriaSet#children}. This attribute is
	// required.
	// <span class="constraint Required">This attribute is required.</span>
	//

	LogicalOperator *CustomCriteriaSetLogicalOperator `xml:"logicalOperator"`

	// Children
	//
	// The custom criteria. This attribute is required.
	//

	Children []*CustomCriteriaNode `xml:"children"`
}

// CustomFieldValue
//
// The value of a {@link CustomField} that does not have a {@link CustomField#dataType} of {@link
// CustomFieldDataType#DROP_DOWN}.
//

type CustomFieldValue struct {

	// BaseCustomFieldValue
	*BaseCustomFieldValue

	// Value
	//
	// The value for this field. The appropriate type of {@code Value} is determined by the {@link
	// CustomField#dataType} of the {@code CustomField} that this conforms to.
	//
	// <table>
	// <tr><th>{@link CustomFieldDataType}</th><th>{@link Value} type</th></tr>
	// <tr><td>{@link CustomFieldDataType#STRING STRING}</td><td>{@link TextValue}</td></tr>
	// <tr><td>{@link CustomFieldDataType#NUMBER NUMBER}</td><td>{@link NumberValue}</td></tr>
	// <tr><td>{@link CustomFieldDataType#TOGGLE TOGGLE}</td><td>{@link BooleanValue}</td></tr>
	// </table>
	//

	Value *Value `xml:"value"`
}

// CustomFieldValueError
//
// Errors specific to editing custom field values
//

type CustomFieldValueError struct {
	Reason string `xml:"reason"`
}

// CustomPacingCurve
//
// A curve consisting of {@link CustomPacingGoal} objects that is used to pace line item delivery.
//

type CustomPacingCurve struct {

	// CustomPacingGoalUnit
	//
	// The unit of the {@link CustomPacingGoalDto#amount} values.
	//

	CustomPacingGoalUnit *CustomPacingGoalUnit `xml:"customPacingGoalUnit"`

	// CustomPacingGoals
	//
	// The list of goals that make up the custom pacing curve.
	//

	CustomPacingGoals []*CustomPacingGoal `xml:"customPacingGoals"`
}

// CustomPacingGoal
//
// An interval of a {@link CustomPacingCurve}. A custom pacing goal contains a start time and an
// amount. The goal will apply until either the next custom pacing goal's {@code getStartTime} or
// the line item's end time if it is the last goal.
//

type CustomPacingGoal struct {

	// StartDateTime
	//
	// The start date and time of the goal. This field is required unless {@code
	// useLineItemStartDateTime} is true.
	//

	StartDateTime *DateTime `xml:"startDateTime"`

	// UseLineItemStartDateTime
	//
	// Whether the {@link LineItem#startDateTime} should be used for the start date and time of this
	// goal. This field is not persisted and if it is set to true, the {@code startDateTime} field
	// will be populated by the line item's start time.
	//

	UseLineItemStartDateTime *bool `xml:"useLineItemStartDateTime"`

	// Amount

	Amount *int64 `xml:"amount"`
}

// CmsMetadataCriteria
//
// A {@code CmsMetadataCriteria} object is used to target {@code CmsMetadataValue} objects.
//

type CmsMetadataCriteria struct {

	// CustomCriteriaLeaf
	*CustomCriteriaLeaf

	// Operator
	//
	// The comparison operator. This attribute is required.
	//

	Operator *CmsMetadataCriteriaComparisonOperator `xml:"operator"`

	// CmsMetadataValueIds
	//
	// The ids of {@link CmsMetadataValue} objects used to target CMS metadata. This attribute is
	// required.
	//

	CmsMetadataValueIds []*int64 `xml:"cmsMetadataValueIds"`
}

// CustomTargetingError
//
// Lists all errors related to {@link CustomTargetingKey} and
// {@link CustomTargetingValue} objects.
//

type CustomTargetingError struct {
	Reason string `xml:"reason"`
}

// CustomCriteriaLeaf
//
// A {@link CustomCriteriaLeaf} object represents a generic leaf of {@link CustomCriteria} tree
// structure.
//

type CustomCriteriaLeaf struct {
}

// CustomCriteriaNode
//
// A {@link CustomCriteriaNode} is a node in the custom targeting tree. A custom criteria node can
// either be a {@link CustomCriteriaSet} (a non-leaf node) or a {@link CustomCriteria} (a leaf
// node). The custom criteria targeting tree is subject to the rules defined on {@link
// Targeting#customTargeting}.
//

type CustomCriteriaNode struct {
}

// AudienceSegmentCriteria
//
// An {@link AudienceSegmentCriteria} object is used to target {@link AudienceSegment} objects.
//

type AudienceSegmentCriteria struct {

	// CustomCriteriaLeaf
	*CustomCriteriaLeaf

	// Operator
	//
	// The comparison operator. This attribute is required.
	//

	Operator *AudienceSegmentCriteriaComparisonOperator `xml:"operator"`

	// AudienceSegmentIds
	//
	// The ids of {@link AudienceSegment} objects used to target audience segments. This attribute is
	// required.
	//

	AudienceSegmentIds []*int64 `xml:"audienceSegmentIds"`
}

// Date
//
// Represents a date.
//

type Date struct {

	// Year
	//
	// Year (e.g., 2009)
	//

	Year *int `xml:"year"`

	// Month
	//
	// Month (1..12)
	//

	Month *int `xml:"month"`

	// Day
	//
	// Day (1..31)
	//

	Day *int `xml:"day"`
}

// DateTime
//
// Represents a date combined with the time of day.
//

type DateTime struct {

	// Date

	Date *Date `xml:"date"`

	// Hour

	Hour *int `xml:"hour"`

	// Minute

	Minute *int `xml:"minute"`

	// Second

	Second *int `xml:"second"`

	// TimeZoneId

	TimeZoneId *string `xml:"timeZoneId"`
}

// DateTimeRange
//
// Represents a range of dates (combined with time of day) that has an upper and/or lower bound.
//

type DateTimeRange struct {

	// StartDateTime
	//
	// The start date time of this range. This field is optional and if it is not set then there is no
	// lower bound on the date time range. If this field is not set then {@code endDateTime} must be
	// specified.
	//

	StartDateTime *DateTime `xml:"startDateTime"`

	// EndDateTime
	//
	// The end date time of this range. This field is optional and if it is not set then there is no
	// upper bound on the date time range. If this field is not set then {@code startDateTime} must be
	// specified.
	//

	EndDateTime *DateTime `xml:"endDateTime"`
}

// DateTimeRangeTargeting
//
// The date time ranges that the line item is eligible to serve.
//

type DateTimeRangeTargeting struct {

	// TargetedDateTimeRanges

	TargetedDateTimeRanges []*DateTimeRange `xml:"targetedDateTimeRanges"`
}

// DateTimeRangeTargetingError
//
// Lists all date time range errors caused by associating a line item with a targeting
// expression.
//

type DateTimeRangeTargetingError struct {
	Reason string `xml:"reason"`
}

// DateTimeValue
//
// Contains a date-time value.
//

type DateTimeValue struct {

	// Value
	//
	// The {@code DateTime} value.
	//

	Value *DateTime `xml:"value"`
}

// DateValue
//
// Contains a date value.
//

type DateValue struct {

	// Value
	//
	// The {@code Date} value.
	//

	Value *Date `xml:"value"`
}

// DayPart
//
// {@code DayPart} represents a time-period within a day of the week which is
// targeted by a {@link LineItem}.
//

type DayPart struct {

	// DayOfWeek
	//
	// Day of the week the target applies to. This field is required.
	//

	DayOfWeek *DayOfWeek `xml:"dayOfWeek"`

	// StartTime
	//
	// Represents the start time of the targeted period (inclusive).
	//

	StartTime *TimeOfDay `xml:"startTime"`

	// EndTime
	//
	// Represents the end time of the targeted period (exclusive).
	//

	EndTime *TimeOfDay `xml:"endTime"`
}

// DayPartTargeting
//
// Modify the delivery times of line items for particular days of the week. By default, line items
// are served at all days and times.
//

type DayPartTargeting struct {

	// DayParts
	//
	// Specifies days of the week and times at which a {@code LineItem} will be delivered.
	//
	// <p>If targeting all days and times, this value will be ignored.
	//

	DayParts []*DayPart `xml:"dayParts"`

	// TimeZone
	//
	// Specifies the time zone to be used for delivering {@link LineItem} objects. This attribute is
	// optional and defaults to {@link DeliveryTimeZone#BROWSER}.
	//
	// <p>Setting this has no effect if targeting all days and times.
	//

	TimeZone *DeliveryTimeZone `xml:"timeZone"`
}

// DayPartTargetingError
//
// Lists all errors associated with day-part targeting for a line item.
//

type DayPartTargetingError struct {
	Reason string `xml:"reason"`
}

// DeleteLineItems
//
// The action used for deleting {@link LineItem} objects. A line item can be
// deleted if it has never been eligible to serve. Note: deleted line items
// will still count against your network limits. For more information, see the
// <a href="https://support.google.com/admanager/answer/1628457">Help Center</a>.
//

type DeleteLineItems struct {
}

func NewDeleteLineItems() (requestbody.PerformAction, error) {
	return &DeleteLineItems{}, nil
}
func (a DeleteLineItems) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a DeleteLineItems) GetActionType() string {
	return "DeleteLineItems"
}

// DeliveryData
//
// Holds the number of clicks or impressions, determined by
// {@link LineItem#costType}, delivered for a single line item for the
// last 7 days
//

type DeliveryData struct {

	// Units
	//
	// Clicks or impressions delivered for the last 7 days.
	//

	Units []*int64 `xml:"units"`
}

// DeliveryIndicator
//
// Indicates the delivery performance of the {@link LineItem}.
//

type DeliveryIndicator struct {

	// ExpectedDeliveryPercentage
	//
	// How much the {@code LineItem} was expected to deliver as a percentage of
	// {@link LineItem#primaryGoal}.
	//

	ExpectedDeliveryPercentage *float64 `xml:"expectedDeliveryPercentage"`

	// ActualDeliveryPercentage
	//
	// How much the line item actually delivered as a percentage of
	// {@link LineItem#primaryGoal}.
	//

	ActualDeliveryPercentage *float64 `xml:"actualDeliveryPercentage"`
}

// DeviceCapability
//
// Represents a capability of a physical device.
//

type DeviceCapability struct {
}

// DeviceCapabilityTargeting
//
// Represents device capabilities that are being targeted or excluded by the {@link LineItem}.
//

type DeviceCapabilityTargeting struct {

	// TargetedDeviceCapabilities
	//
	// Device capabilities that are being targeted by the {@link LineItem}.
	//

	TargetedDeviceCapabilities []*Technology `xml:"targetedDeviceCapabilities"`

	// ExcludedDeviceCapabilities
	//
	// Device capabilities that are being excluded by the {@link LineItem}.
	//

	ExcludedDeviceCapabilities []*Technology `xml:"excludedDeviceCapabilities"`
}

// DeviceCategory
//
// Represents the category of a device.
//

type DeviceCategory struct {
}

// DeviceCategoryTargeting
//
// Represents device categories that are being targeted or excluded by the {@link LineItem}.
//

type DeviceCategoryTargeting struct {

	// TargetedDeviceCategories
	//
	// Device categories that are being targeted by the {@link LineItem}.
	//

	TargetedDeviceCategories []*Technology `xml:"targetedDeviceCategories"`

	// ExcludedDeviceCategories
	//
	// Device categories that are being excluded by the {@link LineItem}.
	//

	ExcludedDeviceCategories []*Technology `xml:"excludedDeviceCategories"`
}

// DeviceManufacturer
//
// Represents a mobile device's manufacturer.
//

type DeviceManufacturer struct {
}

// DeviceManufacturerTargeting
//
// Represents device manufacturer that are being targeted or excluded by the {@link LineItem}.
//

type DeviceManufacturerTargeting struct {

	// IsTargeted
	//
	// Indicates whether device manufacturers should be targeted or excluded. This attribute is
	// optional and defaults to {@code true}.
	//

	IsTargeted *bool `xml:"isTargeted"`

	// DeviceManufacturers
	//
	// Device manufacturers that are being targeted or excluded by the {@link LineItem}.
	//

	DeviceManufacturers []*Technology `xml:"deviceManufacturers"`
}

// DropDownCustomFieldValue
//
// A {@link CustomFieldValue} for a {@link CustomField} that has a {@link CustomField#dataType} of
// {@link CustomFieldDataType#DROP_DOWN}
//

type DropDownCustomFieldValue struct {

	// BaseCustomFieldValue
	*BaseCustomFieldValue

	// CustomFieldOptionId
	//
	// The {@link CustomFieldOption#id ID} of the {@link CustomFieldOption} for this value.
	//

	CustomFieldOptionId *int64 `xml:"customFieldOptionId"`
}

// EntityChildrenLimitReachedError
//
// Lists errors relating to having too many children on an entity.
//

type EntityChildrenLimitReachedError struct {
	Reason string `xml:"reason"`
}

// EntityLimitReachedError
//
// An error that occurs when creating an entity if the limit on the number of allowed entities for
// a network has already been reached.
//

type EntityLimitReachedError struct {
	Reason string `xml:"reason"`
}

// FeatureError
//
// Errors related to feature management.  If you attempt using a feature that is not available to
// the current network you'll receive a FeatureError with the missing feature as the trigger.
//

type FeatureError struct {
	Reason string `xml:"reason"`
}

// FieldPathElement
//
// A segment of a field path. Each dot in a field path defines a new segment.
//

type FieldPathElement struct {

	// Field
	//
	// The name of a field in lower camelcase. (e.g. "biddingStrategy")
	//

	Field *string `xml:"field"`

	// Index
	//
	// For list fields, this is a 0-indexed position in the list. Null for non-list fields.
	//

	Index *int `xml:"index"`
}

// ForecastError
//
// Errors that can result from a forecast request.
//

type ForecastError struct {
	Reason string `xml:"reason"`
}

// FrequencyCap
//
// Represents a limit on the number of times a single viewer can be exposed to the same {@link
// LineItem} in a specified time period.
//

type FrequencyCap struct {

	// MaxImpressions
	//
	// The maximum number of impressions than can be served to a user within a specified time period.
	//

	MaxImpressions *int `xml:"maxImpressions"`

	// NumTimeUnits
	//
	// The number of {@code FrequencyCap#timeUnit} to represent the total time period.
	//

	NumTimeUnits *int `xml:"numTimeUnits"`

	// TimeUnit
	//
	// The unit of time for specifying the time period.
	//

	TimeUnit *TimeUnit `xml:"timeUnit"`
}

// FrequencyCapError
//
// Lists all errors associated with frequency caps.
//

type FrequencyCapError struct {
	Reason string `xml:"reason"`
}

// GenericTargetingError
//
// Targeting validation errors that can be used by different targeting services.
//

type GenericTargetingError struct {
	Reason string `xml:"reason"`
}

// GeoTargeting
//
// Provides line items the ability to target geographical locations. By default, line items target
// all countries and their subdivisions. With geographical targeting, you can target line items to
// specific countries, regions, metro areas, and cities. You can also exclude the same.
//
// <p>The following rules apply for geographical targeting:
//
// <ul>
// <li>You cannot target and exclude the same location.
// <li>You cannot target a child whose parent has been excluded. For example, if the state of
// Illinois has been excluded, then you cannot target Chicago.
// <li>You must not target a location if you are also targeting its parent. For example, if you
// are targeting New York City, you must not have the state of New York as one of the targeted
// locations.
// <li>You cannot explicitly define inclusions or exclusions that are already implicit. For
// example, if you explicitly include California, you implicitly exclude all other states. You
// therefore cannot explicitly exclude Florida, because it is already implicitly excluded.
// Conversely if you explicitly exclude Florida, you cannot explicitly include California.
// </ul>
//

type GeoTargeting struct {

	// TargetedLocations
	//
	// The geographical locations being targeted by the {@link LineItem}.
	//

	TargetedLocations []*Location `xml:"targetedLocations"`

	// ExcludedLocations
	//
	// The geographical locations being excluded by the {@link LineItem}.
	//

	ExcludedLocations []*Location `xml:"excludedLocations"`
}

// GeoTargetingError
//
// Lists all errors associated with geographical targeting for a
// {@link LineItem}.
//

type GeoTargetingError struct {
	Reason string `xml:"reason"`
}

// Goal
//
// Defines the criteria a {@link LineItem} needs to satisfy to meet its delivery goal.
//

type Goal struct {

	// GoalType
	//
	// The type of the goal for the {@code LineItem}. It defines the period over which the goal for
	// {@code LineItem} should be reached.
	//

	GoalType *GoalType `xml:"goalType"`

	// UnitType
	//
	// The type of the goal unit for the {@code LineItem}.
	//

	UnitType *UnitType `xml:"unitType"`

	// Units
	//
	// If this is a primary goal, it represents the number or percentage of impressions or clicks that
	// will be reserved for the {@code LineItem}. If the line item is of type {@link
	// LineItemType#SPONSORSHIP}, it represents the percentage of available impressions reserved. If
	// the line item is of type {@link LineItemType#BULK} or {@link LineItemType#PRICE_PRIORITY}, it
	// represents the number of remaining impressions reserved. If the line item is of type {@link
	// LineItemType#NETWORK} or {@link LineItemType#HOUSE}, it represents the percentage of remaining
	// impressions reserved.
	//
	// <p>If this is a secondary goal, it represents the number of impressions or conversions that the
	// line item will stop serving at if reached. For valid line item services, see {@link
	// LineItem#secondaryGoals}.
	//

	Units *int64 `xml:"units"`
}

// GrpSettings
//
// {@code GrpSettings} contains information for a line item that will have a target demographic when
// serving. This information will be used to set up tracking and enable reporting on the demographic
// information.
//

type GrpSettings struct {

	// MinTargetAge
	//
	// Specifies the minimum target age (in years) of the {@link LineItem}. This field is only
	// applicable if {@link #provider} is not null.
	//

	MinTargetAge *int64 `xml:"minTargetAge"`

	// MaxTargetAge
	//
	// Specifies the maximum target age (in years) of the {@link LineItem}. This field is only
	// applicable if {@link #provider} is not null.
	//

	MaxTargetAge *int64 `xml:"maxTargetAge"`

	// TargetGender
	//
	// Specifies the target gender of the {@link LineItem}. This field is only applicable if {@link
	// #provider} is not null.
	//

	TargetGender *GrpTargetGender `xml:"targetGender"`

	// Provider
	//
	// Specifies the GRP provider of the {@link LineItem}.
	//

	Provider *GrpProvider `xml:"provider"`

	// InTargetRatioEstimateMilliPercent
	//
	// Estimate for the in-target ratio given the line item's audience targeting. This field is only
	// applicable if {@link #provider} is Nielsen, {@link LineItem#primaryGoal#unitType} is in-target
	// impressions, and {@link LineItem#CostType} is in-target CPM. This field determines the
	// in-target ratio to use for pacing Nielsen line items before Nielsen reporting data is
	// available. Represented as a milli percent, so 55.7% becomes 55700.
	//

	InTargetRatioEstimateMilliPercent *int64 `xml:"inTargetRatioEstimateMilliPercent"`

	// NielsenCtvPacingType
	//
	// Specifies which pacing computation to apply in pacing to impressions from connected devices.
	// This field is required if {@code enableNielsenCoViewingSupport} is true.
	//

	NielsenCtvPacingType *NielsenCtvPacingType `xml:"nielsenCtvPacingType"`

	// PacingDeviceCategorizationType
	//
	// Specifies whether to use Google or Nielsen device breakdown in Nielsen Line Item auto pacing.
	//

	PacingDeviceCategorizationType *PacingDeviceCategorizationType `xml:"pacingDeviceCategorizationType"`

	// ApplyTrueCoview

	ApplyTrueCoview *bool `xml:"applyTrueCoview"`
}

// GrpSettingsError
//
// Errors associated with line items with GRP settings.
//

type GrpSettingsError struct {
	Reason string `xml:"reason"`
}

// ImageError
//
// Lists all errors associated with images.
//

type ImageError struct {
	Reason string `xml:"reason"`
}

// InternalApiError
//
// Indicates that a server-side error has occured. {@code InternalApiError}s
// are generally not the result of an invalid request or message sent by the
// client.
//

type InternalApiError struct {
	Reason string `xml:"reason"`
}

// InvalidUrlError
//
// Lists all errors associated with URLs.
//

type InvalidUrlError struct {
	Reason string `xml:"reason"`
}

// InventorySizeTargeting
//
// Represents a collection of targeted and excluded inventory sizes. This is currently only
// available on {@link YieldGroup} and {@link TrafficDataRequest}.
//

type InventorySizeTargeting struct {

	// IsTargeted
	//
	// Whether the inventory sizes should be targeted or excluded.
	//

	IsTargeted *bool `xml:"isTargeted"`

	// TargetedSizes
	//
	// A list of {@link TargetedSizeDto}s.
	//

	TargetedSizes []*TargetedSize `xml:"targetedSizes"`
}

// InventoryTargeting
//
// A collection of targeted and excluded ad units and placements.
//

type InventoryTargeting struct {

	// TargetedAdUnits
	//
	// A list of targeted {@link AdUnitTargeting}.
	//

	TargetedAdUnits []*AdUnitTargeting `xml:"targetedAdUnits"`

	// ExcludedAdUnits
	//
	// A list of excluded {@link AdUnitTargeting}.
	//

	ExcludedAdUnits []*AdUnitTargeting `xml:"excludedAdUnits"`

	// TargetedPlacementIds
	//
	// A list of targeted {@link Placement} ids.
	//

	TargetedPlacementIds []*int64 `xml:"targetedPlacementIds"`
}

// InventoryTargetingError
//
// Lists all inventory errors caused by associating a line item with a targeting
// expression.
//

type InventoryTargetingError struct {
	Reason string `xml:"reason"`
}

// InventoryUrl
//
// The representation of an inventory Url that is used in targeting.
//

type InventoryUrl struct {

	// Id

	Id *int64 `xml:"id"`
}

// InventoryUrlTargeting
//
// A collection of targeted inventory urls.
//

type InventoryUrlTargeting struct {

	// TargetedUrls

	TargetedUrls []*InventoryUrl `xml:"targetedUrls"`

	// ExcludedUrls

	ExcludedUrls []*InventoryUrl `xml:"excludedUrls"`
}

// LabelEntityAssociationError
//
// Errors specific to creating label entity associations.
//

type LabelEntityAssociationError struct {
	Reason string `xml:"reason"`
}

// LineItemAction
//
// Represents the actions that can be performed on {@link LineItem} objects.
//

type LineItemAction struct {
}

// LineItemActivityAssociationError
//
// Errors specific to associating activities to line items.
//

type LineItemActivityAssociationError struct {
	Reason string `xml:"reason"`
}

// LineItemActivityAssociation
//
// A {@code LineItemActivityAssociation} associates a {@link LineItem} with an {@link Activity} so
// that the conversions of the {@link Activity} can be counted against the {@link LineItem}.
//

type LineItemActivityAssociation struct {

	// ActivityId
	//
	// The ID of the {@link Activity} to which the {@link LineItem} should be associated. This
	// attribute is required.
	//

	ActivityId *int `xml:"activityId"`

	// ClickThroughConversionCost
	//
	// The amount of money to attribute per click through conversion. This attribute is required for
	// creating a {@code LineItemActivityAssociation}. The currency code is readonly and should match
	// the {@link LineItem}.
	//

	ClickThroughConversionCost *Money `xml:"clickThroughConversionCost"`

	// ViewThroughConversionCost
	//
	// The amount of money to attribute per view through conversion. This attribute is required for
	// creating a {@code LineItemActivityAssociation}. The currency code is readonly and should match
	// the {@link LineItem}.
	//

	ViewThroughConversionCost *Money `xml:"viewThroughConversionCost"`
}

// LineItemCreativeAssociationError
//
// Lists all errors associated with line item-to-creative association dates.
//

type LineItemCreativeAssociationError struct {
	Reason string `xml:"reason"`
}

// LineItemDealInfoDto
//
// Data transfer object for the exchange deal info of a line item.
//

type LineItemDealInfoDto struct {

	// ExternalDealId
	//
	// The external deal ID shared between seller and buyer. This field is only present if the deal
	// has been finalized. This attribute is read-only and is assigned by Google.
	//

	ExternalDealId *int64 `xml:"externalDealId"`
}

// LineItem
//
// {@link LineItem} is an advertiser's commitment to purchase a specific number of ad impressions,
// clicks, or time.
//

type LineItem struct {

	// LineItemSummary
	*LineItemSummary

	// Targeting
	//
	// Contains the targeting criteria for the ad campaign. This attribute is required.
	//

	Targeting *Targeting `xml:"targeting"`

	// CreativeTargetings
	//
	// A list of {@link CreativeTargeting} objects that can be used to specify creative level
	// targeting for this line item. Creative level targeting is specified in a creative placeholder's
	// {@link CreativePlaceholder#targetingName} field by referencing the creative targeting's {@link
	// CreativeTargeting#name name}. It also needs to be re-specified in the {@link
	// LineItemCreativeAssociation#targetingName} field when associating a line item with a creative
	// that fits into that placeholder.
	//

	CreativeTargetings []*CreativeTargeting `xml:"creativeTargetings"`
}

// LineItemError
//
// A catch-all error that lists all generic errors associated with LineItem.
//

type LineItemError struct {
	Reason string `xml:"reason"`
}

// LineItemFlightDateError
//
// Lists all errors associated with LineItem start and end dates.
//

type LineItemFlightDateError struct {
	Reason string `xml:"reason"`
}

// LineItemOperationError
//
// Lists all errors for executing operations on line items
//

type LineItemOperationError struct {
	Reason string `xml:"reason"`
}

// LineItemPage
//
// Captures a page of {@link LineItem} objects.
//

type LineItemPage struct {

	// TotalResultSetSize
	//
	// The size of the total result set to which this page belongs.
	//

	TotalResultSetSize *int `xml:"totalResultSetSize"`

	// StartIndex
	//
	// The absolute index in the total result set on which this page begins.
	//

	StartIndex *int `xml:"startIndex"`

	// Results
	//
	// The collection of line items contained within this page.
	//

	Results []*LineItem `xml:"results"`
}

// LineItemSummary
//
// The {@code LineItemSummary} represents the base class from which a {@code LineItem} is derived.
//

type LineItemSummary struct {

	// OrderId
	//
	// The ID of the {@link Order} to which the {@code LineItem} belongs. This attribute is required.
	//

	OrderId *int64 `xml:"orderId"`

	// Id
	//
	// Uniquely identifies the {@code LineItem}. This attribute is read-only and is assigned by Google
	// when a line item is created.
	//

	Id *int64 `xml:"id"`

	// Name
	//
	// The name of the line item. This attribute is required and has a maximum length of 255
	// characters.
	//

	Name *string `xml:"name"`

	// ExternalId
	//
	// An identifier for the {@code LineItem} that is meaningful to the publisher. This attribute is
	// optional and has a maximum length of 255 characters.
	//

	ExternalId *string `xml:"externalId"`

	// OrderName
	//
	// The name of the {@link Order}. This value is read-only.
	//

	OrderName *string `xml:"orderName"`

	// StartDateTime
	//
	// The date and time on which the {@code LineItem} is enabled to begin serving. This attribute is
	// required and must be in the future.
	//

	StartDateTime *DateTime `xml:"startDateTime"`

	// StartDateTimeType
	//
	// Specifies whether to start serving to the {@code LineItem} right away, in an hour, etc. This
	// attribute is optional and defaults to {@link StartDateTimeType#USE_START_DATE_TIME}.
	//

	StartDateTimeType *StartDateTimeType `xml:"startDateTimeType"`

	// EndDateTime
	//
	// The date and time on which the {@code LineItem} will stop serving. This attribute is required
	// unless {@link LineItem#unlimitedEndDateTime} is set to {@code true}. If specified, it must be
	// after the {@link LineItem#startDateTime}. This end date and time does not include auto
	// extension days.
	//

	EndDateTime *DateTime `xml:"endDateTime"`

	// AutoExtensionDays
	//
	// The number of days to allow a line item to deliver past its {@link #endDateTime}. A maximum of
	// 7 days is allowed. This is feature is only available for Ad Manager 360 accounts.
	//

	AutoExtensionDays *int `xml:"autoExtensionDays"`

	// UnlimitedEndDateTime
	//
	// Specifies whether or not the {@code LineItem} has an end time. This attribute is optional and
	// defaults to false. It can be be set to {@code true} for only line items of type {@link
	// LineItemType#SPONSORSHIP}, {@link LineItemType#NETWORK}, {@link LineItemType#PRICE_PRIORITY}
	// and {@link LineItemType#HOUSE}.
	//

	UnlimitedEndDateTime *bool `xml:"unlimitedEndDateTime"`

	// CreativeRotationType
	//
	// The strategy used for displaying multiple {@link Creative} objects that are associated with the
	// {@code LineItem}. This attribute is required.
	//

	CreativeRotationType *CreativeRotationType `xml:"creativeRotationType"`

	// DeliveryRateType
	//
	// The strategy for delivering ads over the course of the line item's duration. This attribute is
	// optional and defaults to {@link DeliveryRateType#EVENLY} or {@link
	// DeliveryRateType#FRONTLOADED} depending on the network's configuration.
	//

	DeliveryRateType *DeliveryRateType `xml:"deliveryRateType"`

	// DeliveryForecastSource
	//
	// Strategy for choosing forecasted traffic shapes to pace line items. This field is optional and
	// defaults to {@link DeliveryForecastSource#HISTORICAL}.
	//

	DeliveryForecastSource *DeliveryForecastSource `xml:"deliveryForecastSource"`

	// CustomPacingCurve
	//
	// The curve that is used to pace the line item's delivery. This field is required if and only if
	// the delivery forecast source is {@link DeliveryForecastSource#CUSTOM_PACING_CURVE}.
	//

	CustomPacingCurve *CustomPacingCurve `xml:"customPacingCurve"`

	// RoadblockingType
	//
	// The strategy for serving roadblocked creatives, i.e. instances where multiple creatives must be
	// served together on a single web page. This attribute is optional and defaults to {@link
	// RoadblockingType#ONE_OR_MORE}.
	//

	RoadblockingType *RoadblockingType `xml:"roadblockingType"`

	// SkippableAdType
	//
	// The nature of the line item's creatives' skippability. This attribute is optional, only
	// applicable for video line items, and defaults to {@link SkippableAdType#NOT_SKIPPABLE}.
	//

	SkippableAdType *SkippableAdType `xml:"skippableAdType"`

	// FrequencyCaps
	//
	// The set of frequency capping units for this {@code LineItem}. This attribute is optional.
	//

	FrequencyCaps []*FrequencyCap `xml:"frequencyCaps"`

	// LineItemType
	//
	// Indicates the line item type of a {@code LineItem}. This attribute is required.
	//
	// <p>The line item type determines the default priority of the line item. More information can be
	// found on the <a href="https://support.google.com/admanager/answer/177279">Ad Manager Help
	// Center</a>.
	//

	LineItemType *LineItemType `xml:"lineItemType"`

	// Priority
	//
	// The priority for the line item. Valid values range from 1 to 16. This field is optional and
	// defaults to the default priority of the {@link LineItemType}.
	//
	// <p>The following table shows the default, minimum, and maximum priority values are for each
	// line item type:
	//
	// <table>
	// <tr>
	// <th colspan="2" scope="col">
	// LineItemType - default priority (minimum priority, maximum priority)
	// </th>
	// </tr>
	// <tr>
	// <td>{@link LineItemType#SPONSORSHIP}</td>
	// <td>4 (2, 5)</td>
	// </tr>
	// <tr>
	// <td>{@link LineItemType#STANDARD}</td>
	// <td>8 (6, 10)</td>
	// </tr>
	// <tr>
	// <td>{@link LineItemType#NETWORK}</td>
	// <td>12 (11, 14)</td>
	// </tr>
	// <tr>
	// <td>{@link LineItemType#BULK}</td>
	// <td>12 (11, 14)</td>
	// </tr>
	// <tr>
	// <td>{@link LineItemType#PRICE_PRIORITY}</td>
	// <td>12 (11, 14)</td>
	// </tr>
	// <tr>
	// <td>{@link LineItemType#HOUSE}</td>
	// <td>16 (15, 16)</td>
	// </tr>
	// <tr>
	// <td>{@link LineItemType#CLICK_TRACKING}</td>
	// <td>16 (1, 16)</td>
	// </tr>
	// <tr>
	// <td>{@link LineItemType#AD_EXCHANGE}</td>
	// <td>12 (1, 16)</td>
	// </tr>
	// <td>{@link LineItemType#ADSENSE}</td>
	// <td>12 (1, 16)</td>
	// </tr>
	// <td>{@link LineItemType#BUMPER}</td>
	// <td>16 (15, 16)</td>
	// </tr>
	// </table>
	//
	// <p>This field can only be edited by certain networks, otherwise a {@link PermissionError} will
	// occur.
	//

	Priority *int `xml:"priority"`

	// CostPerUnit
	//
	// The amount of money to spend per impression or click. This attribute is required for creating a
	// {@code LineItem}.
	//

	CostPerUnit *Money `xml:"costPerUnit"`

	// ValueCostPerUnit
	//
	// An amount to help the adserver rank inventory. {@link LineItem#valueCostPerUnit} artificially
	// raises the value of inventory over the {@link LineItem#costPerUnit} but avoids raising the
	// actual {@link LineItem#costPerUnit}. This attribute is optional and defaults to a {@link Money}
	// object in the local currency with {@link Money#microAmount} 0.
	//

	ValueCostPerUnit *Money `xml:"valueCostPerUnit"`

	// CostType
	//
	// The method used for billing this {@code LineItem}. This attribute is required.
	//

	CostType *CostType `xml:"costType"`

	// DiscountType
	//
	// The type of discount being applied to a {@code LineItem}, either percentage based or absolute.
	// This attribute is optional and defaults to {@link LineItemDiscountType#PERCENTAGE}.
	//

	DiscountType *LineItemDiscountType `xml:"discountType"`

	// Discount
	//
	// The number here is either a percentage or an absolute value depending on the {@code
	// LineItemDiscountType}. If the {@code LineItemDiscountType} is {@link
	// LineItemDiscountType#PERCENTAGE}, then only non-fractional values are supported.
	//

	Discount *float64 `xml:"discount"`

	// ContractedUnitsBought
	//
	// This attribute is only applicable for certain {@link #lineItemType line item services} and acts as
	// an "FYI" or note, which does not impact adserving or other backend systems.
	//
	// <p>For {@link LineItemType#SPONSORSHIP} line items, this represents the minimum quantity, which
	// is a lifetime impression volume goal for reporting purposes only.
	//
	// <p>For {@link LineItemType#STANDARD} line items, this represent the contracted quantity, which
	// is the number of units specified in the contract the advertiser has bought for this {@code
	// LineItem}. This field is just a "FYI" for traffickers to manually intervene with the {@code
	// LineItem} when needed. This attribute is only available for {@link LineItemType#STANDARD} line
	// items if you have this feature enabled on your network.
	//

	ContractedUnitsBought *int64 `xml:"contractedUnitsBought"`

	// CreativePlaceholders
	//
	// Details about the creatives that are expected to serve through this {@code LineItem}. This
	// attribute is required and replaces the {@code creativeSizes} attribute.
	//

	CreativePlaceholders []*CreativePlaceholder `xml:"creativePlaceholders"`

	// ActivityAssociations
	//
	// This attribute is required and meaningful only if the {@link LineItem#costType} is {@link
	// CostType.CPA}.
	//

	ActivityAssociations []*LineItemActivityAssociation `xml:"activityAssociations"`

	// EnvironmentType
	//
	// The environment that the {@code LineItem} is targeting. The default value is {@link
	// EnvironmentType#BROWSER}. If this value is {@link EnvironmentType#VIDEO_PLAYER}, then this line
	// item can only target {@code AdUnits} that have {@code AdUnitSizes} whose {@code
	// environmentType} is also {@code VIDEO_PLAYER}.
	//

	EnvironmentType *EnvironmentType `xml:"environmentType"`

	// AllowedFormats
	//
	// The set of {@link allowedFormats} that this programmatic line item can have. If the set is
	// empty, this line item allows all formats.
	//

	AllowedFormats []*AllowedFormats `xml:"allowedFormats"`

	// CompanionDeliveryOption
	//
	// The delivery option for companions. Setting this field is only meaningful if the following
	// conditions are met:
	//
	// <ol>
	// <li>The <b>Guaranteed roadblocks</b> feature is enabled on your network.
	// <li>One of the following is true (both cannot be true, these are mutually exclusive).
	// <ul>
	// <li>The {@link #environmentType} is {@link EnvironmentType#VIDEO_PLAYER}.
	// <li>The {@link #roadblockingType} is {@link RoadblockingType#CREATIVE_SET}.
	// </ul>
	// </ol>
	//
	// <p>This field is optional and defaults to {@link CompanionDeliveryOption#OPTIONAL} if the above
	// conditions are met. In all other cases it defaults to {@link CompanionDeliveryOption#UNKNOWN}
	// and is not meaningful.
	//

	CompanionDeliveryOption *CompanionDeliveryOption `xml:"companionDeliveryOption"`

	// AllowOverbook
	//
	// The flag indicates whether overbooking should be allowed when creating or updating reservations
	// of line item services {@link LineItemType#SPONSORSHIP} and {@link LineItemType#STANDARD}. When
	// true, operations on this line item will never trigger a {@link ForecastError}, which
	// corresponds to an overbook warning in the UI. The default value is false.
	//
	// <p>Note: this field will not persist on the line item itself, and the value will only affect
	// the current request.
	//

	AllowOverbook *bool `xml:"allowOverbook"`

	// SkipInventoryCheck
	//
	// The flag indicates whether the inventory check should be skipped when creating or updating a
	// line item. The default value is false.
	//
	// <p>Note: this field will not persist on the line item itself, and the value will only affect
	// the current request.
	//

	SkipInventoryCheck *bool `xml:"skipInventoryCheck"`

	// SkipCrossSellingRuleWarningChecks
	//
	// True to skip checks for warnings from rules applied to line items targeting inventory shared by
	// a distributor partner for cross selling when performing an action on this line item. The
	// default is false.
	//

	SkipCrossSellingRuleWarningChecks *bool `xml:"skipCrossSellingRuleWarningChecks"`

	// ReserveAtCreation
	//
	// The flag indicates whether inventory should be reserved when creating a line item of services
	// {@link LineItemType#SPONSORSHIP} and {@link LineItemType#STANDARD} in an unapproved {@link
	// Order}. The default value is false.
	//

	ReserveAtCreation *bool `xml:"reserveAtCreation"`

	// Stats
	//
	// Contains trafficking statistics for the line item. This attribute is readonly and is populated
	// by Google. This will be {@code null} in case there are no statistics for a line item yet.
	//

	Stats *Stats `xml:"stats"`

	// DeliveryIndicator
	//
	// Indicates how well the line item has been performing. This attribute is readonly and is
	// populated by Google. This will be {@code null} if the delivery indicator information is not
	// available due to one of the following reasons:
	//
	// <ol>
	// <li>The line item is not delivering.
	// <li>The line item has an unlimited goal or cap.
	// <li>The line item has a percentage based goal or cap.
	// </ol>
	//

	DeliveryIndicator *DeliveryIndicator `xml:"deliveryIndicator"`

	// DeliveryData
	//
	// Delivery data provides the number of clicks or impressions delivered for a {@link LineItem} in
	// the last 7 days. This attribute is readonly and is populated by Google. This will be {@code
	// null} if the delivery data cannot be computed due to one of the following reasons:
	//
	// <ol>
	// <li>The line item is not deliverable.
	// <li>The line item has completed delivering more than 7 days ago.
	// <li>The line item has an absolute-based goal. {@link LineItem#deliveryIndicator} should be
	// used to track its progress in this case.
	//

	DeliveryData *DeliveryData `xml:"deliveryData"`

	// Budget
	//
	// The amount of money allocated to the {@code LineItem}. This attribute is readonly and is
	// populated by Google. The currency code is readonly.
	//

	Budget *Money `xml:"budget"`

	// Status
	//
	// The status of the {@code LineItem}. This attribute is readonly.
	//

	Status *ComputedStatus `xml:"status"`

	// ReservationStatus
	//
	// Describes whether or not inventory has been reserved for the {@code LineItem}. This attribute
	// is readonly and is assigned by Google.
	//

	ReservationStatus *LineItemSummaryReservationStatus `xml:"reservationStatus"`

	// IsArchived
	//
	// The archival status of the {@code LineItem}. This attribute is readonly.
	//

	IsArchived *bool `xml:"isArchived"`

	// WebPropertyCode
	//
	// The web property code used for dynamic allocation line items. This web property is only
	// required with line item services {@link LineItemType#AD_EXCHANGE} and {@link
	// LineItemType#ADSENSE}.
	//

	WebPropertyCode *string `xml:"webPropertyCode"`

	// AppliedLabels
	//
	// The set of labels applied directly to this line item.
	//

	AppliedLabels []*AppliedLabel `xml:"appliedLabels"`

	// EffectiveAppliedLabels
	//
	// Contains the set of labels inherited from the order that contains this line item and the
	// advertiser that owns the order. If a label has been negated, only the negated label is
	// returned. This field is readonly and is assigned by Google.
	//

	EffectiveAppliedLabels []*AppliedLabel `xml:"effectiveAppliedLabels"`

	// DisableSameAdvertiserCompetitiveExclusion
	//
	// If a line item has a series of competitive exclusions on it, it could be blocked from serving
	// with line items from the same advertiser. Setting this to {@code true} will allow line items
	// from the same advertiser to serve regardless of the other competitive exclusion labels being
	// applied.
	//

	DisableSameAdvertiserCompetitiveExclusion *bool `xml:"disableSameAdvertiserCompetitiveExclusion"`

	// LastModifiedByApp
	//
	// The application that last modified this line item. This attribute is read only and is assigned
	// by Google.
	//

	LastModifiedByApp *string `xml:"lastModifiedByApp"`

	// Notes
	//
	// Provides any additional notes that may annotate the {@code LineItem}. This attribute is
	// optional and has a maximum length of 65,535 characters.
	//

	Notes *string `xml:"notes"`

	// CompetitiveConstraintScope
	//
	// The {@code CompetitiveConstraintScope} for the competitive exclusion labels assigned to this
	// line item. This field is optional, defaults to {@link CompetitiveConstraintScope#POD}, and only
	// applies to video line items.
	//

	CompetitiveConstraintScope *CompetitiveConstraintScope `xml:"competitiveConstraintScope"`

	// LastModifiedDateTime
	//
	// The date and time this line item was last modified.
	//

	LastModifiedDateTime *DateTime `xml:"lastModifiedDateTime"`

	// CreationDateTime
	//
	// This attribute may be {@code null} for line items created before this feature was introduced.
	//

	CreationDateTime *DateTime `xml:"creationDateTime"`

	// CustomFieldValues
	//
	// The values of the custom fields associated with this line item.
	//

	CustomFieldValues []*BaseCustomFieldValue `xml:"customFieldValues"`

	// IsMissingCreatives
	//
	// Indicates if a {@code LineItem} is missing any {@link Creative creatives} for the {@code
	// creativePlaceholders} specified.
	//
	// <p>{@link Creative Creatives} can be considered missing for several reasons including:
	//
	// <ul>
	// <li>Not enough {@link Creative creatives} of a certain size have been uploaded, as determined
	// by {@link CreativePlaceholder#expectedCreativeCount}. For example a {@code LineItem}
	// specifies 750x350, 400x200 but only a 750x350 was uploaded. Or {@code LineItem} specifies
	// 750x350 with an expected count of 2, but only one was uploaded.
	// <li>The {@link Creative#appliedLabels} of an associated {@code Creative} do not match the
	// {@link CreativePlaceholder#effectiveAppliedLabels} of the {@code LineItem}. For example
	// {@code LineItem} specifies 750x350 with a Foo {@code AppliedLabel} but a 750x350 creative
	// without a {@code AppliedLabel} was uploaded.
	// </ul>
	//

	IsMissingCreatives *bool `xml:"isMissingCreatives"`

	// ProgrammaticCreativeSource
	//
	// Indicates the {@link ProgrammaticCreativeSource} of the programmatic line item. This is a
	// read-only field. Any changes must be made on the {@link ProposalLineItem}.
	//

	ProgrammaticCreativeSource *ProgrammaticCreativeSource `xml:"programmaticCreativeSource"`

	// ThirdPartyMeasurementSettings

	ThirdPartyMeasurementSettings *ThirdPartyMeasurementSettings `xml:"thirdPartyMeasurementSettings"`

	// YoutubeKidsRestricted
	//
	// Designates this line item as intended for YT Kids app. If true, all creatives associated with
	// this line item must be reviewed and approved. See the <a
	// href="https://support.google.com/yt-partner-sales/answer/10015534">Ad Manager Help Center </a>
	// for more information.
	//

	YoutubeKidsRestricted *bool `xml:"youtubeKidsRestricted"`

	// VideoMaxDuration
	//
	// The max duration of a video creative associated with this {@code LineItem} in milliseconds.
	//
	// <p>This attribute is only meaningful for video line items. For version v202011 and earlier,
	// this attribute is optional and defaults to 0. For version v202102 and later, this attribute is
	// required for video line items and must be greater than 0.
	//

	VideoMaxDuration *int64 `xml:"videoMaxDuration"`

	// PrimaryGoal
	//
	// The primary goal that this {@code LineItem} is associated with, which is used in its pacing and
	// budgeting.
	//

	PrimaryGoal *Goal `xml:"primaryGoal"`

	// SecondaryGoals
	//
	// The secondary goals that this {@code LineItem} is associated with. It is required and
	// meaningful only if the {@link LineItem#costType} is {@link CostType.CPA} or if the {@link
	// LineItem#lineItemType} is {@link LineItemType#SPONSORSHIP} and {@link LineItem#costType} is
	// {@link CostType.CPM}.
	//

	SecondaryGoals []*Goal `xml:"secondaryGoals"`

	// GrpSettings
	//
	// Contains the information for a line item which has a target GRP demographic.
	//

	GrpSettings *GrpSettings `xml:"grpSettings"`

	// DealInfo
	//
	// The deal information associated with this line item, if it is programmatic.
	//

	DealInfo *LineItemDealInfoDto `xml:"dealInfo"`

	// ViewabilityProviderCompanyIds
	//
	// Optional IDs of the {@link Company} that provide ad verification for this line item. {@link
	// Company.Type#VIEWABILITY_PROVIDER}.
	//

	ViewabilityProviderCompanyIds []*int64 `xml:"viewabilityProviderCompanyIds"`

	// ChildContentEligibility
	//
	// Child content eligibility designation for this line item.
	//
	// <p>This field is optional and defaults to {@link ChildContentEligibility#DISALLOWED}.
	//

	ChildContentEligibility *ChildContentEligibility `xml:"childContentEligibility"`

	// CustomVastExtension
	//
	// Custom XML to be rendered in a custom VAST response at serving time.
	//

	CustomVastExtension *string `xml:"customVastExtension"`
}

// Location
//
// A {@link Location} represents a geographical entity that can be targeted. If a location type is
// not available because of the API version you are using, the location will be represented as just
// the base class, otherwise it will be sub-classed correctly.
//

type Location struct {

	// Id
	//
	// Uniquely identifies each {@code Location}.
	//

	Id *int64 `xml:"id"`

	// Type
	//
	// The location type for this geographical entity (ex. "COUNTRY", "CITY", "STATE", "COUNTY", etc.)
	//

	Type *string `xml:"type"`

	// CanonicalParentId
	//
	// The nearest location parent's ID for this geographical entity.
	//

	CanonicalParentId *int `xml:"canonicalParentId"`

	// DisplayName
	//
	// The localized name of the geographical entity.
	//

	DisplayName *string `xml:"displayName"`
}

// MobileApplicationTargeting
//
// Provides line items the ability to target or exclude users' mobile applications.
//

type MobileApplicationTargeting struct {

	// MobileApplicationIds
	//
	// The {@link MobileApplication#applicationId IDs} that are being targeted or excluded by the
	// {@link LineItem}.
	//

	MobileApplicationIds []*int64 `xml:"mobileApplicationIds"`

	// IsTargeted
	//
	// Indicates whether mobile apps should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//

	IsTargeted *bool `xml:"isTargeted"`
}

// MobileApplicationTargetingError
//
// Lists all errors related to mobile application targeting for a line item.
//

type MobileApplicationTargetingError struct {
	Reason string `xml:"reason"`
}

// MobileCarrier
//
// Represents a mobile carrier. Carrier targeting is only available to Ad Manager mobile publishers.
// For a list of current mobile carriers, you can use {@link
// PublisherQueryLanguageService#mobile_carrier}.
//

type MobileCarrier struct {
}

// MobileCarrierTargeting
//
// Represents mobile carriers that are being targeted or excluded by the {@link LineItem}.
//

type MobileCarrierTargeting struct {

	// IsTargeted
	//
	// Indicates whether mobile carriers should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//

	IsTargeted *bool `xml:"isTargeted"`

	// MobileCarriers
	//
	// Mobile carriers that are being targeted or excluded by the {@link LineItem}.
	//

	MobileCarriers []*Technology `xml:"mobileCarriers"`
}

// MobileDevice
//
// Represents a Mobile Device.
//

type MobileDevice struct {

	// Technology
	*Technology

	// ManufacturerCriterionId
	//
	// Manufacturer Id.
	//

	ManufacturerCriterionId *int64 `xml:"manufacturerCriterionId"`
}

// MobileDeviceSubmodel
//
// Represents a mobile device submodel.
//

type MobileDeviceSubmodel struct {

	// Technology
	*Technology

	// MobileDeviceCriterionId
	//
	// The mobile device id.
	//

	MobileDeviceCriterionId *int64 `xml:"mobileDeviceCriterionId"`

	// DeviceManufacturerCriterionId
	//
	// The device manufacturer id.
	//

	DeviceManufacturerCriterionId *int64 `xml:"deviceManufacturerCriterionId"`
}

// MobileDeviceSubmodelTargeting
//
// Represents mobile devices that are being targeted or excluded by the {@link LineItem}.
//

type MobileDeviceSubmodelTargeting struct {

	// TargetedMobileDeviceSubmodels
	//
	// Mobile device submodels that are being targeted by the {@link LineItem}.
	//

	TargetedMobileDeviceSubmodels []*Technology `xml:"targetedMobileDeviceSubmodels"`

	// ExcludedMobileDeviceSubmodels
	//
	// Mobile device submodels that are being excluded by the {@link LineItem}.
	//

	ExcludedMobileDeviceSubmodels []*Technology `xml:"excludedMobileDeviceSubmodels"`
}

// MobileDeviceTargeting
//
// Represents mobile devices that are being targeted or excluded by the {@link LineItem}.
//

type MobileDeviceTargeting struct {

	// TargetedMobileDevices
	//
	// Mobile devices that are being targeted by the {@link LineItem}.
	//

	TargetedMobileDevices []*Technology `xml:"targetedMobileDevices"`

	// ExcludedMobileDevices
	//
	// Mobile devices that are being excluded by the {@link LineItem}.
	//

	ExcludedMobileDevices []*Technology `xml:"excludedMobileDevices"`
}

// Money
//
// Represents a money amount.
//

type Money struct {

	// CurrencyCode
	//
	// Three letter currency code in string format.
	//

	CurrencyCode *string `xml:"currencyCode"`

	// MicroAmount
	//
	// Money values are always specified in terms of micros which are a millionth
	// of the fundamental currency unit. For US dollars, $1 is 1,000,000 micros.
	//

	MicroAmount *int64 `xml:"microAmount"`
}

// NotNullError
//
// Caused by supplying a null value for an attribute that cannot be null.
//

type NotNullError struct {
	Reason string `xml:"reason"`
}

// NullError
//
// Errors associated with violation of a NOT NULL check.
//

type NullError struct {
	Reason string `xml:"reason"`
}

// NumberValue
//
// Contains a numeric value.
//

type NumberValue struct {

	// Value
	//
	// The numeric value represented as a string.
	//

	Value *string `xml:"value"`
}

// OperatingSystem
//
// Represents an Operating System, such as Linux, Mac OS or Windows.
//

type OperatingSystem struct {
}

// OperatingSystemTargeting
//
// Represents operating systems that are being targeted or excluded by the {@link LineItem}.
//

type OperatingSystemTargeting struct {

	// IsTargeted
	//
	// Indicates whether operating systems should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//

	IsTargeted *bool `xml:"isTargeted"`

	// OperatingSystems
	//
	// Operating systems that are being targeted or excluded by the {@link LineItem}.
	//

	OperatingSystems []*Technology `xml:"operatingSystems"`
}

// OperatingSystemVersion
//
// Represents a specific version of an operating system.
//

type OperatingSystemVersion struct {

	// Technology
	*Technology

	// MajorVersion
	//
	// The operating system major version.
	//

	MajorVersion *int `xml:"majorVersion"`

	// MinorVersion
	//
	// The operating system minor version.
	//

	MinorVersion *int `xml:"minorVersion"`

	// MicroVersion
	//
	// The operating system micro version.
	//

	MicroVersion *int `xml:"microVersion"`
}

// OperatingSystemVersionTargeting
//
// Represents operating system versions that are being targeted or excluded by the {@link LineItem}.
//

type OperatingSystemVersionTargeting struct {

	// TargetedOperatingSystemVersions
	//
	// Operating system versions that are being targeted by the {@link LineItem}.
	//

	TargetedOperatingSystemVersions []*Technology `xml:"targetedOperatingSystemVersions"`

	// ExcludedOperatingSystemVersions
	//
	// Operating system versions that are being excluded by the {@link LineItem}.
	//

	ExcludedOperatingSystemVersions []*Technology `xml:"excludedOperatingSystemVersions"`
}

// OrderActionError
//
// Lists all errors associated with performing actions on {@link Order} objects.
//

type OrderActionError struct {
	Reason string `xml:"reason"`
}

// OrderError
//
// Lists all errors associated with orders.
//

type OrderError struct {
	Reason string `xml:"reason"`
}

// ParseError
//
// Lists errors related to parsing.
//

type ParseError struct {
	Reason string `xml:"reason"`
}

// PauseLineItems
//
// The action used for pausing {@link LineItem} objects.
//

type PauseLineItems struct {
}

func NewPauseLineItems() (requestbody.PerformAction, error) {
	return &PauseLineItems{}, nil
}
func (a PauseLineItems) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a PauseLineItems) GetActionType() string {
	return "PauseLineItems"
}

// PermissionError
//
// Errors related to incorrect permission.
//

type PermissionError struct {
	Reason string `xml:"reason"`
}

// PrecisionError
//
// List all errors associated with number precisions.
//

type PrecisionError struct {
	Reason string `xml:"reason"`
}

// ProgrammaticError
//
// Errors associated with programmatic line items.
//

type ProgrammaticError struct {
	Reason string `xml:"reason"`
}

// PublisherQueryLanguageContextError
//
// An error that occurs while executing a PQL query contained in
// a {@link Statement} object.
//

type PublisherQueryLanguageContextError struct {
	Reason string `xml:"reason"`
}

// PublisherQueryLanguageSyntaxError
//
// An error that occurs while parsing a PQL query contained in a
// {@link Statement} object.
//

type PublisherQueryLanguageSyntaxError struct {
	Reason string `xml:"reason"`
}

// QuotaError
//
// Describes a client-side error on which a user is attempting
// to perform an action to which they have no quota remaining.
//

type QuotaError struct {
	Reason string `xml:"reason"`
}

// RangeError
//
// A list of all errors associated with the Range constraint.
//

type RangeError struct {
	Reason string `xml:"reason"`
}

// RegExError
//
// Caused by supplying a value for an object attribute that does not conform
// to a documented valid regular expression.
//

type RegExError struct {
	Reason string `xml:"reason"`
}

// ReleaseLineItems
//
// The action used for releasing {@link LineItem} objects.
//

type ReleaseLineItems struct {
}

func NewReleaseLineItems() (requestbody.PerformAction, error) {
	return &ReleaseLineItems{}, nil
}
func (a ReleaseLineItems) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ReleaseLineItems) GetActionType() string {
	return "ReleaseLineItems"
}

// RequestPlatformTargeting
//
// Provides line items the ability to target the platform that requests and renders the ad.
//
// <p>The following rules apply for {@link RequestPlatformTargeting}
//
// <ul>
// <li>{@link RequestPlatformTargeting} must be specified for {@link ProposalLineItem}s.
// <li>{@link RequestPlatformTargeting} must be specified for video line items. Empty values for
// {@link RequestPlatformTargeting#targetedRequestPlatforms} mean that all request platforms
// will be targeted.
// <li>{@link RequestPlatformTargeting} is read-only and assigned by Google for non-video line
// items.
// <li>{@link RequestPlatformTargeting} is read-only and assigned by Google for line items
// generated from proposal line items.
// </ul>
//

type RequestPlatformTargeting struct {

	// TargetedRequestPlatforms

	TargetedRequestPlatforms []*RequestPlatform `xml:"targetedRequestPlatforms"`
}

// RequestPlatformTargetingError
//
// Errors related to request platform targeting.
//

type RequestPlatformTargetingError struct {
	Reason string `xml:"reason"`
}

// RequiredCollectionError
//
// A list of all errors to be used for validating sizes of collections.
//

type RequiredCollectionError struct {
	Reason string `xml:"reason"`
}

// RequiredError
//
// Errors due to missing required field.
//

type RequiredError struct {
	Reason string `xml:"reason"`
}

// RequiredNumberError
//
// A list of all errors to be used in conjunction with required number
// validators.
//

type RequiredNumberError struct {
	Reason string `xml:"reason"`
}

// RequiredSizeError
//
// A list of all errors to be used for validating {@link Size}.
//

type RequiredSizeError struct {
	Reason string `xml:"reason"`
}

// ReservationDetailsError
//
// Lists all errors associated with LineItem's reservation details.
//

type ReservationDetailsError struct {
	Reason string `xml:"reason"`
}

// ReserveAndOverbookLineItems
//
// The action used for reserving and overbooking {@link LineItem} objects.
//

type ReserveAndOverbookLineItems struct {
}

// ReserveLineItems
//
// The action used for reserving {@link LineItem} objects.
//

type ReserveLineItems struct {

	// LineItemAction
	*LineItemAction

	// SkipInventoryCheck
	//
	// Indicates whether the inventory check should be skipped when performing this action.
	// The default value is false.
	//

	SkipInventoryCheck *bool `xml:"skipInventoryCheck"`
}

func NewReserveLineItems(

	skipInventoryCheck *bool,

) (requestbody.PerformAction, error) {
	return &ReserveLineItems{

		SkipInventoryCheck: skipInventoryCheck,
	}, nil
}
func (a ReserveLineItems) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ReserveLineItems) GetActionType() string {
	return "ReserveLineItems"
}

// ResumeAndOverbookLineItems
//
// The action used for resuming and overbooking {@link LineItem} objects.
//

type ResumeAndOverbookLineItems struct {
}

// ResumeLineItems
//
// The action used for resuming {@link LineItem} objects.
//

type ResumeLineItems struct {

	// LineItemAction
	*LineItemAction

	// SkipInventoryCheck
	//
	// Indicates whether the inventory check should be skipped when performing this action.
	// The default value is false.
	//

	SkipInventoryCheck *bool `xml:"skipInventoryCheck"`
}

func NewResumeLineItems(

	skipInventoryCheck *bool,

) (requestbody.PerformAction, error) {
	return &ResumeLineItems{

		SkipInventoryCheck: skipInventoryCheck,
	}, nil
}
func (a ResumeLineItems) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ResumeLineItems) GetActionType() string {
	return "ResumeLineItems"
}

// AudienceSegmentError
//
// Errors that could occur on audience segment related requests.
//

type AudienceSegmentError struct {
	Reason string `xml:"reason"`
}

// ServerError
//
// Errors related to the server.
//

type ServerError struct {
	Reason string `xml:"reason"`
}

// SetTopBoxLineItemError
//
// Errors associated with set-top box {@link LineItem line items}.
//

type SetTopBoxLineItemError struct {
	Reason string `xml:"reason"`
}

// SetValue
//
// Contains a set of {@link Value Values}. May not contain duplicates.
//

type SetValue struct {

	// Value
	*Value

	// Values
	//
	// The values. They must all be the same type of {@code Value} and not contain duplicates.
	//

	Values []*Value `xml:"values"`
}

// Size
//
// Represents the dimensions of an {@link AdUnit}, {@link LineItem} or {@link Creative}.
//
// <p>For interstitial size (out-of-page), native, ignored and fluid size, {@link Size} must be 1x1.
//

type Size struct {

	// Width
	//
	// The width of the {@link AdUnit}, {@link LineItem} or {@link Creative}.
	//

	Width *int `xml:"width"`

	// Height
	//
	// The height of the {@link AdUnit}, {@link LineItem} or {@link Creative}.
	//

	Height *int `xml:"height"`

	// IsAspectRatio
	//
	// Whether this size represents an aspect ratio.
	//

	IsAspectRatio *bool `xml:"isAspectRatio"`
}

// SoapRequestHeader
//
// Represents the SOAP request header used by API requests.
//

type SoapRequestHeader struct {

	// NetworkCode
	//
	// The network code to use in the context of a request.
	//

	NetworkCode *string `xml:"networkCode"`

	// ApplicationName
	//
	// The name of client library application.
	//

	ApplicationName *string `xml:"applicationName"`
}

// SoapResponseHeader
//
// Represents the SOAP request header used by API responses.
//

type SoapResponseHeader struct {

	// RequestId

	RequestId *string `xml:"requestId"`

	// ResponseTime

	ResponseTime *int64 `xml:"responseTime"`
}

// Statement
//
// Captures the {@code WHERE}, {@code ORDER BY} and {@code LIMIT} clauses of a
// PQL query. Statements are typically used to retrieve objects of a predefined
// domain type, which makes SELECT clause unnecessary.
// <p>
// An example query text might be {@code "WHERE status = 'ACTIVE' ORDER BY id
// LIMIT 30"}.
// </p>
// <p>
// Statements support bind variables. These are substitutes for literals
// and can be thought of as input parameters to a PQL query.
// </p>
// <p>
// An example of such a query might be {@code "WHERE id = :idValue"}.
// </p>
// <p>
// Statements also support use of the LIKE keyword. This provides wildcard string matching.
// </p>
// <p>
// An example of such a query might be {@code "WHERE name LIKE '%searchString%'"}.
// </p>
// The value for the variable idValue must then be set with an object of type
// {@link Value}, e.g., {@link NumberValue}, {@link TextValue} or
// {@link BooleanValue}.
//

type Statement struct {

	// Query
	//
	// Holds the query in PQL syntax. The syntax is:<br>
	// <code>[WHERE <condition> {[AND | OR] <condition> ...}]</code><br>
	// <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	// <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>
	// <p>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <value></code><br>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <bind variable></code><br>
	// <code><condition> := <property> IN <list></code><br>
	// <code><condition> := <property> IS NULL</code><br>
	// <code><condition> := <property> LIKE <wildcard%match></code><br>
	// <code><bind variable> := :<name></code><br>
	// </p>
	//

	Query *string `xml:"query"`

	// Values
	//
	// Holds keys and values for bind variables and their values. The key is the
	// name of the bind variable. The value is the literal value of the variable.
	// <p>
	// In the example {@code "WHERE status = :bindStatus ORDER BY id LIMIT 30"},
	// the bind variable, represented by {@code :bindStatus} is named {@code
	// bindStatus}, which would also be the parameter map key. The bind variable's
	// value would be represented by a parameter map value of type
	// {@link TextValue}. The final result, for example, would be an entry of
	// {@code "bindStatus" => StringParam("ACTIVE")}.
	// </p>
	//

	Values []*String_ValueMapEntry `xml:"values"`
}

// StatementError
//
// An error that occurs while parsing {@link Statement} objects.
//

type StatementError struct {
	Reason string `xml:"reason"`
}

// Stats
//
// {@code Stats} contains trafficking statistics for {@link LineItem} and {@link
// LineItemCreativeAssociation} objects
//

type Stats struct {

	// ImpressionsDelivered
	//
	// The number of impressions delivered.
	//

	ImpressionsDelivered *int64 `xml:"impressionsDelivered"`

	// ClicksDelivered
	//
	// The number of clicks delivered.
	//

	ClicksDelivered *int64 `xml:"clicksDelivered"`

	// VideoCompletionsDelivered
	//
	// The number of video completions delivered.
	//

	VideoCompletionsDelivered *int64 `xml:"videoCompletionsDelivered"`

	// VideoStartsDelivered
	//
	// The number of video starts delivered.
	//

	VideoStartsDelivered *int64 `xml:"videoStartsDelivered"`

	// ViewableImpressionsDelivered
	//
	// The number of viewable impressions delivered.
	//

	ViewableImpressionsDelivered *int64 `xml:"viewableImpressionsDelivered"`
}

// StringFormatError
//
// A list of error code for reporting invalid content of input strings.
//

type StringFormatError struct {
	Reason string `xml:"reason"`
}

// StringLengthError
//
// Errors for Strings which do not meet given length constraints.
//

type StringLengthError struct {
	Reason string `xml:"reason"`
}

// String_ValueMapEntry
//
// This represents an entry in a map with a key of type String
// and value of type Value.
//

type String_ValueMapEntry struct {

	// Key

	Key *string `xml:"key"`

	// Value

	Value *Value `xml:"value"`
}

// TargetedSize
//
// A size that is targeted on a request.
//

type TargetedSize struct {

	// Size

	Size *Size `xml:"size"`
}

// Targeting
//
// Contains targeting criteria for {@link LineItem} objects. See {@link LineItem#targeting}.
//

type Targeting struct {

	// GeoTargeting
	//
	// Specifies what geographical locations are targeted by the {@link LineItem}. This attribute is
	// optional.
	//

	GeoTargeting *GeoTargeting `xml:"geoTargeting"`

	// InventoryTargeting
	//
	// Specifies what inventory is targeted by the {@link LineItem}. This attribute is required. The
	// line item must target at least one ad unit or placement.
	//

	InventoryTargeting *InventoryTargeting `xml:"inventoryTargeting"`

	// DayPartTargeting
	//
	// Specifies the days of the week and times that are targeted by the {@link LineItem}. This
	// attribute is optional.
	//

	DayPartTargeting *DayPartTargeting `xml:"dayPartTargeting"`

	// DateTimeRangeTargeting
	//
	// Specifies the dates and time ranges that are targeted by the {@link LineItem}. This attribute
	// is optional.
	//

	DateTimeRangeTargeting *DateTimeRangeTargeting `xml:"dateTimeRangeTargeting"`

	// TechnologyTargeting
	//
	// Specifies the browsing technologies that are targeted by the {@link LineItem}. This attribute
	// is optional.
	//

	TechnologyTargeting *TechnologyTargeting `xml:"technologyTargeting"`

	// CustomTargeting
	//
	// Specifies the collection of custom criteria that is targeted by the {@link LineItem}.
	//
	// <p>Once the {@link LineItem} is updated or modified with custom targeting, the server may
	// return a normalized, but equivalent representation of the custom targeting expression.
	//
	// <p>{@code customTargeting} will have up to three levels of expressions including itself.
	//
	// <p>The top level {@code CustomCriteriaSet} i.e. the {@code customTargeting} object can only
	// contain a {@link CustomCriteriaSet.LogicalOperator#OR} of all its children.
	//
	// <p>The second level of {@code CustomCriteriaSet} objects can only contain {@link
	// CustomCriteriaSet.LogicalOperator#AND} of all their children. If a {@link CustomCriteria} is
	// placed on this level, the server will wrap it in a {@link CustomCriteriaSet}.
	//
	// <p>The third level can only comprise of {@link CustomCriteria} objects.
	//
	// <p>The resulting custom targeting tree would be of the form: <br>
	// <img
	// src="https://chart.apis.google.com/chart?cht=gv&chl=digraph{customTargeting_LogicalOperator_OR-%3ECustomCriteriaSet_LogicalOperator_AND_1-%3ECustomCriteria_1;CustomCriteriaSet_LogicalOperator_AND_1-%3Eellipsis1;customTargeting_LogicalOperator_OR-%3Eellipsis2;ellipsis1[label=%22...%22,shape=none,fontsize=32];ellipsis2[label=%22...%22,shape=none,fontsize=32]}&chs=450x200"/>
	//

	CustomTargeting *CustomCriteriaSet `xml:"customTargeting"`

	// UserDomainTargeting
	//
	// Specifies the domains or subdomains that are targeted or excluded by the {@link LineItem}.
	// Users visiting from an IP address associated with those domains will be targeted or excluded.
	// This attribute is optional.
	//

	UserDomainTargeting *UserDomainTargeting `xml:"userDomainTargeting"`

	// ContentTargeting
	//
	// Specifies the video categories and individual videos targeted by the {@link LineItem}.
	//

	ContentTargeting *ContentTargeting `xml:"contentTargeting"`

	// VideoPositionTargeting
	//
	// Specifies targeting against video position services.
	//

	VideoPositionTargeting *VideoPositionTargeting `xml:"videoPositionTargeting"`

	// MobileApplicationTargeting
	//
	// Specifies targeting against mobile applications.
	//

	MobileApplicationTargeting *MobileApplicationTargeting `xml:"mobileApplicationTargeting"`

	// BuyerUserListTargeting
	//
	// Specifies whether buyer user lists are targeted on a programmatic {@link LineItem} or {@link
	// ProposalLineItem}. This attribute is readonly and is populated by Google.
	//

	BuyerUserListTargeting *BuyerUserListTargeting `xml:"buyerUserListTargeting"`

	// InventoryUrlTargeting
	//
	// Specifies the URLs that are targeted by the entity. This is currently only supported by {@link
	// YieldGroup}.
	//

	InventoryUrlTargeting *InventoryUrlTargeting `xml:"inventoryUrlTargeting"`

	// RequestPlatformTargeting
	//
	// Specifies the request platforms that are targeted by the {@link LineItem}. This attribute is
	// required for video line items and for {@link ProposalLineItem}.
	//
	// <p>This value is modifiable for video line items, but read-only for non-video line items.
	//
	// <p>This value is read-only for video line items generated from proposal line items.
	//

	RequestPlatformTargeting *RequestPlatformTargeting `xml:"requestPlatformTargeting"`

	// InventorySizeTargeting
	//
	// Specifies the sizes that are targeted by the entity. This is currently only supported on {@link
	// YieldGroup} and {@link TrafficDataRequest}.
	//

	InventorySizeTargeting *InventorySizeTargeting `xml:"inventorySizeTargeting"`
}

// TeamError
//
// Errors related to a Team.
//

type TeamError struct {
	Reason string `xml:"reason"`
}

// Technology
//
// Represents a technology entity that can be targeted.
//

type Technology struct {

	// Id
	//
	// The unique ID of the {@code Technology}. This value is required for all forms of {@code
	// TechnologyTargeting}.
	//

	Id *int64 `xml:"id"`

	// Name
	//
	// The name of the technology being targeting. This value is read-only and is assigned by Google.
	//

	Name *string `xml:"name"`
}

// TechnologyTargetingError
//
// Technology targeting validation errors.
//

type TechnologyTargetingError struct {
	Reason string `xml:"reason"`
}

// TextValue
//
// Contains a string value.
//

type TextValue struct {

	// Value
	//
	// The string value.
	//

	Value *string `xml:"value"`
}

// ThirdPartyMeasurementSettings
//
// Contains third party auto-pixeling settings for cross-sell Partners.
//

type ThirdPartyMeasurementSettings struct {

	// ViewabilityPartner
	//
	// A field to determine the type of ThirdPartyViewabilityIntegrationPartner. This field default is
	// NONE.
	//

	ViewabilityPartner *ThirdPartyViewabilityIntegrationPartner `xml:"viewabilityPartner"`

	// ViewabilityClientId
	//
	// The third party partner id for YouTube viewability verification.
	//

	ViewabilityClientId *string `xml:"viewabilityClientId"`

	// ViewabilityReportingId
	//
	// The reporting id that maps viewability partner data with a campaign (or a group of related
	// campaigns) specific data.
	//

	ViewabilityReportingId *string `xml:"viewabilityReportingId"`

	// PublisherViewabilityPartner
	//
	// A field to determine the type of publisher's viewability partner. This field default is NONE.
	//

	PublisherViewabilityPartner *ThirdPartyViewabilityIntegrationPartner `xml:"publisherViewabilityPartner"`

	// PublisherViewabilityClientId
	//
	// The third party partner id for YouTube viewability verification for publisher.
	//

	PublisherViewabilityClientId *string `xml:"publisherViewabilityClientId"`

	// PublisherViewabilityReportingId
	//
	// The reporting id that maps viewability partner data with a campaign (or a group of related
	// campaigns) specific data for publisher.
	//

	PublisherViewabilityReportingId *string `xml:"publisherViewabilityReportingId"`

	// BrandLiftPartner
	//
	// A field to determine the type of ThirdPartyBrandLiftIntegrationPartner. This field default is
	// NONE.
	//

	BrandLiftPartner *ThirdPartyBrandLiftIntegrationPartner `xml:"brandLiftPartner"`

	// BrandLiftClientId
	//
	// The third party partner id for YouTube brand lift verification.
	//

	BrandLiftClientId *string `xml:"brandLiftClientId"`

	// BrandLiftReportingId
	//
	// The reporting id that maps brand lift partner data with a campaign (or a group of related
	// campaigns) specific data.
	//

	BrandLiftReportingId *string `xml:"brandLiftReportingId"`

	// ReachPartner
	//
	// A field to determine the type of advertiser's ThirdPartyReachIntegrationPartner. This field
	// default is UNKNOWN.
	//

	ReachPartner *ThirdPartyReachIntegrationPartner `xml:"reachPartner"`

	// ReachClientId
	//
	// The third party partner id for YouTube reach verification for advertiser.
	//

	ReachClientId *string `xml:"reachClientId"`

	// ReachReportingId
	//
	// The reporting id that maps reach partner data with a campaign (or a group of related campaigns)
	// specific data for advertiser.
	//

	ReachReportingId *string `xml:"reachReportingId"`

	// PublisherReachPartner
	//
	// A field to determine the type of publisher's ThirdPartyReachIntegrationPartner. This field
	// default is UNKNOWN.
	//

	PublisherReachPartner *ThirdPartyReachIntegrationPartner `xml:"publisherReachPartner"`

	// PublisherReachClientId
	//
	// The third party partner id for YouTube reach verification for publisher.
	//

	PublisherReachClientId *string `xml:"publisherReachClientId"`

	// PublisherReachReportingId
	//
	// The reporting id that maps reach partner data with a campaign (or a group of related campaigns)
	// specific data for publisher.
	//

	PublisherReachReportingId *string `xml:"publisherReachReportingId"`
}

// TimeOfDay
//
// Represents a specific time in a day.
//

type TimeOfDay struct {

	// Hour
	//
	// Hour in 24 hour time (0..24). This field must be between 0 and 24,
	// inclusive. This field is required.
	//

	Hour *int `xml:"hour"`

	// Minute
	//
	// Minutes in an hour. Currently, only 0, 15, 30, and 45 are supported. This
	// field is required.
	//

	Minute *MinuteOfHour `xml:"minute"`
}

// TimeZoneError
//
// Errors related to timezones.
//

type TimeZoneError struct {
	Reason string `xml:"reason"`
}

// TranscodingError
//
// Errors associated with the video and audio transcoding flow.
//

type TranscodingError struct {
	Reason string `xml:"reason"`
}

// TypeError
//
// An error for a field which is an invalid type.
//

type TypeError struct {
	Reason string `xml:"reason"`
}

// UnarchiveLineItems
//
// The action used for unarchiving {@link LineItem} objects.
//

type UnarchiveLineItems struct {
}

func NewUnarchiveLineItems() (requestbody.PerformAction, error) {
	return &UnarchiveLineItems{}, nil
}
func (a UnarchiveLineItems) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a UnarchiveLineItems) GetActionType() string {
	return "UnarchiveLineItems"
}

// UniqueError
//
// An error for a field which must satisfy a uniqueness constraint
//

type UniqueError struct {
	Reason string `xml:"reason"`
}

// UpdateResult
//
// Represents the result of performing an action on objects.
//

type UpdateResult struct {

	// NumChanges
	//
	// The number of objects that were changed as a result of performing the
	// action.
	//

	NumChanges *int `xml:"numChanges"`
}

// UserDomainTargeting
//
// Provides line items the ability to target or exclude users visiting their websites from a list of
// domains or subdomains.
//

type UserDomainTargeting struct {

	// Domains
	//
	// The domains or subdomains that are being targeted or excluded by the {@link LineItem}. This
	// attribute is required and the maximum length of each domain is 67 characters.
	//

	Domains []*string `xml:"domains"`

	// Targeted
	//
	// Indicates whether domains should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//

	Targeted *bool `xml:"targeted"`
}

// UserDomainTargetingError
//
// Lists all errors related to user domain targeting for a line item.
//

type UserDomainTargetingError struct {
	Reason string `xml:"reason"`
}

// Value
//
// {@code Value} represents a value.
//

type Value struct {
}

// VideoPosition
//
// Represents a targetable position within a video. A video ad can be targeted
// to a position (pre-roll, all mid-rolls, or post-roll), or to a specific mid-roll index.
//

type VideoPosition struct {

	// PositionType
	//
	// The type of video position (pre-roll, mid-roll, or post-roll).
	//

	PositionType *VideoPositionType `xml:"positionType"`

	// MidrollIndex
	//
	// The index of the mid-roll to target.  Only valid if the {@link positionType} is
	// {@link VideoPositionType#MIDROLL}, otherwise this field will be ignored.
	//

	MidrollIndex *int `xml:"midrollIndex"`
}

// VideoPositionTargeting
//
// Represents positions within and around a video where ads can be targeted to.
//
// <p>Example positions could be {@code pre-roll} (before the video plays), {@code post-roll} (after
// a video has completed playback) and {@code mid-roll} (during video playback).
//
// <p>Empty video position targeting means that all video positions are allowed. If a bumper line
// item has empty video position targeting it will be updated to target all bumper positions.
//

type VideoPositionTargeting struct {

	// TargetedPositions
	//
	// The {@link VideoTargetingPosition} objects being targeted by the video {@link LineItem}.
	//

	TargetedPositions []*VideoPositionTarget `xml:"targetedPositions"`
}

// VideoPositionTargetingError
//
// Lists all errors related to {@link VideoPositionTargeting}.
//

type VideoPositionTargetingError struct {
	Reason string `xml:"reason"`
}

// VideoPositionWithinPod
//
// Represents a targetable position within a pod within a video stream. A video ad can be targeted
// to any position in the pod (first, second, third ... last).  If there is only 1 ad in a pod,
// either first or last will target that position.
//

type VideoPositionWithinPod struct {

	// Index
	//
	// The specific index of the pod. The index is defined as:
	// <ul><li>1 = first</li>
	// <li>2 = second</li>
	// <li>3 = third</li>
	// <li>....</li>
	// <li>100 = last</li></ul>
	// 100 will always be the last position. For example, for a pod with 5 positions, 100 would
	// target position 5. Multiple targets against the index 100 can exist.<br>
	// Positions over 100 are not supported.
	//

	Index *int `xml:"index"`
}

// VideoPositionTarget
//
// Represents the options for targetable positions within a video.
//

type VideoPositionTarget struct {

	// VideoPosition
	//
	// The video position to target.  This attribute is required.
	//

	VideoPosition *VideoPosition `xml:"videoPosition"`

	// VideoBumperType
	//
	// The video bumper type to target. To target a video position or a pod position, this value must
	// be null. To target a bumper position this value must be populated and the line item must have a
	// bumper type. To target a custom ad spot, this value must be null.
	//

	VideoBumperType *VideoBumperType `xml:"videoBumperType"`

	// VideoPositionWithinPod
	//
	// The video position within a pod to target. To target a video position or a bumper position,
	// this value must be null. To target a position within a pod this value must be populated. To
	// target a custom ad spot, this value must be null.
	//

	VideoPositionWithinPod *VideoPositionWithinPod `xml:"videoPositionWithinPod"`

	// AdSpotId
	//
	// A custom spot {@link AdSpot} to target. To target a video position, a bumper type or a video
	// position within a pod this value must be null.
	//

	AdSpotId *int64 `xml:"adSpotId"`
}

// AllowedFormats
//
// The formats that a publisher allows on their programmatic {@link LineItem}
// or {@link ProposalLineItem}.
type AllowedFormats string

const (

	// AllowedFormatsAudio
	//
	// Audio format.
	// This is only relevant for programmatic video line items.
	//
	AllowedFormatsAudio AllowedFormats = "AUDIO"

	// AllowedFormatsUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AllowedFormatsUnknown AllowedFormats = "UNKNOWN"
)

// ApiVersionErrorReasonReason
const (

	// ApiVersionErrorReasonReasonUpdateToNewerVersion
	//
	// Indicates that the operation is not allowed in the version the request
	// was made in.
	//
	ApiVersionErrorReasonReasonUpdateToNewerVersion = "UPDATE_TO_NEWER_VERSION"

	// ApiVersionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ApiVersionErrorReasonReasonUnknown = "UNKNOWN"
)

// AssetErrorReasonReason
//
// The reasons for the target error.
const (

	// AssetErrorReasonReasonNonUniqueName
	//
	// An asset name must be unique across advertiser.
	//
	AssetErrorReasonReasonNonUniqueName = "NON_UNIQUE_NAME"

	// AssetErrorReasonReasonFileNameTooLong
	//
	// The file name is too long.
	//
	AssetErrorReasonReasonFileNameTooLong = "FILE_NAME_TOO_LONG"

	// AssetErrorReasonReasonFileSizeTooLarge
	//
	// The file size is too large.
	//
	AssetErrorReasonReasonFileSizeTooLarge = "FILE_SIZE_TOO_LARGE"

	// AssetErrorReasonReasonMissingRequiredDynamicAllocationClient
	//
	// Required client code is not present in the code snippet.
	//
	AssetErrorReasonReasonMissingRequiredDynamicAllocationClient = "MISSING_REQUIRED_DYNAMIC_ALLOCATION_CLIENT"

	// AssetErrorReasonReasonMissingRequiredDynamicAllocationHeight
	//
	// Required height is not present in the code snippet.
	//
	AssetErrorReasonReasonMissingRequiredDynamicAllocationHeight = "MISSING_REQUIRED_DYNAMIC_ALLOCATION_HEIGHT"

	// AssetErrorReasonReasonMissingRequiredDynamicAllocationWidth
	//
	// Required width is not present in the code snippet.
	//
	AssetErrorReasonReasonMissingRequiredDynamicAllocationWidth = "MISSING_REQUIRED_DYNAMIC_ALLOCATION_WIDTH"

	// AssetErrorReasonReasonMissingRequiredDynamicAllocationFormat
	//
	// Required format is not present in the mobile code snippet.
	//
	AssetErrorReasonReasonMissingRequiredDynamicAllocationFormat = "MISSING_REQUIRED_DYNAMIC_ALLOCATION_FORMAT"

	// AssetErrorReasonReasonInvalidCodeSnippetParameterValue
	//
	// The parameter value in the code snippet is invalid.
	//
	AssetErrorReasonReasonInvalidCodeSnippetParameterValue = "INVALID_CODE_SNIPPET_PARAMETER_VALUE"

	// AssetErrorReasonReasonInvalidAssetId
	//
	// Invalid asset Id.
	//
	AssetErrorReasonReasonInvalidAssetId = "INVALID_ASSET_ID"

	// AssetErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AssetErrorReasonReasonUnknown = "UNKNOWN"
)

// AudienceExtensionErrorReasonReason
//
// Specific audience extension error reasons.
const (

	// AudienceExtensionErrorReasonReasonFrequencyCapsNotSupported
	//
	// Frequency caps are not supported by audience extension line items
	//
	AudienceExtensionErrorReasonReasonFrequencyCapsNotSupported = "FREQUENCY_CAPS_NOT_SUPPORTED"

	// AudienceExtensionErrorReasonReasonInvalidTargeting
	//
	// Audience extension line items can only target geography
	//
	AudienceExtensionErrorReasonReasonInvalidTargeting = "INVALID_TARGETING"

	// AudienceExtensionErrorReasonReasonInventoryUnitTargetingInvalid
	//
	// Audience extension line items can only target audience extension inventory units
	//
	AudienceExtensionErrorReasonReasonInventoryUnitTargetingInvalid = "INVENTORY_UNIT_TARGETING_INVALID"

	// AudienceExtensionErrorReasonReasonInvalidCreativeRotation
	//
	// Audience extension line items do not support {@link CreativeRotationType#SEQUENTIAL}.
	//
	AudienceExtensionErrorReasonReasonInvalidCreativeRotation = "INVALID_CREATIVE_ROTATION"

	// AudienceExtensionErrorReasonReasonInvalidExternalEntityId
	//
	// The given ID of the external entity is not valid
	//
	AudienceExtensionErrorReasonReasonInvalidExternalEntityId = "INVALID_EXTERNAL_ENTITY_ID"

	// AudienceExtensionErrorReasonReasonInvalidLineItemType
	//
	// Audience extension line items only support {@link LineItemType#STANDARD}.
	//
	AudienceExtensionErrorReasonReasonInvalidLineItemType = "INVALID_LINE_ITEM_TYPE"

	// AudienceExtensionErrorReasonReasonInvalidMaxBid
	//
	// Audience extension max bid is invalid when it is greater then the max budget.
	//
	AudienceExtensionErrorReasonReasonInvalidMaxBid = "INVALID_MAX_BID"

	// AudienceExtensionErrorReasonReasonAudienceExtensionBulkUpdateNotAllowed
	//
	// Bulk update for audience extension line items is not allowed.
	//
	AudienceExtensionErrorReasonReasonAudienceExtensionBulkUpdateNotAllowed = "AUDIENCE_EXTENSION_BULK_UPDATE_NOT_ALLOWED"

	// AudienceExtensionErrorReasonReasonUnexpectedAudienceExtensionError
	//
	// An unexpected error occurred.
	//
	AudienceExtensionErrorReasonReasonUnexpectedAudienceExtensionError = "UNEXPECTED_AUDIENCE_EXTENSION_ERROR"

	// AudienceExtensionErrorReasonReasonMaxDailyBudgetAmountExceeded
	//
	// The value entered for the maximum daily budget on an audience extension line item exceeds
	// the maximum allowed.
	//
	AudienceExtensionErrorReasonReasonMaxDailyBudgetAmountExceeded = "MAX_DAILY_BUDGET_AMOUNT_EXCEEDED"

	// AudienceExtensionErrorReasonReasonExternalCampaignAlreadyExists
	//
	// Creating a campaign for a line item that already has an associated campaign is not allowed.
	//
	AudienceExtensionErrorReasonReasonExternalCampaignAlreadyExists = "EXTERNAL_CAMPAIGN_ALREADY_EXISTS"

	// AudienceExtensionErrorReasonReasonAudienceExtensionWithoutFeature
	//
	// Audience extension was specified on a line item but the feature was not
	// enabled.
	//
	AudienceExtensionErrorReasonReasonAudienceExtensionWithoutFeature = "AUDIENCE_EXTENSION_WITHOUT_FEATURE"

	// AudienceExtensionErrorReasonReasonAudienceExtensionWithoutLinkedAccount
	//
	// Audience extension was specified on a line item but no audience extension account has
	// been linked.
	//
	AudienceExtensionErrorReasonReasonAudienceExtensionWithoutLinkedAccount = "AUDIENCE_EXTENSION_WITHOUT_LINKED_ACCOUNT"

	// AudienceExtensionErrorReasonReasonCannotOverrideCreativeSizeWithAudienceExtension
	//
	// Assocation creative size overrides are not allowed with audience extension.
	//
	AudienceExtensionErrorReasonReasonCannotOverrideCreativeSizeWithAudienceExtension = "CANNOT_OVERRIDE_CREATIVE_SIZE_WITH_AUDIENCE_EXTENSION"

	// AudienceExtensionErrorReasonReasonCannotOverrideFieldWithAudienceExtension
	//
	// Some association overrides are not allowed with audience extension.
	//
	AudienceExtensionErrorReasonReasonCannotOverrideFieldWithAudienceExtension = "CANNOT_OVERRIDE_FIELD_WITH_AUDIENCE_EXTENSION"

	// AudienceExtensionErrorReasonReasonOnlyOneCreativePlaceholderAllowed
	//
	// Only one creative placeholder is allowed for an audience extension line item.
	//
	AudienceExtensionErrorReasonReasonOnlyOneCreativePlaceholderAllowed = "ONLY_ONE_CREATIVE_PLACEHOLDER_ALLOWED"

	// AudienceExtensionErrorReasonReasonMultipleAudienceExtensionLineItemsOnOrder
	//
	// Only one audience extension line item can be associated with a given order.
	//
	AudienceExtensionErrorReasonReasonMultipleAudienceExtensionLineItemsOnOrder = "MULTIPLE_AUDIENCE_EXTENSION_LINE_ITEMS_ON_ORDER"

	// AudienceExtensionErrorReasonReasonCannotCopyAudienceExtensionLineItemsAndCreativesTogether
	//
	// Audience extension line items must be copied separately from their associated creatives.
	//
	AudienceExtensionErrorReasonReasonCannotCopyAudienceExtensionLineItemsAndCreativesTogether = "CANNOT_COPY_AUDIENCE_EXTENSION_LINE_ITEMS_AND_CREATIVES_TOGETHER"

	// AudienceExtensionErrorReasonReasonFeatureDeprecated
	//
	// Audience extension is no longer supported and cannot be used.
	//
	AudienceExtensionErrorReasonReasonFeatureDeprecated = "FEATURE_DEPRECATED"

	// AudienceExtensionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceExtensionErrorReasonReasonUnknown = "UNKNOWN"
)

// AuthenticationErrorReasonReason
const (

	// AuthenticationErrorReasonReasonAmbiguousSoapRequestHeader
	//
	// The SOAP message contains a request header with an ambiguous definition of the authentication
	// header fields. This means either the {@code authToken} and {@code oAuthToken} fields were
	// both null or both were specified. Exactly one value should be specified with each request.
	//
	AuthenticationErrorReasonReasonAmbiguousSoapRequestHeader = "AMBIGUOUS_SOAP_REQUEST_HEADER"

	// AuthenticationErrorReasonReasonInvalidEmail
	//
	// The login provided is invalid.
	//
	AuthenticationErrorReasonReasonInvalidEmail = "INVALID_EMAIL"

	// AuthenticationErrorReasonReasonAuthenticationFailed
	//
	// Tried to authenticate with provided information, but failed.
	//
	AuthenticationErrorReasonReasonAuthenticationFailed = "AUTHENTICATION_FAILED"

	// AuthenticationErrorReasonReasonInvalidOauthSignature
	//
	// The OAuth provided is invalid.
	//
	AuthenticationErrorReasonReasonInvalidOauthSignature = "INVALID_OAUTH_SIGNATURE"

	// AuthenticationErrorReasonReasonInvalidService
	//
	// The specified service to use was not recognized.
	//
	AuthenticationErrorReasonReasonInvalidService = "INVALID_SERVICE"

	// AuthenticationErrorReasonReasonMissingSoapRequestHeader
	//
	// The SOAP message is missing a request header with an {@code authToken} and optional {@code
	// networkCode}.
	//
	AuthenticationErrorReasonReasonMissingSoapRequestHeader = "MISSING_SOAP_REQUEST_HEADER"

	// AuthenticationErrorReasonReasonMissingAuthenticationHttpHeader
	//
	// The HTTP request is missing a request header with an {@code authToken}
	//
	AuthenticationErrorReasonReasonMissingAuthenticationHttpHeader = "MISSING_AUTHENTICATION_HTTP_HEADER"

	// AuthenticationErrorReasonReasonMissingAuthentication
	//
	// The request is missing an {@code authToken}
	//
	AuthenticationErrorReasonReasonMissingAuthentication = "MISSING_AUTHENTICATION"

	// AuthenticationErrorReasonReasonNetworkApiAccessDisabled
	//
	// The network does not have API access enabled.
	//
	AuthenticationErrorReasonReasonNetworkApiAccessDisabled = "NETWORK_API_ACCESS_DISABLED"

	// AuthenticationErrorReasonReasonNoNetworksToAccess
	//
	// The user is not associated with any network.
	//
	AuthenticationErrorReasonReasonNoNetworksToAccess = "NO_NETWORKS_TO_ACCESS"

	// AuthenticationErrorReasonReasonNetworkNotFound
	//
	// No network for the given {@code networkCode} was found.
	//
	AuthenticationErrorReasonReasonNetworkNotFound = "NETWORK_NOT_FOUND"

	// AuthenticationErrorReasonReasonNetworkCodeRequired
	//
	// The user has access to more than one network, but did not provide a {@code networkCode}.
	//
	AuthenticationErrorReasonReasonNetworkCodeRequired = "NETWORK_CODE_REQUIRED"

	// AuthenticationErrorReasonReasonConnectionError
	//
	// An error happened on the server side during connection to authentication service.
	//
	AuthenticationErrorReasonReasonConnectionError = "CONNECTION_ERROR"

	// AuthenticationErrorReasonReasonGoogleAccountAlreadyAssociatedWithNetwork
	//
	// The user tried to create a test network using an account that already is associated with a
	// network.
	//
	AuthenticationErrorReasonReasonGoogleAccountAlreadyAssociatedWithNetwork = "GOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK"

	// AuthenticationErrorReasonReasonUnderInvestigation
	//
	// The account is blocked and under investigation by the collections team. Please contact Google
	// for more information.
	//
	AuthenticationErrorReasonReasonUnderInvestigation = "UNDER_INVESTIGATION"

	// AuthenticationErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AuthenticationErrorReasonReasonUnknown = "UNKNOWN"
)

// ChildContentEligibility
//
// Child content eligibility designation.
//
// <p>This field is optional and defaults to {@link ChildContentEligibility#DISALLOWED}. This field
// has no effect on serving enforcement unless you opt to "Child content enforcement" in the
// network's Child Content settings.
type ChildContentEligibility string

const (

	// ChildContentEligibilityUnknown
	ChildContentEligibilityUnknown ChildContentEligibility = "UNKNOWN"

	// ChildContentEligibilityDisallowed
	//
	// This line item is not eligible to serve on any requests that are child-directed.
	//
	ChildContentEligibilityDisallowed ChildContentEligibility = "DISALLOWED"

	// ChildContentEligibilityAllowed
	//
	// This line item is eligible to serve on requests that are child-directed.
	//
	ChildContentEligibilityAllowed ChildContentEligibility = "ALLOWED"
)

// ClickTrackingLineItemErrorReasonReason
//
// The reasons for the target error.
const (

	// ClickTrackingLineItemErrorReasonReasonTypeImmutable
	//
	// The line item type cannot be changed once created.
	//
	ClickTrackingLineItemErrorReasonReasonTypeImmutable = "TYPE_IMMUTABLE"

	// ClickTrackingLineItemErrorReasonReasonInvalidTargetingType
	//
	// Click tracking line items can only be targeted at ad unit inventory, all other
	// services are invalid, as well as placements.
	//
	ClickTrackingLineItemErrorReasonReasonInvalidTargetingType = "INVALID_TARGETING_TYPE"

	// ClickTrackingLineItemErrorReasonReasonInvalidRoadblockingType
	//
	// Click tracking line items do not allow us to control creative delivery so
	// are by nature one or more as entered by the third party.
	//
	ClickTrackingLineItemErrorReasonReasonInvalidRoadblockingType = "INVALID_ROADBLOCKING_TYPE"

	// ClickTrackingLineItemErrorReasonReasonInvalidCreativerotationType
	//
	// Click tracking line items do not support the
	// {@link CreativeRotationType#OPTIMIZED} creative rotation type.
	//
	ClickTrackingLineItemErrorReasonReasonInvalidCreativerotationType = "INVALID_CREATIVEROTATION_TYPE"

	// ClickTrackingLineItemErrorReasonReasonInvalidDeliveryRateType
	//
	// Click tracking line items do not allow us to control line item delivery so
	// we can not control the rate at which they are served.
	//
	ClickTrackingLineItemErrorReasonReasonInvalidDeliveryRateType = "INVALID_DELIVERY_RATE_TYPE"

	// ClickTrackingLineItemErrorReasonReasonUnsupportedField
	//
	// Not all fields are supported by the click tracking line items.
	//
	ClickTrackingLineItemErrorReasonReasonUnsupportedField = "UNSUPPORTED_FIELD"

	// ClickTrackingLineItemErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ClickTrackingLineItemErrorReasonReasonUnknown = "UNKNOWN"
)

// CollectionSizeErrorReasonReason
const (

	// CollectionSizeErrorReasonReasonTooLarge
	CollectionSizeErrorReasonReasonTooLarge = "TOO_LARGE"

	// CollectionSizeErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CollectionSizeErrorReasonReasonUnknown = "UNKNOWN"
)

// CommonErrorReasonReason
//
// Describes reasons for common errors
const (

	// CommonErrorReasonReasonNotFound
	//
	// Indicates that an attempt was made to retrieve an entity that does not
	// exist.
	//
	CommonErrorReasonReasonNotFound = "NOT_FOUND"

	// CommonErrorReasonReasonAlreadyExists
	//
	// Indicates that an attempt was made to create an entity that already
	// exists.
	//
	CommonErrorReasonReasonAlreadyExists = "ALREADY_EXISTS"

	// CommonErrorReasonReasonNotApplicable
	//
	// Indicates that a value is not applicable for given use case.
	//
	CommonErrorReasonReasonNotApplicable = "NOT_APPLICABLE"

	// CommonErrorReasonReasonDuplicateObject
	//
	// Indicates that two elements in the collection were identical.
	//
	CommonErrorReasonReasonDuplicateObject = "DUPLICATE_OBJECT"

	// CommonErrorReasonReasonCannotUpdate
	//
	// Indicates that an attempt was made to change an immutable field.
	//
	CommonErrorReasonReasonCannotUpdate = "CANNOT_UPDATE"

	// CommonErrorReasonReasonUnsupportedOperation
	//
	// Indicates that the requested operation is not supported.
	//
	CommonErrorReasonReasonUnsupportedOperation = "UNSUPPORTED_OPERATION"

	// CommonErrorReasonReasonConcurrentModification
	//
	// Indicates that another request attempted to update the same data in the same network
	// at about the same time. Please wait and try the request again.
	//
	CommonErrorReasonReasonConcurrentModification = "CONCURRENT_MODIFICATION"

	// CommonErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CommonErrorReasonReasonUnknown = "UNKNOWN"
)

// CompanionDeliveryOption
//
// The delivery option for companions.  Used for line items whose environmentType is
// {@link EnvironmentType#VIDEO_PLAYER}.
type CompanionDeliveryOption string

const (

	// CompanionDeliveryOptionOptional
	//
	// Companions are not required to serve a creative set. The creative set can
	// serve to inventory that has zero or more matching companions.
	//
	CompanionDeliveryOptionOptional CompanionDeliveryOption = "OPTIONAL"

	// CompanionDeliveryOptionAtLeastOne
	//
	// At least one companion must be served in order for the creative set to be used.
	//
	CompanionDeliveryOptionAtLeastOne CompanionDeliveryOption = "AT_LEAST_ONE"

	// CompanionDeliveryOptionAll
	//
	// All companions in the set must be served in order for the creative set to
	// be used. This can still serve to inventory that has more companions
	// than can be filled.
	//
	CompanionDeliveryOptionAll CompanionDeliveryOption = "ALL"

	// CompanionDeliveryOptionUnknown
	//
	// The delivery type is unknown.
	//
	CompanionDeliveryOptionUnknown CompanionDeliveryOption = "UNKNOWN"
)

// CompanyCreditStatusErrorReasonReason
//
// The reasons for the target error.
const (

	// CompanyCreditStatusErrorReasonReasonCompanyCreditStatusChangeNotAllowed
	//
	// The user's role does not have permission to change
	// {@link Company#creditStatus} from the default value. The default value is
	// {@link Company.CreditStatus#ACTIVE} for the Basic credit status setting
	// and {@link Company.CreditStatus#ON_HOLD} for the Advanced credit status
	// setting.
	//
	CompanyCreditStatusErrorReasonReasonCompanyCreditStatusChangeNotAllowed = "COMPANY_CREDIT_STATUS_CHANGE_NOT_ALLOWED"

	// CompanyCreditStatusErrorReasonReasonCannotUseCreditStatusSetting
	//
	// The network has not been enabled for editing credit status settings for
	// companies.
	//
	CompanyCreditStatusErrorReasonReasonCannotUseCreditStatusSetting = "CANNOT_USE_CREDIT_STATUS_SETTING"

	// CompanyCreditStatusErrorReasonReasonCannotUseAdvancedCreditStatusSetting
	//
	// The network has not been enabled for the Advanced credit status
	// settings for companies. {@link Company#creditStatus} must be either
	// {@code ACTIVE} or {@code INACTIVE}.
	//
	CompanyCreditStatusErrorReasonReasonCannotUseAdvancedCreditStatusSetting = "CANNOT_USE_ADVANCED_CREDIT_STATUS_SETTING"

	// CompanyCreditStatusErrorReasonReasonUnacceptableCompanyCreditStatusForOrder
	//
	// An order cannot be created or updated because the
	// {@link Order#advertiserId} or the {@link Order#agencyId} it is associated
	// with has {@link Company#creditStatus} that is not {@code ACTIVE} or
	// {@code ON_HOLD}.
	//
	CompanyCreditStatusErrorReasonReasonUnacceptableCompanyCreditStatusForOrder = "UNACCEPTABLE_COMPANY_CREDIT_STATUS_FOR_ORDER"

	// CompanyCreditStatusErrorReasonReasonUnacceptableCompanyCreditStatusForLineItem
	//
	// A line item cannot be created for the order because the
	// {@link Order#advertiserId} or {Order#agencyId} it is associated with has
	// {@link Company#creditStatus} that is not {@code ACTIVE} or
	// {@code ON_HOLD}.
	//
	CompanyCreditStatusErrorReasonReasonUnacceptableCompanyCreditStatusForLineItem = "UNACCEPTABLE_COMPANY_CREDIT_STATUS_FOR_LINE_ITEM"

	// CompanyCreditStatusErrorReasonReasonCannotBlockCompanyTooManyApprovedOrders
	//
	// The company cannot be blocked because there are more than 200 approved
	// orders of the company. Archive some, so that there are less than 200 of
	// them.
	//
	CompanyCreditStatusErrorReasonReasonCannotBlockCompanyTooManyApprovedOrders = "CANNOT_BLOCK_COMPANY_TOO_MANY_APPROVED_ORDERS"

	// CompanyCreditStatusErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CompanyCreditStatusErrorReasonReasonUnknown = "UNKNOWN"
)

// CompetitiveConstraintScope
//
// The scope to which the assignment of any competitive exclusion labels for a video line item is
// limited.
type CompetitiveConstraintScope string

const (

	// CompetitiveConstraintScopePod
	//
	// The competitive exclusion label applies to all line items within a single pod (or group).
	//
	CompetitiveConstraintScopePod CompetitiveConstraintScope = "POD"

	// CompetitiveConstraintScopeStream
	//
	// The competitive exclusion label applies to all line items within the entire stream of content.
	//
	CompetitiveConstraintScopeStream CompetitiveConstraintScope = "STREAM"

	// CompetitiveConstraintScopeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CompetitiveConstraintScopeUnknown CompetitiveConstraintScope = "UNKNOWN"
)

// ComputedStatus
//
// Describes the computed {@link LineItem} status that is derived from the
// current state of the line item.
type ComputedStatus string

const (

	// ComputedStatusDeliveryExtended
	//
	// The {@link LineItem} has past its {@link LineItem#endDateTime} with an auto extension, but
	// hasn't met its goal.
	//
	ComputedStatusDeliveryExtended ComputedStatus = "DELIVERY_EXTENDED"

	// ComputedStatusDelivering
	//
	// The {@link LineItem} has begun serving.
	//
	ComputedStatusDelivering ComputedStatus = "DELIVERING"

	// ComputedStatusReady
	//
	// The {@link LineItem} has been activated and is ready to serve.
	//
	ComputedStatusReady ComputedStatus = "READY"

	// ComputedStatusPaused
	//
	// The {@link LineItem} has been paused from serving.
	//
	ComputedStatusPaused ComputedStatus = "PAUSED"

	// ComputedStatusInactive
	//
	// The {@link LineItem} is inactive. It is either caused by missing creatives or
	// the network disabling auto-activation.
	//
	ComputedStatusInactive ComputedStatus = "INACTIVE"

	// ComputedStatusPausedInventoryReleased
	//
	// The {@link LineItem} has been paused and its reserved inventory has been
	// released. The {@code LineItem} will not serve.
	//
	ComputedStatusPausedInventoryReleased ComputedStatus = "PAUSED_INVENTORY_RELEASED"

	// ComputedStatusPendingApproval
	//
	// The {@link LineItem} has been submitted for approval.
	//
	ComputedStatusPendingApproval ComputedStatus = "PENDING_APPROVAL"

	// ComputedStatusCompleted
	//
	// The {@link LineItem} has completed its run.
	//
	ComputedStatusCompleted ComputedStatus = "COMPLETED"

	// ComputedStatusDisapproved
	//
	// The {@link LineItem} has been disapproved and is not eligible to serve.
	//
	ComputedStatusDisapproved ComputedStatus = "DISAPPROVED"

	// ComputedStatusDraft
	//
	// The {@link LineItem} is still being drafted.
	//
	ComputedStatusDraft ComputedStatus = "DRAFT"

	// ComputedStatusCanceled
	//
	// The {@link LineItem} has been canceled and is no longer eligible to serve.
	// This is a legacy status imported from Google Ad Manager orders.
	//
	ComputedStatusCanceled ComputedStatus = "CANCELED"
)

// CostType
//
// Describes the {@link LineItem} actions that are billable.
type CostType string

const (

	// CostTypeCpa
	//
	// Starting February 22, 2024 the CPA {@link CostType} will be read only as part of Spotlight
	// deprecation, <a href="https://support.google.com/admanager/answer/7519021#spotlight">learn
	// more</a>.
	//
	// <p>Cost per action. The {@link LineItem#lineItemType} must be one of:
	//
	// <ul>
	// <li>{@link LineItemType#SPONSORSHIP}
	// <li>{@link LineItemType#STANDARD}
	// <li>{@link LineItemType#BULK}
	// <li>{@link LineItemType#NETWORK}
	// </ul>
	//
	CostTypeCpa CostType = "CPA"

	// CostTypeCpc
	//
	// Cost per click. The {@link LineItem#lineItemType} must be one of:
	// <ul>
	// <li>{@link LineItemType#SPONSORSHIP}</li>
	// <li>{@link LineItemType#STANDARD}</li>
	// <li>{@link LineItemType#BULK}</li>
	// <li>{@link LineItemType#NETWORK}</li>
	// <li>{@link LineItemType#PRICE_PRIORITY}</li>
	// <li>{@link LineItemType#HOUSE}</li>
	// </ul>
	//
	CostTypeCpc CostType = "CPC"

	// CostTypeCpd
	//
	// Cost per day. The {@link LineItem#lineItemType} must be one of:
	// <ul>
	// <li>{@link LineItemType#SPONSORSHIP}<li>
	// <li>{@link LineItemType#NETWORK}<li>
	// </ul>
	//
	CostTypeCpd CostType = "CPD"

	// CostTypeCpm
	//
	// Cost per mille (cost per thousand impressions). The
	// {@link LineItem#lineItemType} must be one of:
	// <ul>
	// <li>{@link LineItemType#SPONSORSHIP}</li>
	// <li>{@link LineItemType#STANDARD}</li>
	// <li>{@link LineItemType#BULK}</li>
	// <li>{@link LineItemType#NETWORK}</li>
	// <li>{@link LineItemType#PRICE_PRIORITY}</li>
	// <li>{@link LineItemType#HOUSE}</li>
	// </ul>
	//
	CostTypeCpm CostType = "CPM"

	// CostTypeVcpm
	//
	// Cost per thousand Active View viewable impressions. The {@link LineItem#lineItemType}
	// must be {@link LineItemType#STANDARD}.
	//
	CostTypeVcpm CostType = "VCPM"

	// CostTypeCpmInTarget
	//
	// Cost per thousand in-target impressions. The {@link LineItem#lineItemType}
	// must be {@link LineItemType#STANDARD}.
	//
	CostTypeCpmInTarget CostType = "CPM_IN_TARGET"

	// CostTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CostTypeUnknown CostType = "UNKNOWN"
)

// CreativeErrorReasonReason
//
// The reasons for the target error.
const (

	// CreativeErrorReasonReasonFlashAndFallbackUrlAreSame
	//
	// {@link FlashRedirectCreative#flashUrl} and
	// {@link FlashRedirectCreative#fallbackUrl} are the same. The fallback URL
	// is used when the flash URL does not work and must be different from it.
	//
	CreativeErrorReasonReasonFlashAndFallbackUrlAreSame = "FLASH_AND_FALLBACK_URL_ARE_SAME"

	// CreativeErrorReasonReasonInvalidInternalRedirectUrl
	//
	// The internal redirect URL was invalid. The URL must have the following
	// syntax http://ad.doubleclick.net/ad/sitename/;sz=size.
	//
	CreativeErrorReasonReasonInvalidInternalRedirectUrl = "INVALID_INTERNAL_REDIRECT_URL"

	// CreativeErrorReasonReasonDestinationUrlRequired
	//
	// {@link HasDestinationUrlCreative#destinationUrl} is required.
	//
	CreativeErrorReasonReasonDestinationUrlRequired = "DESTINATION_URL_REQUIRED"

	// CreativeErrorReasonReasonDestinationUrlNotEmpty
	//
	// {@link HasDestinationUrlCreative#destinationUrl} must be empty when its type is
	// {@link DestinationUrlType#NONE}.
	//
	CreativeErrorReasonReasonDestinationUrlNotEmpty = "DESTINATION_URL_NOT_EMPTY"

	// CreativeErrorReasonReasonDestinationUrlTypeNotSupported
	//
	// The provided {@link DestinationUrlType} is not supported for the creative type it is
	// being used on.
	//
	CreativeErrorReasonReasonDestinationUrlTypeNotSupported = "DESTINATION_URL_TYPE_NOT_SUPPORTED"

	// CreativeErrorReasonReasonCannotCreateOrUpdateLegacyDfpCreative
	//
	// Cannot create or update legacy DART For Publishers creative.
	//
	CreativeErrorReasonReasonCannotCreateOrUpdateLegacyDfpCreative = "CANNOT_CREATE_OR_UPDATE_LEGACY_DFP_CREATIVE"

	// CreativeErrorReasonReasonCannotCreateOrUpdateLegacyDfpMobileCreative
	//
	// Cannot create or update legacy mobile creative.
	//
	CreativeErrorReasonReasonCannotCreateOrUpdateLegacyDfpMobileCreative = "CANNOT_CREATE_OR_UPDATE_LEGACY_DFP_MOBILE_CREATIVE"

	// CreativeErrorReasonReasonMissingFeature
	//
	// The user is missing a necessary feature.
	//
	CreativeErrorReasonReasonMissingFeature = "MISSING_FEATURE"

	// CreativeErrorReasonReasonInvalidCompanyType
	//
	// Company type should be one of Advertisers, House Advertisers and
	// Ad Networks.
	//
	CreativeErrorReasonReasonInvalidCompanyType = "INVALID_COMPANY_TYPE"

	// CreativeErrorReasonReasonInvalidAdsenseCreativeSize
	//
	// Invalid size for AdSense dynamic allocation creative.
	// Only valid AFC sizes are allowed.
	//
	CreativeErrorReasonReasonInvalidAdsenseCreativeSize = "INVALID_ADSENSE_CREATIVE_SIZE"

	// CreativeErrorReasonReasonInvalidAdExchangeCreativeSize
	//
	// Invalid size for Ad Exchange dynamic allocation creative.
	// Only valid Ad Exchange sizes are allowed.
	//
	CreativeErrorReasonReasonInvalidAdExchangeCreativeSize = "INVALID_AD_EXCHANGE_CREATIVE_SIZE"

	// CreativeErrorReasonReasonDuplicateAssetInCreative
	//
	// Assets associated with the same creative must be unique.
	//
	CreativeErrorReasonReasonDuplicateAssetInCreative = "DUPLICATE_ASSET_IN_CREATIVE"

	// CreativeErrorReasonReasonCreativeAssetCannotHaveIdAndByteArray
	//
	// A creative asset cannot contain an asset ID and a byte array.
	//
	CreativeErrorReasonReasonCreativeAssetCannotHaveIdAndByteArray = "CREATIVE_ASSET_CANNOT_HAVE_ID_AND_BYTE_ARRAY"

	// CreativeErrorReasonReasonCannotCreateOrUpdateUnsupportedCreative
	//
	// Cannot create or update unsupported creative.
	//
	CreativeErrorReasonReasonCannotCreateOrUpdateUnsupportedCreative = "CANNOT_CREATE_OR_UPDATE_UNSUPPORTED_CREATIVE"

	// CreativeErrorReasonReasonCannotCreateProgrammaticCreatives
	//
	// Cannot create programmatic creatives.
	//
	CreativeErrorReasonReasonCannotCreateProgrammaticCreatives = "CANNOT_CREATE_PROGRAMMATIC_CREATIVES"

	// CreativeErrorReasonReasonInvalidSizeForThirdPartyImpressionTracker
	//
	// A creative must have valid size to use the third-party impression tracker.
	//
	CreativeErrorReasonReasonInvalidSizeForThirdPartyImpressionTracker = "INVALID_SIZE_FOR_THIRD_PARTY_IMPRESSION_TRACKER"

	// CreativeErrorReasonReasonCannotDeactivateCreativesInCreativeSets
	//
	// Ineligible creatives can not be deactivated.
	//
	CreativeErrorReasonReasonCannotDeactivateCreativesInCreativeSets = "CANNOT_DEACTIVATE_CREATIVES_IN_CREATIVE_SETS"

	// CreativeErrorReasonReasonHostedVideoCreativeRequiresVideoAsset
	//
	// Ad Manager hosted video creatives must contain a video asset.
	//
	CreativeErrorReasonReasonHostedVideoCreativeRequiresVideoAsset = "HOSTED_VIDEO_CREATIVE_REQUIRES_VIDEO_ASSET"

	// CreativeErrorReasonReasonCannotSetMultipleImpressionTrackingUrls
	//
	// {@link ImageCreative#thirdPartyImpressionTrackingUrls} should not contain more than one url.
	//
	CreativeErrorReasonReasonCannotSetMultipleImpressionTrackingUrls = "CANNOT_SET_MULTIPLE_IMPRESSION_TRACKING_URLS"

	// CreativeErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CreativeErrorReasonReasonUnknown = "UNKNOWN"
)

// CreativeRotationType
//
// The strategy to use for displaying multiple {@link Creative} objects that are
// associated with a {@link LineItem}.
type CreativeRotationType string

const (

	// CreativeRotationTypeEven
	//
	// Creatives are displayed roughly the same number of times over
	// the duration of the line item.
	//
	CreativeRotationTypeEven CreativeRotationType = "EVEN"

	// CreativeRotationTypeOptimized
	//
	// Creatives are served roughly proportionally to their performance.
	//
	CreativeRotationTypeOptimized CreativeRotationType = "OPTIMIZED"

	// CreativeRotationTypeManual
	//
	// Creatives are served roughly proportionally to their weights, set on the
	// {@link LineItemCreativeAssociation}.
	//
	CreativeRotationTypeManual CreativeRotationType = "MANUAL"

	// CreativeRotationTypeSequential
	//
	// Creatives are served exactly in sequential order, aka Storyboarding.
	// Set on the {@link LineItemCreativeAssociation}.
	//
	CreativeRotationTypeSequential CreativeRotationType = "SEQUENTIAL"
)

// CreativeSizeType
//
// Descriptions of the services of sizes a creative can be.  Not all creatives can
// be described by a height-width pair, this provides additional context.
type CreativeSizeType string

const (

	// CreativeSizeTypePixel
	//
	// Dimension based size, an actual height and width.
	//
	CreativeSizeTypePixel CreativeSizeType = "PIXEL"

	// CreativeSizeTypeAspectRatio
	//
	// Mobile size, that is expressed as a ratio of say 4 by 1, that could be
	// met by a 100 x 25 sized image.
	//
	CreativeSizeTypeAspectRatio CreativeSizeType = "ASPECT_RATIO"

	// CreativeSizeTypeInterstitial
	//
	// Out-of-page size, that is not related to the slot it is served.  But rather
	// is a function of the snippet, and the values set. This must be used with
	// 1x1 size.
	//
	CreativeSizeTypeInterstitial CreativeSizeType = "INTERSTITIAL"

	// CreativeSizeTypeIgnored
	//
	// Size has no meaning
	//
	// <p>1. For Click Tracking entities, where size doesn't matter 2. For entities that allow all
	// requested sizes, where the size represents all sizes.
	//
	CreativeSizeTypeIgnored CreativeSizeType = "IGNORED"

	// CreativeSizeTypeNative
	//
	// Native size, which is a function of the how the client renders the creative.
	// This must be used with 1x1 size.
	//
	CreativeSizeTypeNative CreativeSizeType = "NATIVE"

	// CreativeSizeTypeAudio
	//
	// Audio size. Used with audio ads. This must be used with 1x1 size.
	//
	CreativeSizeTypeAudio CreativeSizeType = "AUDIO"
)

// CrossSellErrorReasonReason
//
// The reason of the error.
const (

	// CrossSellErrorReasonReasonCompanyIsNotDistributionPartner
	//
	// A company for cross-sell partner must be of type {@link Company.Type#PARTNER}.
	//
	CrossSellErrorReasonReasonCompanyIsNotDistributionPartner = "COMPANY_IS_NOT_DISTRIBUTION_PARTNER"

	// CrossSellErrorReasonReasonChangingPartnerNetworkIsNotSupported
	//
	// The network code of a cross-sell partner cannot be changed.
	//
	CrossSellErrorReasonReasonChangingPartnerNetworkIsNotSupported = "CHANGING_PARTNER_NETWORK_IS_NOT_SUPPORTED"

	// CrossSellErrorReasonReasonMissingDistributorPartnerName
	//
	// A cross-sell partner must have a partner name.
	//
	CrossSellErrorReasonReasonMissingDistributorPartnerName = "MISSING_DISTRIBUTOR_PARTNER_NAME"

	// CrossSellErrorReasonReasonDistributorNetworkMissingPublisherFeature
	//
	// The cross-sell distributor publisher feature must be enabled.
	//
	CrossSellErrorReasonReasonDistributorNetworkMissingPublisherFeature = "DISTRIBUTOR_NETWORK_MISSING_PUBLISHER_FEATURE"

	// CrossSellErrorReasonReasonContentProviderNetworkMissingPublisherFeature
	//
	// The cross-sell publisher features must be enabled on the partner's network.
	//
	CrossSellErrorReasonReasonContentProviderNetworkMissingPublisherFeature = "CONTENT_PROVIDER_NETWORK_MISSING_PUBLISHER_FEATURE"

	// CrossSellErrorReasonReasonInvalidDistributorPartnerName
	//
	// The cross-sell partner name conflicts with an ad unit name on the partner's network.
	//
	CrossSellErrorReasonReasonInvalidDistributorPartnerName = "INVALID_DISTRIBUTOR_PARTNER_NAME"

	// CrossSellErrorReasonReasonInvalidContentProviderNetwork
	//
	// The network code of a cross-sell partner is invalid.
	//
	CrossSellErrorReasonReasonInvalidContentProviderNetwork = "INVALID_CONTENT_PROVIDER_NETWORK"

	// CrossSellErrorReasonReasonContentProviderNetworkCannotBeActiveNetwork
	//
	// The content provider network must be different than the distributor network.
	//
	CrossSellErrorReasonReasonContentProviderNetworkCannotBeActiveNetwork = "CONTENT_PROVIDER_NETWORK_CANNOT_BE_ACTIVE_NETWORK"

	// CrossSellErrorReasonReasonContentProviderNetworkAlreadyEnabledForCrossSelling
	//
	// The same network code was already enabled for cross-sell in a different company.
	//
	CrossSellErrorReasonReasonContentProviderNetworkAlreadyEnabledForCrossSelling = "CONTENT_PROVIDER_NETWORK_ALREADY_ENABLED_FOR_CROSS_SELLING"

	// CrossSellErrorReasonReasonDistributorRuleViolationError
	//
	// A rule defined by the cross selling distributor has been violated by a line item targeting
	// a shared ad unit. Violating this rule is an error.
	//
	CrossSellErrorReasonReasonDistributorRuleViolationError = "DISTRIBUTOR_RULE_VIOLATION_ERROR"

	// CrossSellErrorReasonReasonDistributorRuleViolationWarning
	//
	// A rule defined by the cross selling distributor has been violated by a line item targeting
	// a shared ad unit. Violating this rule is a warning.
	//
	// <p>By setting {@link LineItem#skipCrossSellingRuleWarningChecks}, the content partner can
	// suppress the warning (and create or save the line item).
	//
	// <p>This flag is available beginning in V201411.
	//
	CrossSellErrorReasonReasonDistributorRuleViolationWarning = "DISTRIBUTOR_RULE_VIOLATION_WARNING"

	// CrossSellErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CrossSellErrorReasonReasonUnknown = "UNKNOWN"
)

// CurrencyCodeErrorReasonReason
//
// The reason behind the currency code error.
const (

	// CurrencyCodeErrorReasonReasonInvalid
	//
	// The currency code is invalid and does not follow ISO 4217.
	//
	CurrencyCodeErrorReasonReasonInvalid = "INVALID"

	// CurrencyCodeErrorReasonReasonUnsupported
	//
	// The currency code is valid, but is not supported.
	//
	CurrencyCodeErrorReasonReasonUnsupported = "UNSUPPORTED"

	// CurrencyCodeErrorReasonReasonDeprecatedCurrencyUsed
	//
	// The currency has been used for entity creation after its deprecation
	//
	CurrencyCodeErrorReasonReasonDeprecatedCurrencyUsed = "DEPRECATED_CURRENCY_USED"
)

// CustomCriteriaComparisonOperatorType
//
// Specifies the available comparison operators.
type CustomCriteriaComparisonOperator string

const (

	// CustomCriteriaComparisonOperatorTypeIs
	CustomCriteriaComparisonOperatorTypeIs CustomCriteriaComparisonOperator = "IS"

	// CustomCriteriaComparisonOperatorTypeIsNot
	CustomCriteriaComparisonOperatorTypeIsNot CustomCriteriaComparisonOperator = "IS_NOT"
)

// CustomCriteriaSetLogicalOperatorType
//
// Specifies the available logical operators.
type CustomCriteriaSetLogicalOperator string

const (

	// CustomCriteriaSetLogicalOperatorTypeAnd
	CustomCriteriaSetLogicalOperatorTypeAnd CustomCriteriaSetLogicalOperator = "AND"

	// CustomCriteriaSetLogicalOperatorTypeOr
	CustomCriteriaSetLogicalOperatorTypeOr CustomCriteriaSetLogicalOperator = "OR"
)

// CustomFieldValueErrorReasonReason
//
// The reasons for the target error.
const (

	// CustomFieldValueErrorReasonReasonCustomFieldNotFound
	//
	// An attempt was made to modify or create a {@link CustomFieldValue} for
	// a {@link CustomField} that does not exist.
	//
	CustomFieldValueErrorReasonReasonCustomFieldNotFound = "CUSTOM_FIELD_NOT_FOUND"

	// CustomFieldValueErrorReasonReasonCustomFieldInactive
	//
	// An attempt was made to create a new value for a custom field
	// that is inactive.
	//
	CustomFieldValueErrorReasonReasonCustomFieldInactive = "CUSTOM_FIELD_INACTIVE"

	// CustomFieldValueErrorReasonReasonCustomFieldOptionNotFound
	//
	// An attempt was made to modify or create a {@link CustomFieldValue} corresponding
	// to a {@link CustomFieldOption} that could not be found.
	//
	CustomFieldValueErrorReasonReasonCustomFieldOptionNotFound = "CUSTOM_FIELD_OPTION_NOT_FOUND"

	// CustomFieldValueErrorReasonReasonInvalidEntityType
	//
	// An attempt was made to modify or create a {@link CustomFieldValue} with an
	// association to an entity of the wrong type for its field.
	//
	CustomFieldValueErrorReasonReasonInvalidEntityType = "INVALID_ENTITY_TYPE"

	// CustomFieldValueErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CustomFieldValueErrorReasonReasonUnknown = "UNKNOWN"
)

// CustomPacingGoalUnit
//
// Options for the unit of the custom pacing goal amounts.
type CustomPacingGoalUnit string

const (

	// CustomPacingGoalUnitAbsolute
	//
	// The custom pacing goal amounts represent absolute numbers corresponding to the line item's
	// {@link Goal#unitType}.
	//
	CustomPacingGoalUnitAbsolute CustomPacingGoalUnit = "ABSOLUTE"

	// CustomPacingGoalUnitMilliPercent
	//
	// The custom pacing goal amounts represent a millipercent. For example, 15000 millipercent
	// equals 15%.
	//
	CustomPacingGoalUnitMilliPercent CustomPacingGoalUnit = "MILLI_PERCENT"

	// CustomPacingGoalUnitUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CustomPacingGoalUnitUnknown CustomPacingGoalUnit = "UNKNOWN"
)

// CmsMetadataCriteriaComparisonOperatorType
//
// Specifies the available comparison operators.
type CmsMetadataCriteriaComparisonOperator string

const (

	// CmsMetadataCriteriaComparisonOperatorTypeEquals
	CmsMetadataCriteriaComparisonOperatorTypeEquals CmsMetadataCriteriaComparisonOperator = "EQUALS"

	// CmsMetadataCriteriaComparisonOperatorTypeNotEquals
	CmsMetadataCriteriaComparisonOperatorTypeNotEquals CmsMetadataCriteriaComparisonOperator = "NOT_EQUALS"
)

// CustomTargetingErrorReasonReason
//
// The reasons for the target error.
const (

	// CustomTargetingErrorReasonReasonKeyNotFound
	//
	// Requested {@link CustomTargetingKey} is not found.
	//
	CustomTargetingErrorReasonReasonKeyNotFound = "KEY_NOT_FOUND"

	// CustomTargetingErrorReasonReasonKeyCountTooLarge
	//
	// Number of {@link CustomTargetingKey} objects created exceeds the limit
	// allowed for the network.
	//
	CustomTargetingErrorReasonReasonKeyCountTooLarge = "KEY_COUNT_TOO_LARGE"

	// CustomTargetingErrorReasonReasonKeyNameDuplicate
	//
	// {@link CustomTargetingKey} with the same {@link CustomTargetingKey#name}
	// already exists.
	//
	CustomTargetingErrorReasonReasonKeyNameDuplicate = "KEY_NAME_DUPLICATE"

	// CustomTargetingErrorReasonReasonKeyNameEmpty
	//
	// {@link CustomTargetingKey#name} is empty.
	//
	CustomTargetingErrorReasonReasonKeyNameEmpty = "KEY_NAME_EMPTY"

	// CustomTargetingErrorReasonReasonKeyNameInvalidLength
	//
	// {@link CustomTargetingKey#name} is too long.
	//
	CustomTargetingErrorReasonReasonKeyNameInvalidLength = "KEY_NAME_INVALID_LENGTH"

	// CustomTargetingErrorReasonReasonKeyNameInvalidChars
	//
	// {@link CustomTargetingKey#name} contains unsupported or reserved
	// characters.
	//
	CustomTargetingErrorReasonReasonKeyNameInvalidChars = "KEY_NAME_INVALID_CHARS"

	// CustomTargetingErrorReasonReasonKeyNameReserved
	//
	// {@link CustomTargetingKey#name} matches one of the reserved custom
	// targeting key names.
	//
	CustomTargetingErrorReasonReasonKeyNameReserved = "KEY_NAME_RESERVED"

	// CustomTargetingErrorReasonReasonKeyDisplayNameInvalidLength
	//
	// {@link CustomTargetingKey#displayName} is too long.
	//
	CustomTargetingErrorReasonReasonKeyDisplayNameInvalidLength = "KEY_DISPLAY_NAME_INVALID_LENGTH"

	// CustomTargetingErrorReasonReasonKeyStatusNotActive
	//
	// Key is not active.
	//
	CustomTargetingErrorReasonReasonKeyStatusNotActive = "KEY_STATUS_NOT_ACTIVE"

	// CustomTargetingErrorReasonReasonValueNotFound
	//
	// Requested {@link CustomTargetingValue} is not found.
	//
	CustomTargetingErrorReasonReasonValueNotFound = "VALUE_NOT_FOUND"

	// CustomTargetingErrorReasonReasonGetValuesByStatementMustContainKeyId
	//
	// The {@code WHERE} clause in the {@link Statement#query} must always
	// contain {@link CustomTargetingValue#customTargetingKeyId} as one of its
	// columns in a way that it is AND'ed with the rest of the query.
	//
	CustomTargetingErrorReasonReasonGetValuesByStatementMustContainKeyId = "GET_VALUES_BY_STATEMENT_MUST_CONTAIN_KEY_ID"

	// CustomTargetingErrorReasonReasonValueCountForKeyTooLarge
	//
	// The number of {@link CustomTargetingValue} objects associated with a
	// {@link CustomTargetingKey} exceeds the network limit. This is only
	// applicable for keys of type {@code CustomTargetingKey.Type#PREDEFINED}.
	//
	CustomTargetingErrorReasonReasonValueCountForKeyTooLarge = "VALUE_COUNT_FOR_KEY_TOO_LARGE"

	// CustomTargetingErrorReasonReasonValueNameDuplicate
	//
	// {@link CustomTargetingValue} with the same
	// {@link CustomTargetingValue#name} already exists.
	//
	CustomTargetingErrorReasonReasonValueNameDuplicate = "VALUE_NAME_DUPLICATE"

	// CustomTargetingErrorReasonReasonValueNameEmpty
	//
	// {@link CustomTargetingValue#name} is empty.
	//
	CustomTargetingErrorReasonReasonValueNameEmpty = "VALUE_NAME_EMPTY"

	// CustomTargetingErrorReasonReasonValueNameInvalidLength
	//
	// {@link CustomTargetingValue#name} is too long.
	//
	CustomTargetingErrorReasonReasonValueNameInvalidLength = "VALUE_NAME_INVALID_LENGTH"

	// CustomTargetingErrorReasonReasonValueNameInvalidChars
	//
	// {@link CustomTargetingValue#name} contains unsupported or reserved
	// characters.
	//
	CustomTargetingErrorReasonReasonValueNameInvalidChars = "VALUE_NAME_INVALID_CHARS"

	// CustomTargetingErrorReasonReasonValueDisplayNameInvalidLength
	//
	// {@link CustomTargetingValue#displayName} is too long.
	//
	CustomTargetingErrorReasonReasonValueDisplayNameInvalidLength = "VALUE_DISPLAY_NAME_INVALID_LENGTH"

	// CustomTargetingErrorReasonReasonValueMatchTypeNotAllowed
	//
	// Only Ad Manager 360 networks can have {@link CustomTargetingValue#matchType}
	// other than {@link CustomTargetingValue.MatchType#EXACT}.
	//
	CustomTargetingErrorReasonReasonValueMatchTypeNotAllowed = "VALUE_MATCH_TYPE_NOT_ALLOWED"

	// CustomTargetingErrorReasonReasonValueMatchTypeNotExactForPredefinedKey
	//
	// You can only create {@link CustomTargetingValue} objects with match type
	// {@link CustomTargetingValue.MatchType#EXACT} when associating
	// with {@link CustomTargetingKey} objects of type
	// {@link CustomTargetingKey.Type#PREDEFINED}
	//
	CustomTargetingErrorReasonReasonValueMatchTypeNotExactForPredefinedKey = "VALUE_MATCH_TYPE_NOT_EXACT_FOR_PREDEFINED_KEY"

	// CustomTargetingErrorReasonReasonSuffixMatchTypeNotAllowed
	//
	// {@link CustomTargetingValue} object cannot have match type of
	// {@link CustomTargetingValue.MatchType#SUFFIX} when adding a
	// {@link CustomTargetingValue} to a line item.
	//
	CustomTargetingErrorReasonReasonSuffixMatchTypeNotAllowed = "SUFFIX_MATCH_TYPE_NOT_ALLOWED"

	// CustomTargetingErrorReasonReasonContainsMatchTypeNotAllowed
	//
	// {@link CustomTargetingValue} object cannot have match type of
	// {@link CustomTargetingValue.MatchType#CONTAINS} when adding a
	// {@link CustomTargetingValue} to targeting expression of a line item.
	//
	CustomTargetingErrorReasonReasonContainsMatchTypeNotAllowed = "CONTAINS_MATCH_TYPE_NOT_ALLOWED"

	// CustomTargetingErrorReasonReasonValueStatusNotActive
	//
	// Value is not active.
	//
	CustomTargetingErrorReasonReasonValueStatusNotActive = "VALUE_STATUS_NOT_ACTIVE"

	// CustomTargetingErrorReasonReasonKeyWithMissingValues
	//
	// The {@link CustomTargetingKey} does not have any
	// {@link CustomTargetingValue} associated with it.
	//
	CustomTargetingErrorReasonReasonKeyWithMissingValues = "KEY_WITH_MISSING_VALUES"

	// CustomTargetingErrorReasonReasonInvalidValueForKey
	//
	// The {@link CustomTargetingKey} has a {@link CustomTargetingValue} specified for which the
	// value is not a valid child.
	//
	CustomTargetingErrorReasonReasonInvalidValueForKey = "INVALID_VALUE_FOR_KEY"

	// CustomTargetingErrorReasonReasonCannotOrDifferentKeys
	//
	// {@link CustomCriteriaSet.LogicalOperator#OR} operation cannot be applied
	// to values with different keys.
	//
	CustomTargetingErrorReasonReasonCannotOrDifferentKeys = "CANNOT_OR_DIFFERENT_KEYS"

	// CustomTargetingErrorReasonReasonInvalidTargetingExpression
	//
	// Targeting expression is invalid. This can happen if the sequence of
	// operators is wrong, or a node contains invalid number of children.
	//
	CustomTargetingErrorReasonReasonInvalidTargetingExpression = "INVALID_TARGETING_EXPRESSION"

	// CustomTargetingErrorReasonReasonDeletedKeyCannotBeUsedForTargeting
	//
	// The key has been deleted. {@link CustomCriteria} cannot have deleted
	// keys.
	//
	CustomTargetingErrorReasonReasonDeletedKeyCannotBeUsedForTargeting = "DELETED_KEY_CANNOT_BE_USED_FOR_TARGETING"

	// CustomTargetingErrorReasonReasonDeletedValueCannotBeUsedForTargeting
	//
	// The value has been deleted. {@link CustomCriteria} cannot have deleted
	// values.
	//
	CustomTargetingErrorReasonReasonDeletedValueCannotBeUsedForTargeting = "DELETED_VALUE_CANNOT_BE_USED_FOR_TARGETING"

	// CustomTargetingErrorReasonReasonVideoBrowseByKeyCannotBeUsedForCustomTargeting
	//
	// The key is set as the video browse-by key, which cannot be used for
	// custom targeting.
	//
	CustomTargetingErrorReasonReasonVideoBrowseByKeyCannotBeUsedForCustomTargeting = "VIDEO_BROWSE_BY_KEY_CANNOT_BE_USED_FOR_CUSTOM_TARGETING"

	// CustomTargetingErrorReasonReasonCannotDeleteCustomKeyUsedInPartnerAssignmentTargeting
	//
	// Cannot delete a custom criteria key that is targeted by an active partner assignment.
	//
	CustomTargetingErrorReasonReasonCannotDeleteCustomKeyUsedInPartnerAssignmentTargeting = "CANNOT_DELETE_CUSTOM_KEY_USED_IN_PARTNER_ASSIGNMENT_TARGETING"

	// CustomTargetingErrorReasonReasonCannotDeleteCustomValueUsedInPartnerAssignmentTargeting
	//
	// Cannot delete a custom criteria value that is targeted by an active partner assignment.
	//
	CustomTargetingErrorReasonReasonCannotDeleteCustomValueUsedInPartnerAssignmentTargeting = "CANNOT_DELETE_CUSTOM_VALUE_USED_IN_PARTNER_ASSIGNMENT_TARGETING"

	// CustomTargetingErrorReasonReasonCannotTargetAudienceSegment
	//
	// {@link AudienceSegment} object cannot be targeted.
	//
	CustomTargetingErrorReasonReasonCannotTargetAudienceSegment = "CANNOT_TARGET_AUDIENCE_SEGMENT"

	// CustomTargetingErrorReasonReasonCannotTargetThirdPartyAudienceSegment
	//
	// Third party {@link AudienceSegment} cannot be targeted.
	//
	CustomTargetingErrorReasonReasonCannotTargetThirdPartyAudienceSegment = "CANNOT_TARGET_THIRD_PARTY_AUDIENCE_SEGMENT"

	// CustomTargetingErrorReasonReasonCannotTargetInactiveAudienceSegment
	//
	// Inactive {@link AudienceSegment} object cannot be targeted.
	//
	CustomTargetingErrorReasonReasonCannotTargetInactiveAudienceSegment = "CANNOT_TARGET_INACTIVE_AUDIENCE_SEGMENT"

	// CustomTargetingErrorReasonReasonInvalidAudienceSegments
	//
	// Targeted {@link AudienceSegment} object is not valid.
	//
	CustomTargetingErrorReasonReasonInvalidAudienceSegments = "INVALID_AUDIENCE_SEGMENTS"

	// CustomTargetingErrorReasonReasonCannotTargetMappedMetadata
	//
	// Mapped metadata key-values are deprecated and cannot be targeted.
	//
	CustomTargetingErrorReasonReasonCannotTargetMappedMetadata = "CANNOT_TARGET_MAPPED_METADATA"

	// CustomTargetingErrorReasonReasonOnlyApprovedAudienceSegmentsCanBeTargeted
	//
	// Targeted {@link AudienceSegment} objects have not been approved.
	//
	CustomTargetingErrorReasonReasonOnlyApprovedAudienceSegmentsCanBeTargeted = "ONLY_APPROVED_AUDIENCE_SEGMENTS_CAN_BE_TARGETED"

	// CustomTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CustomTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// AudienceSegmentCriteriaComparisonOperatorType
//
// Specifies the available comparison operators.
type AudienceSegmentCriteriaComparisonOperator string

const (

	// AudienceSegmentCriteriaComparisonOperatorTypeIs
	AudienceSegmentCriteriaComparisonOperatorTypeIs AudienceSegmentCriteriaComparisonOperator = "IS"

	// AudienceSegmentCriteriaComparisonOperatorTypeIsNot
	AudienceSegmentCriteriaComparisonOperatorTypeIsNot AudienceSegmentCriteriaComparisonOperator = "IS_NOT"
)

// DateTimeRangeTargetingErrorReasonReason
//
// {@link ApiErrorReason} enum for date time range targeting error.
const (

	// DateTimeRangeTargetingErrorReasonReasonEmptyRanges
	//
	// No targeted ranges exists.
	//
	DateTimeRangeTargetingErrorReasonReasonEmptyRanges = "EMPTY_RANGES"

	// DateTimeRangeTargetingErrorReasonReasonNotSponsorshipLineitem
	//
	// Type of lineitem is not sponsorship.
	//
	DateTimeRangeTargetingErrorReasonReasonNotSponsorshipLineitem = "NOT_SPONSORSHIP_LINEITEM"

	// DateTimeRangeTargetingErrorReasonReasonNotSponsorshipOrStandardLineitem
	//
	// Type of lineitem is not sponsorship or standard.
	//
	DateTimeRangeTargetingErrorReasonReasonNotSponsorshipOrStandardLineitem = "NOT_SPONSORSHIP_OR_STANDARD_LINEITEM"

	// DateTimeRangeTargetingErrorReasonReasonUnsupportedLineitemReservationType
	//
	// Line item must have a reservation type of sponsorship, standard or preferred deal to use date
	// time range targeting.
	//
	DateTimeRangeTargetingErrorReasonReasonUnsupportedLineitemReservationType = "UNSUPPORTED_LINEITEM_RESERVATION_TYPE"

	// DateTimeRangeTargetingErrorReasonReasonPastRangesChanged
	//
	// Past ranges are changed.
	//
	DateTimeRangeTargetingErrorReasonReasonPastRangesChanged = "PAST_RANGES_CHANGED"

	// DateTimeRangeTargetingErrorReasonReasonRangesOverlap
	//
	// Targeted date time ranges overlap.
	//
	DateTimeRangeTargetingErrorReasonReasonRangesOverlap = "RANGES_OVERLAP"

	// DateTimeRangeTargetingErrorReasonReasonFirstDateTimeDoesNotMatchStartTime
	//
	// First date time does not match line item's start time.
	//
	DateTimeRangeTargetingErrorReasonReasonFirstDateTimeDoesNotMatchStartTime = "FIRST_DATE_TIME_DOES_NOT_MATCH_START_TIME"

	// DateTimeRangeTargetingErrorReasonReasonLastDateTimeDoesNotMatchEndTime
	//
	// Last date time does not match line item's end time.
	//
	DateTimeRangeTargetingErrorReasonReasonLastDateTimeDoesNotMatchEndTime = "LAST_DATE_TIME_DOES_NOT_MATCH_END_TIME"

	// DateTimeRangeTargetingErrorReasonReasonRangesOutOfLineitemActivePeriod
	//
	// Targeted date time ranges fall out the active period of lineitem.
	//
	DateTimeRangeTargetingErrorReasonReasonRangesOutOfLineitemActivePeriod = "RANGES_OUT_OF_LINEITEM_ACTIVE_PERIOD"

	// DateTimeRangeTargetingErrorReasonReasonStartTimeIsNotStartOfDay
	//
	// Start time of range (except the earliest range) is not at start of day.
	// Start of day is 00:00:00.
	//
	DateTimeRangeTargetingErrorReasonReasonStartTimeIsNotStartOfDay = "START_TIME_IS_NOT_START_OF_DAY"

	// DateTimeRangeTargetingErrorReasonReasonEndTimeIsNotEndOfDay
	//
	// End time of range (except the latest range) is not at end of day.
	// End of day is 23:59:59.
	//
	DateTimeRangeTargetingErrorReasonReasonEndTimeIsNotEndOfDay = "END_TIME_IS_NOT_END_OF_DAY"

	// DateTimeRangeTargetingErrorReasonReasonStartDateTimeIsInPast
	//
	// Start date time of earliest targeted ranges is in past.
	//
	DateTimeRangeTargetingErrorReasonReasonStartDateTimeIsInPast = "START_DATE_TIME_IS_IN_PAST"

	// DateTimeRangeTargetingErrorReasonReasonModifyStartDateTimeToPast
	//
	// Cannot modify the start date time for date time targeting to the past.
	//
	DateTimeRangeTargetingErrorReasonReasonModifyStartDateTimeToPast = "MODIFY_START_DATE_TIME_TO_PAST"

	// DateTimeRangeTargetingErrorReasonReasonRangeEndTimeBeforeStartTime
	//
	// The end time of range is before the start time.
	// Could happen when start type is IMMEDIATE or ONE_HOUR_LATER.
	//
	DateTimeRangeTargetingErrorReasonReasonRangeEndTimeBeforeStartTime = "RANGE_END_TIME_BEFORE_START_TIME"

	// DateTimeRangeTargetingErrorReasonReasonEndDateTimeIsTooLate
	//
	// End date time of latest targeted ranges is too late.
	//
	DateTimeRangeTargetingErrorReasonReasonEndDateTimeIsTooLate = "END_DATE_TIME_IS_TOO_LATE"

	// DateTimeRangeTargetingErrorReasonReasonLimitedRangesInUnlimitedLineitem
	DateTimeRangeTargetingErrorReasonReasonLimitedRangesInUnlimitedLineitem = "LIMITED_RANGES_IN_UNLIMITED_LINEITEM"

	// DateTimeRangeTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DateTimeRangeTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// DayOfWeek
//
// Days of the week.
type DayOfWeek string

const (

	// DayOfWeekMonday
	//
	// The day of week named Monday.
	//
	DayOfWeekMonday DayOfWeek = "MONDAY"

	// DayOfWeekTuesday
	//
	// The day of week named Tuesday.
	//
	DayOfWeekTuesday DayOfWeek = "TUESDAY"

	// DayOfWeekWednesday
	//
	// The day of week named Wednesday.
	//
	DayOfWeekWednesday DayOfWeek = "WEDNESDAY"

	// DayOfWeekThursday
	//
	// The day of week named Thursday.
	//
	DayOfWeekThursday DayOfWeek = "THURSDAY"

	// DayOfWeekFriday
	//
	// The day of week named Friday.
	//
	DayOfWeekFriday DayOfWeek = "FRIDAY"

	// DayOfWeekSaturday
	//
	// The day of week named Saturday.
	//
	DayOfWeekSaturday DayOfWeek = "SATURDAY"

	// DayOfWeekSunday
	//
	// The day of week named Sunday.
	//
	DayOfWeekSunday DayOfWeek = "SUNDAY"
)

// DayPartTargetingErrorReasonReason
//
// The reasons for the target error.
const (

	// DayPartTargetingErrorReasonReasonInvalidHour
	//
	// Hour of day must be between 0 and 24, inclusive.
	//
	DayPartTargetingErrorReasonReasonInvalidHour = "INVALID_HOUR"

	// DayPartTargetingErrorReasonReasonInvalidMinute
	//
	// Minute of hour must be one of 0, 15,30, 45.
	//
	DayPartTargetingErrorReasonReasonInvalidMinute = "INVALID_MINUTE"

	// DayPartTargetingErrorReasonReasonEndTimeNotAfterStartTime
	//
	// The {@link DayPart#endTime} cannot be after {@link DayPart#startTime}.
	//
	DayPartTargetingErrorReasonReasonEndTimeNotAfterStartTime = "END_TIME_NOT_AFTER_START_TIME"

	// DayPartTargetingErrorReasonReasonTimePeriodsOverlap
	//
	// Cannot create day-parts that overlap.
	//
	DayPartTargetingErrorReasonReasonTimePeriodsOverlap = "TIME_PERIODS_OVERLAP"

	// DayPartTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DayPartTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// DeliveryTimeZone
//
// Represents the time zone to be used for {@link DayPartTargeting}.
type DeliveryTimeZone string

const (

	// DeliveryTimeZonePublisher
	//
	// Use the time zone of the publisher.
	//
	DeliveryTimeZonePublisher DeliveryTimeZone = "PUBLISHER"

	// DeliveryTimeZoneBrowser
	//
	// Use the time zone of the browser.
	//
	DeliveryTimeZoneBrowser DeliveryTimeZone = "BROWSER"
)

// DeliveryForecastSource
//
// Strategies for choosing forecasted traffic shapes to pace line items.
type DeliveryForecastSource string

const (

	// DeliveryForecastSourceHistorical
	//
	// The line item's historical traffic shape will be used to pace line item delivery.
	//
	DeliveryForecastSourceHistorical DeliveryForecastSource = "HISTORICAL"

	// DeliveryForecastSourceForecasting
	//
	// The line item's projected future traffic will be used to pace line item delivery.
	//
	DeliveryForecastSourceForecasting DeliveryForecastSource = "FORECASTING"

	// DeliveryForecastSourceCustomPacingCurve
	//
	// A user specified custom pacing curve will be used to pace line item delivery.
	//
	DeliveryForecastSourceCustomPacingCurve DeliveryForecastSource = "CUSTOM_PACING_CURVE"

	// DeliveryForecastSourceUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DeliveryForecastSourceUnknown DeliveryForecastSource = "UNKNOWN"
)

// DeliveryRateType
//
// Possible delivery rates for a {@link LineItem}, which dictate the manner in
// which they are served.
type DeliveryRateType string

const (

	// DeliveryRateTypeEvenly
	//
	// Line items are served as evenly as possible across the number of
	// days specified in a line item's {@link LineItem#duration}.
	//
	DeliveryRateTypeEvenly DeliveryRateType = "EVENLY"

	// DeliveryRateTypeFrontloaded
	//
	// Line items are served more aggressively in the beginning of the flight
	// date.
	//
	DeliveryRateTypeFrontloaded DeliveryRateType = "FRONTLOADED"

	// DeliveryRateTypeAsFastAsPossible
	//
	// The booked impressions for a line item may be delivered well before the
	// {@link LineItem#endDateTime}. Other lower-priority or lower-value line
	// items will be stopped from delivering until this line item meets the number
	// of impressions or clicks it is booked for.
	//
	DeliveryRateTypeAsFastAsPossible DeliveryRateType = "AS_FAST_AS_POSSIBLE"
)

// EntityChildrenLimitReachedErrorReasonReason
//
// The reasons for the entity children limit reached error.
const (

	// EntityChildrenLimitReachedErrorReasonReasonLineItemLimitForOrderReached
	//
	// The number of line items on the order exceeds the max number of line items allowed per order
	// in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonLineItemLimitForOrderReached = "LINE_ITEM_LIMIT_FOR_ORDER_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonCreativeAssociationLimitForLineItemReached
	//
	// The number of creatives associated with the line item exceeds the max number of creatives
	// allowed to be associated with a line item in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonCreativeAssociationLimitForLineItemReached = "CREATIVE_ASSOCIATION_LIMIT_FOR_LINE_ITEM_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForPlacementReached
	//
	// The number of ad units on the placement exceeds the max number of ad units
	// allowed per placement in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForPlacementReached = "AD_UNIT_LIMIT_FOR_PLACEMENT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForLineItemReached
	//
	// The number of targeting expressions on the line item exceeds the max number of targeting
	// expressions allowed per line item in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForLineItemReached = "TARGETING_EXPRESSION_LIMIT_FOR_LINE_ITEM_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionSizeLimitReached
	//
	// The size of a single targeting expression tree exceeds the max size allowed by the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionSizeLimitReached = "TARGETING_EXPRESSION_SIZE_LIMIT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonCustomTargetingValuesForKeyLimitReached
	//
	// The number of custom targeting values for the free-form or predefined custom targeting key
	// exceeds the max number allowed.
	//
	EntityChildrenLimitReachedErrorReasonReasonCustomTargetingValuesForKeyLimitReached = "CUSTOM_TARGETING_VALUES_FOR_KEY_LIMIT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForCreativesOnLineItemReached
	//
	// The total number of targeting expressions on the creatives for the line item exceeds
	// the max number allowed per line item in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForCreativesOnLineItemReached = "TARGETING_EXPRESSION_LIMIT_FOR_CREATIVES_ON_LINE_ITEM_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonAttachmentLimitForProposalReached
	//
	// The number of attachments added to the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonAttachmentLimitForProposalReached = "ATTACHMENT_LIMIT_FOR_PROPOSAL_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProposalLineItemLimitForProposalReached
	//
	// The number of proposal line items on the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProposalLineItemLimitForProposalReached = "PROPOSAL_LINE_ITEM_LIMIT_FOR_PROPOSAL_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProductLimitForProductPackageReached
	//
	// The number of product package items on the product package exceeds the max number
	// allowed per product package in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProductLimitForProductPackageReached = "PRODUCT_LIMIT_FOR_PRODUCT_PACKAGE_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProductTemplateAndProductBaseRateLimitForRateCardReached
	//
	// The number of product template and product base rates on the rate card (including excluded
	// product base rates) exceeds the max number allowed per rate card in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProductTemplateAndProductBaseRateLimitForRateCardReached = "PRODUCT_TEMPLATE_AND_PRODUCT_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProductPackageItemBaseRateLimitForRateCardReached
	//
	// The number of product package item base rates on the rate card exceeds the max number
	// allowed per rate card in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProductPackageItemBaseRateLimitForRateCardReached = "PRODUCT_PACKAGE_ITEM_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonPremiumLimitForRateCardReached
	//
	// The number of premiums of the rate card exceeds the max number allowed per rate card
	// in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonPremiumLimitForRateCardReached = "PREMIUM_LIMIT_FOR_RATE_CARD_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForAdExclusionRuleTargetingReached
	//
	// The number of ad units on {@link AdExclusionRule#inventoryTargeting} exceeds the max number
	// of ad units allowed per ad exclusion rule inventory targeting in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForAdExclusionRuleTargetingReached = "AD_UNIT_LIMIT_FOR_AD_EXCLUSION_RULE_TARGETING_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonNativeStyleLimitForNativeAdFormatReached
	//
	// The number of native styles under the native creative template exceeds the
	// max number of native styles allowed per native creative template in the
	// network.
	//
	EntityChildrenLimitReachedErrorReasonReasonNativeStyleLimitForNativeAdFormatReached = "NATIVE_STYLE_LIMIT_FOR_NATIVE_AD_FORMAT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForPresentationAssignmentReached
	//
	// The number of targeting expressions on the native style exceeds the max number of targeting
	// expressions allowed per native style in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForPresentationAssignmentReached = "TARGETING_EXPRESSION_LIMIT_FOR_PRESENTATION_ASSIGNMENT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityChildrenLimitReachedErrorReasonReasonUnknown = "UNKNOWN"
)

// EntityLimitReachedErrorReasonReason
//
// The reasons for the entity limit reached error.
const (

	// EntityLimitReachedErrorReasonReasonCustomTargetingValuesLimitReached
	//
	// The number of custom targeting values exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonCustomTargetingValuesLimitReached = "CUSTOM_TARGETING_VALUES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonAdExclusionRulesLimitReached
	//
	// The number of ad exclusion rules exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonAdExclusionRulesLimitReached = "AD_EXCLUSION_RULES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonFirstPartyAudienceSegmentsLimitReached
	//
	// The number of first party audience segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonFirstPartyAudienceSegmentsLimitReached = "FIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonPlacementsLimitReached
	//
	// The number of active placements exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonPlacementsLimitReached = "PLACEMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonLineItemsLimitReached
	//
	// The number of line items excceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonLineItemsLimitReached = "LINE_ITEMS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonActiveLineItemsLimitReached
	//
	// The number of active line items exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonActiveLineItemsLimitReached = "ACTIVE_LINE_ITEMS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonDaiEncodingProfilesLimitReached
	//
	// The number of not-archived encoding profiles exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonDaiEncodingProfilesLimitReached = "DAI_ENCODING_PROFILES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonTrafficForecastSegmentsLimitReached
	//
	// The number of traffic forecast segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonTrafficForecastSegmentsLimitReached = "TRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonForecastAdjustmentsLimitReached
	//
	// The number of forecast adjustments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonForecastAdjustmentsLimitReached = "FORECAST_ADJUSTMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonActiveExperimentsLimitReached
	//
	// The number of active experiments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonActiveExperimentsLimitReached = "ACTIVE_EXPERIMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonSitesLimitReached
	//
	// The number of sites exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonSitesLimitReached = "SITES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonUserTeamsLimitReached
	//
	// The number of teams on the user exceeds the max number allowed.
	//
	EntityLimitReachedErrorReasonReasonUserTeamsLimitReached = "USER_TEAMS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityLimitReachedErrorReasonReasonUnknown = "UNKNOWN"
)

// EnvironmentType
//
// Enum for the valid environments in which ads can be shown.
type EnvironmentType string

const (

	// EnvironmentTypeBrowser
	//
	// A regular web browser.
	//
	EnvironmentTypeBrowser EnvironmentType = "BROWSER"

	// EnvironmentTypeVideoPlayer
	//
	// Video players.
	//
	EnvironmentTypeVideoPlayer EnvironmentType = "VIDEO_PLAYER"
)

// FeatureErrorReasonReason
const (

	// FeatureErrorReasonReasonMissingFeature
	//
	// A feature is being used that is not enabled on the current network.
	//
	FeatureErrorReasonReasonMissingFeature = "MISSING_FEATURE"

	// FeatureErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FeatureErrorReasonReasonUnknown = "UNKNOWN"
)

// ForecastErrorReasonReason
//
// Reason why a forecast could not be retrieved.
const (

	// ForecastErrorReasonReasonServerNotAvailable
	//
	// The forecast could not be retrieved due to a server side
	// connection problem. Please try again soon.
	//
	ForecastErrorReasonReasonServerNotAvailable = "SERVER_NOT_AVAILABLE"

	// ForecastErrorReasonReasonInternalError
	//
	// There was an unexpected internal error.
	//
	ForecastErrorReasonReasonInternalError = "INTERNAL_ERROR"

	// ForecastErrorReasonReasonNoForecastYet
	//
	// The forecast could not be retrieved because there is not
	// enough forecasting data available yet. It may take up to one week before
	// enough data is available.
	//
	ForecastErrorReasonReasonNoForecastYet = "NO_FORECAST_YET"

	// ForecastErrorReasonReasonNotEnoughInventory
	//
	// There's not enough inventory for the requested reservation.
	//
	ForecastErrorReasonReasonNotEnoughInventory = "NOT_ENOUGH_INVENTORY"

	// ForecastErrorReasonReasonSuccess
	//
	// No error from forecast.
	//
	ForecastErrorReasonReasonSuccess = "SUCCESS"

	// ForecastErrorReasonReasonZeroLengthReservation
	//
	// The requested reservation is of zero length.  No forecast is returned.
	//
	ForecastErrorReasonReasonZeroLengthReservation = "ZERO_LENGTH_RESERVATION"

	// ForecastErrorReasonReasonExceededQuota
	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>
	// Another way to mitigate this error is to limit requests to 2 per second.
	// Once again this does not guarantee that every request will succeed, but
	// may help reduce the number of times you receive this error.
	// </p>
	//
	ForecastErrorReasonReasonExceededQuota = "EXCEEDED_QUOTA"

	// ForecastErrorReasonReasonOutsideAvailableDateRange
	//
	// The request falls outside the date range of the available data.
	//
	ForecastErrorReasonReasonOutsideAvailableDateRange = "OUTSIDE_AVAILABLE_DATE_RANGE"

	// ForecastErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ForecastErrorReasonReasonUnknown = "UNKNOWN"
)

// FrequencyCapErrorReasonReason
//
// The reasons for the frequency cap error.
const (

	// FrequencyCapErrorReasonReasonImpressionLimitExceeded
	FrequencyCapErrorReasonReasonImpressionLimitExceeded = "IMPRESSION_LIMIT_EXCEEDED"

	// FrequencyCapErrorReasonReasonImpressionsTooLow
	FrequencyCapErrorReasonReasonImpressionsTooLow = "IMPRESSIONS_TOO_LOW"

	// FrequencyCapErrorReasonReasonRangeLimitExceeded
	FrequencyCapErrorReasonReasonRangeLimitExceeded = "RANGE_LIMIT_EXCEEDED"

	// FrequencyCapErrorReasonReasonRangeTooLow
	FrequencyCapErrorReasonReasonRangeTooLow = "RANGE_TOO_LOW"

	// FrequencyCapErrorReasonReasonDuplicateTimeRange
	FrequencyCapErrorReasonReasonDuplicateTimeRange = "DUPLICATE_TIME_RANGE"

	// FrequencyCapErrorReasonReasonDuplicateTimeUnit
	FrequencyCapErrorReasonReasonDuplicateTimeUnit = "DUPLICATE_TIME_UNIT"

	// FrequencyCapErrorReasonReasonTooManyFrequencyCaps
	FrequencyCapErrorReasonReasonTooManyFrequencyCaps = "TOO_MANY_FREQUENCY_CAPS"

	// FrequencyCapErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FrequencyCapErrorReasonReasonUnknown = "UNKNOWN"
)

// GenericTargetingErrorReasonReason
//
// The reasons for the target error.
const (

	// GenericTargetingErrorReasonReasonConflictingInclusionOrExclusionOfSiblings
	//
	// Both including and excluding sibling criteria is disallowed.
	//
	GenericTargetingErrorReasonReasonConflictingInclusionOrExclusionOfSiblings = "CONFLICTING_INCLUSION_OR_EXCLUSION_OF_SIBLINGS"

	// GenericTargetingErrorReasonReasonIncludingDescendantsOfExcludedCriteria
	//
	// Including descendants of excluded criteria is disallowed.
	//
	GenericTargetingErrorReasonReasonIncludingDescendantsOfExcludedCriteria = "INCLUDING_DESCENDANTS_OF_EXCLUDED_CRITERIA"

	// GenericTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GenericTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// GeoTargetingErrorReasonReason
//
// The reasons for the target error.
const (

	// GeoTargetingErrorReasonReasonTargetedLocationsNotExcludable
	//
	// A location that is targeted cannot also be excluded.
	//
	GeoTargetingErrorReasonReasonTargetedLocationsNotExcludable = "TARGETED_LOCATIONS_NOT_EXCLUDABLE"

	// GeoTargetingErrorReasonReasonExcludedLocationsCannotHaveChildrenTargeted
	//
	// Excluded locations cannot have any of their children targeted.
	//
	GeoTargetingErrorReasonReasonExcludedLocationsCannotHaveChildrenTargeted = "EXCLUDED_LOCATIONS_CANNOT_HAVE_CHILDREN_TARGETED"

	// GeoTargetingErrorReasonReasonPostalCodesCannotBeExcluded
	//
	// Postal codes cannot be excluded.
	//
	GeoTargetingErrorReasonReasonPostalCodesCannotBeExcluded = "POSTAL_CODES_CANNOT_BE_EXCLUDED"

	// GeoTargetingErrorReasonReasonUntargetableLocation
	//
	// Indicates that location targeting is not allowed.
	//
	GeoTargetingErrorReasonReasonUntargetableLocation = "UNTARGETABLE_LOCATION"

	// GeoTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GeoTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// GoalType
//
// Specifies the type of the goal for a {@link LineItem}.
type GoalType string

const (

	// GoalTypeNone
	//
	// No goal is specified for the number of ads delivered. The
	// {@link LineItem#lineItemType} must be one of:
	// <ul>
	// <li>{@link LineItemType#PRICE_PRIORITY}</li>
	// <li>{@link LineItemType#AD_EXCHANGE}</li>
	// <li>{@link LineItemType#CLICK_TRACKING}</li>
	// </ul>
	//
	GoalTypeNone GoalType = "NONE"

	// GoalTypeLifetime
	//
	// There is a goal on the number of ads delivered for this line item during
	// its entire lifetime. The {@link LineItem#lineItemType} must be
	// one of:
	// <ul>
	// <li>{@link LineItemType#STANDARD}</li>
	// <li>{@link LineItemType#BULK}</li>
	// <li>{@link LineItemType#PRICE_PRIORITY}</li>
	// <li>{@link LineItemType#ADSENSE}</li>
	// <li>{@link LineItemType#AD_EXCHANGE}</li>
	// <li>{@link LineItemType#ADMOB}</li>
	// <li>{@link LineItemType#CLICK_TRACKING}</li>
	// </ul>
	//
	GoalTypeLifetime GoalType = "LIFETIME"

	// GoalTypeDaily
	//
	// There is a daily goal on the number of ads delivered for this line item.
	// The {@link LineItem#lineItemType} must be one of:
	// <ul>
	// <li>{@link LineItemType#SPONSORSHIP}</li>
	// <li>{@link LineItemType#NETWORK}</li>
	// <li>{@link LineItemType#PRICE_PRIORITY}</li>
	// <li>{@link LineItemType#HOUSE}</li>
	// <li>{@link LineItemType#ADSENSE}</li>
	// <li>{@link LineItemType#AD_EXCHANGE}</li>
	// <li>{@link LineItemType#ADMOB}</li>
	// <li>{@link LineItemType#BUMPER}</li>
	// </ul>
	//
	GoalTypeDaily GoalType = "DAILY"

	// GoalTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GoalTypeUnknown GoalType = "UNKNOWN"
)

// GrpProvider
//
// Represents available GRP providers that a line item will have its target demographic measured
// by.
type GrpProvider string

const (

	// GrpProviderUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GrpProviderUnknown GrpProvider = "UNKNOWN"

	// GrpProviderNielsen
	GrpProviderNielsen GrpProvider = "NIELSEN"

	// GrpProviderGoogle
	//
	// Renamed to {@code GOOGLE} beginning in V201608.
	//
	GrpProviderGoogle GrpProvider = "GOOGLE"
)

// GrpSettingsErrorReasonReason
//
// Reason for GRP settings error.
const (

	// GrpSettingsErrorReasonReasonInvalidAgeRange
	//
	// Age range for GRP audience is not valid. Please see the
	// <a href="https://support.google.com/admanager/answer/6135438">Ad Manager Help Center</a>
	// for more information.
	//
	GrpSettingsErrorReasonReasonInvalidAgeRange = "INVALID_AGE_RANGE"

	// GrpSettingsErrorReasonReasonUnder18MinAgeRequiresAllAges
	//
	// Age range for GRP audience is not allowed to include ages under 18 unless designating all
	// ages in target(2-65+).
	//
	GrpSettingsErrorReasonReasonUnder18MinAgeRequiresAllAges = "UNDER_18_MIN_AGE_REQUIRES_ALL_AGES"

	// GrpSettingsErrorReasonReasonLineItemEnvironmentTypeNotSupported
	//
	// GRP settings are only supported for video line items.
	//
	GrpSettingsErrorReasonReasonLineItemEnvironmentTypeNotSupported = "LINE_ITEM_ENVIRONMENT_TYPE_NOT_SUPPORTED"

	// GrpSettingsErrorReasonReasonNielsenDarRequiresInstreamVideo
	//
	// For deals with Nielsen DAR enabled, there must be an instream video environment.
	//
	GrpSettingsErrorReasonReasonNielsenDarRequiresInstreamVideo = "NIELSEN_DAR_REQUIRES_INSTREAM_VIDEO"

	// GrpSettingsErrorReasonReasonLineItemTypeNotSupported
	//
	// GRP settings are not supported for the given line item type.
	//
	GrpSettingsErrorReasonReasonLineItemTypeNotSupported = "LINE_ITEM_TYPE_NOT_SUPPORTED"

	// GrpSettingsErrorReasonReasonCannotSpecifyGenderForGivenAgeRange
	//
	// GRP audience gender cannot be specified for the selected age range.
	//
	GrpSettingsErrorReasonReasonCannotSpecifyGenderForGivenAgeRange = "CANNOT_SPECIFY_GENDER_FOR_GIVEN_AGE_RANGE"

	// GrpSettingsErrorReasonReasonInvalidMinAge
	//
	// Minimum age for GRP audience is not valid.
	//
	GrpSettingsErrorReasonReasonInvalidMinAge = "INVALID_MIN_AGE"

	// GrpSettingsErrorReasonReasonInvalidMaxAge
	//
	// Maximum age for GRP audience is not valid.
	//
	GrpSettingsErrorReasonReasonInvalidMaxAge = "INVALID_MAX_AGE"

	// GrpSettingsErrorReasonReasonCannotDisableGrpAfterEnabling
	//
	// GRP settings cannot be disabled.
	//
	GrpSettingsErrorReasonReasonCannotDisableGrpAfterEnabling = "CANNOT_DISABLE_GRP_AFTER_ENABLING"

	// GrpSettingsErrorReasonReasonCannotChangeGrpProviders
	//
	// GRP provider cannot be updated.
	//
	GrpSettingsErrorReasonReasonCannotChangeGrpProviders = "CANNOT_CHANGE_GRP_PROVIDERS"

	// GrpSettingsErrorReasonReasonCannotChangeGrpSettings
	//
	// GRP settings cannot be updated once the line item has started serving.
	//
	GrpSettingsErrorReasonReasonCannotChangeGrpSettings = "CANNOT_CHANGE_GRP_SETTINGS"

	// GrpSettingsErrorReasonReasonGrpAudienceGoalNotSupported
	//
	// Impression goal based on GRP audience is not supported.
	//
	GrpSettingsErrorReasonReasonGrpAudienceGoalNotSupported = "GRP_AUDIENCE_GOAL_NOT_SUPPORTED"

	// GrpSettingsErrorReasonReasonDemogGoalExpected
	//
	// Impression goal based on GRP audience expected.
	//
	GrpSettingsErrorReasonReasonDemogGoalExpected = "DEMOG_GOAL_EXPECTED"

	// GrpSettingsErrorReasonReasonCannotSetGrpAudienceGoal
	//
	// Impression goal based on GRP audience cannot be set once the line item has started serving.
	//
	GrpSettingsErrorReasonReasonCannotSetGrpAudienceGoal = "CANNOT_SET_GRP_AUDIENCE_GOAL"

	// GrpSettingsErrorReasonReasonCannotRemoveGrpAudienceGoal
	//
	// Impression goal based on GRP audience cannot be removed once the line item has started
	// serving.
	//
	GrpSettingsErrorReasonReasonCannotRemoveGrpAudienceGoal = "CANNOT_REMOVE_GRP_AUDIENCE_GOAL"

	// GrpSettingsErrorReasonReasonUnsupportedGeoTargeting
	//
	// Unsupported geographic location targeted for line item with GRP audience goal.
	//
	GrpSettingsErrorReasonReasonUnsupportedGeoTargeting = "UNSUPPORTED_GEO_TARGETING"

	// GrpSettingsErrorReasonReasonUnsupportedGrpSetting
	//
	// GRP Settings specified are unsupported.
	//
	GrpSettingsErrorReasonReasonUnsupportedGrpSetting = "UNSUPPORTED_GRP_SETTING"

	// GrpSettingsErrorReasonReasonShouldSetInTargetGoalThroughGrpSettings
	//
	// In-target line items should be set through the grpSettings target impression goal.
	//
	GrpSettingsErrorReasonReasonShouldSetInTargetGoalThroughGrpSettings = "SHOULD_SET_IN_TARGET_GOAL_THROUGH_GRP_SETTINGS"

	// GrpSettingsErrorReasonReasonShouldSetInTargetGoalThroughPrimaryGoal
	//
	// In-target line items should be set through the primaryReservationUnit's in-target Impressions
	// unit type.
	//
	GrpSettingsErrorReasonReasonShouldSetInTargetGoalThroughPrimaryGoal = "SHOULD_SET_IN_TARGET_GOAL_THROUGH_PRIMARY_GOAL"

	// GrpSettingsErrorReasonReasonNielsenRegistrationFailed
	//
	// Attempt to register with Nielsen failed.
	//
	GrpSettingsErrorReasonReasonNielsenRegistrationFailed = "NIELSEN_REGISTRATION_FAILED"

	// GrpSettingsErrorReasonReasonLegacyNielsenCampaignRegistrationAttempt
	//
	// Attempted to register a placement on a legacy Nielsen campaign.
	//
	GrpSettingsErrorReasonReasonLegacyNielsenCampaignRegistrationAttempt = "LEGACY_NIELSEN_CAMPAIGN_REGISTRATION_ATTEMPT"

	// GrpSettingsErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GrpSettingsErrorReasonReasonUnknown = "UNKNOWN"
)

// GrpTargetGender
//
// Represents the target gender for a GRP demographic targeted line item.
type GrpTargetGender string

const (

	// GrpTargetGenderUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GrpTargetGenderUnknown GrpTargetGender = "UNKNOWN"

	// GrpTargetGenderMale
	//
	// Indicates that the GRP target gender is Male.
	//
	GrpTargetGenderMale GrpTargetGender = "MALE"

	// GrpTargetGenderFemale
	//
	// Indicates that the GRP target gender is Female.
	//
	GrpTargetGenderFemale GrpTargetGender = "FEMALE"

	// GrpTargetGenderBoth
	//
	// Indicates that the GRP target gender is both male and female.
	//
	GrpTargetGenderBoth GrpTargetGender = "BOTH"
)

// ImageErrorReasonReason
//
// The reasons for the target error.
const (

	// ImageErrorReasonReasonInvalidImage
	//
	// The file's format is invalid.
	//
	ImageErrorReasonReasonInvalidImage = "INVALID_IMAGE"

	// ImageErrorReasonReasonInvalidSize
	//
	// {@link Size#width} and {@link Size#height} cannot be negative.
	//
	ImageErrorReasonReasonInvalidSize = "INVALID_SIZE"

	// ImageErrorReasonReasonUnexpectedSize
	//
	// The actual image size does not match the expected image size.
	//
	ImageErrorReasonReasonUnexpectedSize = "UNEXPECTED_SIZE"

	// ImageErrorReasonReasonOverlaySizeTooLarge
	//
	// The size of the asset is larger than that of the overlay creative.
	//
	ImageErrorReasonReasonOverlaySizeTooLarge = "OVERLAY_SIZE_TOO_LARGE"

	// ImageErrorReasonReasonAnimatedNotAllowed
	//
	// Animated images are not allowed.
	//
	ImageErrorReasonReasonAnimatedNotAllowed = "ANIMATED_NOT_ALLOWED"

	// ImageErrorReasonReasonAnimationTooLong
	//
	// Animation length exceeded the allowed policy limit.
	//
	ImageErrorReasonReasonAnimationTooLong = "ANIMATION_TOO_LONG"

	// ImageErrorReasonReasonCmykJpegNotAllowed
	//
	// Images in CMYK color formats are not allowed.
	//
	ImageErrorReasonReasonCmykJpegNotAllowed = "CMYK_JPEG_NOT_ALLOWED"

	// ImageErrorReasonReasonFlashNotAllowed
	//
	// Flash files are not allowed.
	//
	ImageErrorReasonReasonFlashNotAllowed = "FLASH_NOT_ALLOWED"

	// ImageErrorReasonReasonFlashWithoutClicktag
	//
	// If {@link FlashCreative#clickTagRequired} is {@code true}, then the flash
	// file is required to have a click tag embedded in it.
	//
	ImageErrorReasonReasonFlashWithoutClicktag = "FLASH_WITHOUT_CLICKTAG"

	// ImageErrorReasonReasonAnimatedVisualEffect
	//
	// Animated visual effect is not allowed.
	//
	ImageErrorReasonReasonAnimatedVisualEffect = "ANIMATED_VISUAL_EFFECT"

	// ImageErrorReasonReasonFlashError
	//
	// An error was encountered in the flash file.
	//
	ImageErrorReasonReasonFlashError = "FLASH_ERROR"

	// ImageErrorReasonReasonLayoutProblem
	//
	// Incorrect image layout.
	//
	ImageErrorReasonReasonLayoutProblem = "LAYOUT_PROBLEM"

	// ImageErrorReasonReasonFlashHasNetworkObjects
	//
	// Flash files with network objects are not allowed.
	//
	ImageErrorReasonReasonFlashHasNetworkObjects = "FLASH_HAS_NETWORK_OBJECTS"

	// ImageErrorReasonReasonFlashHasNetworkMethods
	//
	// Flash files with network methods are not allowed.
	//
	ImageErrorReasonReasonFlashHasNetworkMethods = "FLASH_HAS_NETWORK_METHODS"

	// ImageErrorReasonReasonFlashHasUrl
	//
	// Flash files with hard-coded click thru URLs are not allowed.
	//
	ImageErrorReasonReasonFlashHasUrl = "FLASH_HAS_URL"

	// ImageErrorReasonReasonFlashHasMouseTracking
	//
	// Flash files with mouse tracking are not allowed.
	//
	ImageErrorReasonReasonFlashHasMouseTracking = "FLASH_HAS_MOUSE_TRACKING"

	// ImageErrorReasonReasonFlashHasRandomNum
	//
	// Flash files that generate or use random numbers are not allowed.
	//
	ImageErrorReasonReasonFlashHasRandomNum = "FLASH_HAS_RANDOM_NUM"

	// ImageErrorReasonReasonFlashSelfTargets
	//
	// Flash files with self targets are not allowed.
	//
	ImageErrorReasonReasonFlashSelfTargets = "FLASH_SELF_TARGETS"

	// ImageErrorReasonReasonFlashBadGeturlTarget
	//
	// Flash file contains a bad geturl target.
	//
	ImageErrorReasonReasonFlashBadGeturlTarget = "FLASH_BAD_GETURL_TARGET"

	// ImageErrorReasonReasonFlashVersionNotSupported
	//
	// Flash or ActionScript version in the submitted file is not supported.
	//
	ImageErrorReasonReasonFlashVersionNotSupported = "FLASH_VERSION_NOT_SUPPORTED"

	// ImageErrorReasonReasonFileTooLarge
	//
	// The uploaded file is too large.
	//
	ImageErrorReasonReasonFileTooLarge = "FILE_TOO_LARGE"

	// ImageErrorReasonReasonSystemErrorIrs
	//
	// A system error occurred, please try again.
	//
	ImageErrorReasonReasonSystemErrorIrs = "SYSTEM_ERROR_IRS"

	// ImageErrorReasonReasonSystemErrorScs
	//
	// A system error occurred, please try again.
	//
	ImageErrorReasonReasonSystemErrorScs = "SYSTEM_ERROR_SCS"

	// ImageErrorReasonReasonUnexpectedPrimaryAssetDensity
	//
	// The image density for a primary asset was not one of the expected image densities.
	//
	ImageErrorReasonReasonUnexpectedPrimaryAssetDensity = "UNEXPECTED_PRIMARY_ASSET_DENSITY"

	// ImageErrorReasonReasonDuplicateAssetDensity
	//
	// Two or more assets have the same image density.
	//
	ImageErrorReasonReasonDuplicateAssetDensity = "DUPLICATE_ASSET_DENSITY"

	// ImageErrorReasonReasonMissingDefaultAsset
	//
	// The creative does not contain a primary asset. (For high-density creatives, the primary
	// asset must be a standard image file with 1x density.)
	//
	ImageErrorReasonReasonMissingDefaultAsset = "MISSING_DEFAULT_ASSET"

	// ImageErrorReasonReasonPreverifiedMimetypeNotAllowed
	//
	// preverified_mime_type is not in the client spec's allowlist.
	//
	ImageErrorReasonReasonPreverifiedMimetypeNotAllowed = "PREVERIFIED_MIMETYPE_NOT_ALLOWED"

	// ImageErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ImageErrorReasonReasonUnknown = "UNKNOWN"
)

// InternalApiErrorReasonReason
//
// The single reason for the internal API error.
const (

	// InternalApiErrorReasonReasonUnexpectedInternalApiError
	//
	// API encountered an unexpected internal error.
	//
	InternalApiErrorReasonReasonUnexpectedInternalApiError = "UNEXPECTED_INTERNAL_API_ERROR"

	// InternalApiErrorReasonReasonTransientError
	//
	// A temporary error occurred during the request. Please retry.
	//
	InternalApiErrorReasonReasonTransientError = "TRANSIENT_ERROR"

	// InternalApiErrorReasonReasonUnknown
	//
	// The cause of the error is not known or only defined in newer versions.
	//
	InternalApiErrorReasonReasonUnknown = "UNKNOWN"

	// InternalApiErrorReasonReasonDowntime
	//
	// The API is currently unavailable for a planned downtime.
	//
	InternalApiErrorReasonReasonDowntime = "DOWNTIME"

	// InternalApiErrorReasonReasonErrorGeneratingResponse
	//
	// Mutate succeeded but server was unable to build response. Client should not retry mutate.
	//
	InternalApiErrorReasonReasonErrorGeneratingResponse = "ERROR_GENERATING_RESPONSE"
)

// InvalidUrlErrorReasonReason
const (

	// InvalidUrlErrorReasonReasonIllegalCharacters
	//
	// The URL contains invalid characters.
	//
	InvalidUrlErrorReasonReasonIllegalCharacters = "ILLEGAL_CHARACTERS"

	// InvalidUrlErrorReasonReasonInvalidFormat
	//
	// The format of the URL is not allowed. This could occur for a number of
	// reasons. For example, if an invalid scheme is specified (like "ftp://")
	// or if a port is specified when not required, or if a query was specified
	// when not required.
	//
	InvalidUrlErrorReasonReasonInvalidFormat = "INVALID_FORMAT"

	// InvalidUrlErrorReasonReasonInsecureScheme
	//
	// URL contains insecure scheme.
	//
	InvalidUrlErrorReasonReasonInsecureScheme = "INSECURE_SCHEME"

	// InvalidUrlErrorReasonReasonNoScheme
	//
	// The URL does not contain a scheme.
	//
	InvalidUrlErrorReasonReasonNoScheme = "NO_SCHEME"

	// InvalidUrlErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InvalidUrlErrorReasonReasonUnknown = "UNKNOWN"
)

// InventoryTargetingErrorReasonReason
//
// The reasons for the target error.
const (

	// InventoryTargetingErrorReasonReasonAtLeastOnePlacementOrInventoryUnitRequired
	//
	// At least one placement or inventory unit is required
	//
	InventoryTargetingErrorReasonReasonAtLeastOnePlacementOrInventoryUnitRequired = "AT_LEAST_ONE_PLACEMENT_OR_INVENTORY_UNIT_REQUIRED"

	// InventoryTargetingErrorReasonReasonInventoryCannotBeTargetedAndExcluded
	//
	// The same inventory unit or placement cannot be targeted and excluded at
	// the same time
	//
	InventoryTargetingErrorReasonReasonInventoryCannotBeTargetedAndExcluded = "INVENTORY_CANNOT_BE_TARGETED_AND_EXCLUDED"

	// InventoryTargetingErrorReasonReasonInventoryUnitCannotBeTargetedIfAncestorIsTargeted
	//
	// A child inventory unit cannot be targeted if its ancestor inventory unit
	// is also targeted.
	//
	InventoryTargetingErrorReasonReasonInventoryUnitCannotBeTargetedIfAncestorIsTargeted = "INVENTORY_UNIT_CANNOT_BE_TARGETED_IF_ANCESTOR_IS_TARGETED"

	// InventoryTargetingErrorReasonReasonInventoryUnitCannotBeTargetedIfAncestorIsExcluded
	//
	// A child inventory unit cannot be targeted if its ancestor inventory unit
	// is excluded.
	//
	InventoryTargetingErrorReasonReasonInventoryUnitCannotBeTargetedIfAncestorIsExcluded = "INVENTORY_UNIT_CANNOT_BE_TARGETED_IF_ANCESTOR_IS_EXCLUDED"

	// InventoryTargetingErrorReasonReasonInventoryUnitCannotBeExcludedIfAncestorIsExcluded
	//
	// A child inventory unit cannot be excluded if its ancestor inventory unit
	// is also excluded.
	//
	InventoryTargetingErrorReasonReasonInventoryUnitCannotBeExcludedIfAncestorIsExcluded = "INVENTORY_UNIT_CANNOT_BE_EXCLUDED_IF_ANCESTOR_IS_EXCLUDED"

	// InventoryTargetingErrorReasonReasonExplicitlyTargetedInventoryUnitCannotBeTargeted
	//
	// An explicitly targeted inventory unit cannot be targeted.
	//
	InventoryTargetingErrorReasonReasonExplicitlyTargetedInventoryUnitCannotBeTargeted = "EXPLICITLY_TARGETED_INVENTORY_UNIT_CANNOT_BE_TARGETED"

	// InventoryTargetingErrorReasonReasonExplicitlyTargetedInventoryUnitCannotBeExcluded
	//
	// An explicitly targeted inventory unit cannot be excluded.
	//
	InventoryTargetingErrorReasonReasonExplicitlyTargetedInventoryUnitCannotBeExcluded = "EXPLICITLY_TARGETED_INVENTORY_UNIT_CANNOT_BE_EXCLUDED"

	// InventoryTargetingErrorReasonReasonSelfOnlyInventoryUnitNotAllowed
	//
	// A landing page-only ad unit cannot be targeted.
	//
	InventoryTargetingErrorReasonReasonSelfOnlyInventoryUnitNotAllowed = "SELF_ONLY_INVENTORY_UNIT_NOT_ALLOWED"

	// InventoryTargetingErrorReasonReasonSelfOnlyInventoryUnitWithoutDescendants
	//
	// A landing page-only ad unit cannot be targeted if it doesn't have any
	// children.
	//
	InventoryTargetingErrorReasonReasonSelfOnlyInventoryUnitWithoutDescendants = "SELF_ONLY_INVENTORY_UNIT_WITHOUT_DESCENDANTS"

	// InventoryTargetingErrorReasonReasonYoutubeAudienceSegmentsCanOnlyBeTargetedWithYoutubeSharedInventory
	//
	// Audience segments shared from YouTube can only be targeted with inventory shared
	// from YouTube for cross selling.
	//
	InventoryTargetingErrorReasonReasonYoutubeAudienceSegmentsCanOnlyBeTargetedWithYoutubeSharedInventory = "YOUTUBE_AUDIENCE_SEGMENTS_CAN_ONLY_BE_TARGETED_WITH_YOUTUBE_SHARED_INVENTORY"

	// InventoryTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InventoryTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// LabelEntityAssociationErrorReasonReason
//
// The reasons for the target error.
const (

	// LabelEntityAssociationErrorReasonReasonDuplicateAssociation
	//
	// The label has already been attached to the entity.
	//
	LabelEntityAssociationErrorReasonReasonDuplicateAssociation = "DUPLICATE_ASSOCIATION"

	// LabelEntityAssociationErrorReasonReasonInvalidAssociation
	//
	// A label is being applied to an entity that does not support that entity
	// type.
	//
	LabelEntityAssociationErrorReasonReasonInvalidAssociation = "INVALID_ASSOCIATION"

	// LabelEntityAssociationErrorReasonReasonNegationNotAllowed
	//
	// Label negation cannot be applied to the entity type.
	//
	LabelEntityAssociationErrorReasonReasonNegationNotAllowed = "NEGATION_NOT_ALLOWED"

	// LabelEntityAssociationErrorReasonReasonDuplicateAssociationWithNegation
	//
	// The same label is being applied and negated to the same entity.
	//
	LabelEntityAssociationErrorReasonReasonDuplicateAssociationWithNegation = "DUPLICATE_ASSOCIATION_WITH_NEGATION"

	// LabelEntityAssociationErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LabelEntityAssociationErrorReasonReasonUnknown = "UNKNOWN"
)

// LineItemActivityAssociationErrorReasonReason
//
// The reasons for the target error.
const (

	// LineItemActivityAssociationErrorReasonReasonInvalidActivityForAdvertiser
	//
	// When associating an activity to a line item the activity must belong to the same
	// advertiser as the line item.
	//
	LineItemActivityAssociationErrorReasonReasonInvalidActivityForAdvertiser = "INVALID_ACTIVITY_FOR_ADVERTISER"

	// LineItemActivityAssociationErrorReasonReasonInvalidCostTypeForAssociation
	//
	// Activities can only be associated with line items of {@link CostType.CPA}.
	//
	LineItemActivityAssociationErrorReasonReasonInvalidCostTypeForAssociation = "INVALID_COST_TYPE_FOR_ASSOCIATION"

	// LineItemActivityAssociationErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LineItemActivityAssociationErrorReasonReasonUnknown = "UNKNOWN"
)

// LineItemCreativeAssociationErrorReasonReason
//
// The reasons for the target error.
const (

	// LineItemCreativeAssociationErrorReasonReasonCreativeInWrongAdvertisersLibrary
	//
	// Cannot associate a creative to the wrong advertiser
	//
	LineItemCreativeAssociationErrorReasonReasonCreativeInWrongAdvertisersLibrary = "CREATIVE_IN_WRONG_ADVERTISERS_LIBRARY"

	// LineItemCreativeAssociationErrorReasonReasonInvalidLineitemCreativePairing
	//
	// The creative type being associated is a invalid for the line item type.
	//
	LineItemCreativeAssociationErrorReasonReasonInvalidLineitemCreativePairing = "INVALID_LINEITEM_CREATIVE_PAIRING"

	// LineItemCreativeAssociationErrorReasonReasonStartdateBeforeLineitemStartdate
	//
	// Association start date cannot be before line item start date
	//
	LineItemCreativeAssociationErrorReasonReasonStartdateBeforeLineitemStartdate = "STARTDATE_BEFORE_LINEITEM_STARTDATE"

	// LineItemCreativeAssociationErrorReasonReasonStartdateNotBeforeLineitemEnddate
	//
	// Association start date cannot be same as or after line item end date
	//
	LineItemCreativeAssociationErrorReasonReasonStartdateNotBeforeLineitemEnddate = "STARTDATE_NOT_BEFORE_LINEITEM_ENDDATE"

	// LineItemCreativeAssociationErrorReasonReasonEnddateAfterLineitemEnddate
	//
	// Association end date cannot be after line item end date
	//
	LineItemCreativeAssociationErrorReasonReasonEnddateAfterLineitemEnddate = "ENDDATE_AFTER_LINEITEM_ENDDATE"

	// LineItemCreativeAssociationErrorReasonReasonEnddateNotAfterLineitemStartdate
	//
	// Association end date cannot be same as or before line item start date
	//
	LineItemCreativeAssociationErrorReasonReasonEnddateNotAfterLineitemStartdate = "ENDDATE_NOT_AFTER_LINEITEM_STARTDATE"

	// LineItemCreativeAssociationErrorReasonReasonEnddateNotAfterStartdate
	//
	// Association end date cannot be same as or before its start date
	//
	LineItemCreativeAssociationErrorReasonReasonEnddateNotAfterStartdate = "ENDDATE_NOT_AFTER_STARTDATE"

	// LineItemCreativeAssociationErrorReasonReasonEnddateInThePast
	//
	// Association end date cannot be in the past.
	//
	LineItemCreativeAssociationErrorReasonReasonEnddateInThePast = "ENDDATE_IN_THE_PAST"

	// LineItemCreativeAssociationErrorReasonReasonCannotCopyWithinSameLineItem
	//
	// Cannot copy an association to the same line item without
	// creating new creative
	//
	LineItemCreativeAssociationErrorReasonReasonCannotCopyWithinSameLineItem = "CANNOT_COPY_WITHIN_SAME_LINE_ITEM"

	// LineItemCreativeAssociationErrorReasonReasonUnsupportedCreativeVastRedirectType
	//
	// Programmatic only supports the "Video" redirect type.
	//
	LineItemCreativeAssociationErrorReasonReasonUnsupportedCreativeVastRedirectType = "UNSUPPORTED_CREATIVE_VAST_REDIRECT_TYPE"

	// LineItemCreativeAssociationErrorReasonReasonUnsupportedYoutubeHostedCreative
	//
	// Programmatic does not support YouTube hosted creatives.
	//
	LineItemCreativeAssociationErrorReasonReasonUnsupportedYoutubeHostedCreative = "UNSUPPORTED_YOUTUBE_HOSTED_CREATIVE"

	// LineItemCreativeAssociationErrorReasonReasonProgrammaticCreativesCanOnlyBeAssignedToOneLineItem
	//
	// Programmatic creatives can only be assigned to one line item.
	//
	LineItemCreativeAssociationErrorReasonReasonProgrammaticCreativesCanOnlyBeAssignedToOneLineItem = "PROGRAMMATIC_CREATIVES_CAN_ONLY_BE_ASSIGNED_TO_ONE_LINE_ITEM"

	// LineItemCreativeAssociationErrorReasonReasonCannotActivateAssociationWithInactiveCreative
	//
	// Cannot activate a line item creative association if the associated creative is inactive.
	//
	LineItemCreativeAssociationErrorReasonReasonCannotActivateAssociationWithInactiveCreative = "CANNOT_ACTIVATE_ASSOCIATION_WITH_INACTIVE_CREATIVE"

	// LineItemCreativeAssociationErrorReasonReasonCannotCreateProgrammaticCreatives
	//
	// Cannot create programmatic creatives.
	//
	LineItemCreativeAssociationErrorReasonReasonCannotCreateProgrammaticCreatives = "CANNOT_CREATE_PROGRAMMATIC_CREATIVES"

	// LineItemCreativeAssociationErrorReasonReasonCannotUpdateProgrammaticCreatives
	//
	// Cannot update programmatic creatives.
	//
	LineItemCreativeAssociationErrorReasonReasonCannotUpdateProgrammaticCreatives = "CANNOT_UPDATE_PROGRAMMATIC_CREATIVES"

	// LineItemCreativeAssociationErrorReasonReasonCreativeAndLineItemMustBothBeSetTopBoxEnabled
	//
	// Cannot associate a creative with a line item if only one of them is set-top box enabled.
	//
	LineItemCreativeAssociationErrorReasonReasonCreativeAndLineItemMustBothBeSetTopBoxEnabled = "CREATIVE_AND_LINE_ITEM_MUST_BOTH_BE_SET_TOP_BOX_ENABLED"

	// LineItemCreativeAssociationErrorReasonReasonCannotDeleteSetTopBoxEnabledAssociations
	//
	// Cannot delete associations between set-top box enabled line items and set-top box enabled
	// creatives.
	//
	LineItemCreativeAssociationErrorReasonReasonCannotDeleteSetTopBoxEnabledAssociations = "CANNOT_DELETE_SET_TOP_BOX_ENABLED_ASSOCIATIONS"

	// LineItemCreativeAssociationErrorReasonReasonSetTopBoxCreativeRotationWeightMustBeInteger
	//
	// Creative rotation weights must be integers.
	//
	LineItemCreativeAssociationErrorReasonReasonSetTopBoxCreativeRotationWeightMustBeInteger = "SET_TOP_BOX_CREATIVE_ROTATION_WEIGHT_MUST_BE_INTEGER"

	// LineItemCreativeAssociationErrorReasonReasonInvalidCreativeRotationTypeForManualWeight
	//
	// Creative rotation weights are only valid when creative rotation type is set to
	// {@link CreativeRotationType#MANUAL}.
	//
	LineItemCreativeAssociationErrorReasonReasonInvalidCreativeRotationTypeForManualWeight = "INVALID_CREATIVE_ROTATION_TYPE_FOR_MANUAL_WEIGHT"

	// LineItemCreativeAssociationErrorReasonReasonClickMacrosRequired
	//
	// The code snippet of a creative must contain a click macro
	// (%%CLICK_URL_ESC%% or %%CLICK_URL_UNESC%%).
	//
	LineItemCreativeAssociationErrorReasonReasonClickMacrosRequired = "CLICK_MACROS_REQUIRED"

	// LineItemCreativeAssociationErrorReasonReasonViewMacrosNotAllowed
	//
	// The code snippet of a creative must not contain a view macro
	// (%%VIEW_URL_ESC%% or %%VIEW_URL_UNESC%%).
	//
	LineItemCreativeAssociationErrorReasonReasonViewMacrosNotAllowed = "VIEW_MACROS_NOT_ALLOWED"

	// LineItemCreativeAssociationErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LineItemCreativeAssociationErrorReasonReasonUnknown = "UNKNOWN"
)

// LineItemDiscountType
//
// Describes the possible discount services on the cost of booking a
// {@link LineItem}.
type LineItemDiscountType string

const (

	// LineItemDiscountTypeAbsoluteValue
	//
	// An absolute value will be discounted from the line item's cost.
	//
	LineItemDiscountTypeAbsoluteValue LineItemDiscountType = "ABSOLUTE_VALUE"

	// LineItemDiscountTypePercentage
	//
	// A percentage of the cost will be applied as discount for booking the line
	// item.
	//
	LineItemDiscountTypePercentage LineItemDiscountType = "PERCENTAGE"
)

// LineItemErrorReasonReason
//
// The reasons for the target error.
const (

	// LineItemErrorReasonReasonAlreadyStarted
	//
	// Some changes may not be allowed because a line item has already started.
	//
	LineItemErrorReasonReasonAlreadyStarted = "ALREADY_STARTED"

	// LineItemErrorReasonReasonUpdateReservationNotAllowed
	//
	// Update reservation is not allowed because a line item has
	// already started, users must pause the line item first.
	//
	LineItemErrorReasonReasonUpdateReservationNotAllowed = "UPDATE_RESERVATION_NOT_ALLOWED"

	// LineItemErrorReasonReasonAllRoadblockNotAllowed
	//
	// Roadblocking to display all creatives is not allowed.
	//
	LineItemErrorReasonReasonAllRoadblockNotAllowed = "ALL_ROADBLOCK_NOT_ALLOWED"

	// LineItemErrorReasonReasonAllCompanionDeliveryNotAllowed
	//
	// Companion delivery to display all creatives is not allowed.
	//
	LineItemErrorReasonReasonAllCompanionDeliveryNotAllowed = "ALL_COMPANION_DELIVERY_NOT_ALLOWED"

	// LineItemErrorReasonReasonCreativeSetRoadblockNotAllowed
	//
	// Roadblocking to display all master and companion creative set is not allowed.
	//
	LineItemErrorReasonReasonCreativeSetRoadblockNotAllowed = "CREATIVE_SET_ROADBLOCK_NOT_ALLOWED"

	// LineItemErrorReasonReasonFractionalPercentageNotAllowed
	//
	// Fractional percentage is not allowed.
	//
	LineItemErrorReasonReasonFractionalPercentageNotAllowed = "FRACTIONAL_PERCENTAGE_NOT_ALLOWED"

	// LineItemErrorReasonReasonDiscountNotAllowed
	//
	// For certain LineItem configurations discounts are not allowed.
	//
	LineItemErrorReasonReasonDiscountNotAllowed = "DISCOUNT_NOT_ALLOWED"

	// LineItemErrorReasonReasonUpdateCanceledLineItemNotAllowed
	//
	// Updating a canceled line item is not allowed.
	//
	LineItemErrorReasonReasonUpdateCanceledLineItemNotAllowed = "UPDATE_CANCELED_LINE_ITEM_NOT_ALLOWED"

	// LineItemErrorReasonReasonUpdatePendingApprovalLineItemNotAllowed
	//
	// Updating a pending approval line item is not allowed.
	//
	LineItemErrorReasonReasonUpdatePendingApprovalLineItemNotAllowed = "UPDATE_PENDING_APPROVAL_LINE_ITEM_NOT_ALLOWED"

	// LineItemErrorReasonReasonUpdateArchivedLineItemNotAllowed
	//
	// Updating an archived line item is not allowed.
	//
	LineItemErrorReasonReasonUpdateArchivedLineItemNotAllowed = "UPDATE_ARCHIVED_LINE_ITEM_NOT_ALLOWED"

	// LineItemErrorReasonReasonCreateOrUpdateLegacyDfpLineItemTypeNotAllowed
	//
	// Create or update legacy dfp line item type is not allowed.
	//
	LineItemErrorReasonReasonCreateOrUpdateLegacyDfpLineItemTypeNotAllowed = "CREATE_OR_UPDATE_LEGACY_DFP_LINE_ITEM_TYPE_NOT_ALLOWED"

	// LineItemErrorReasonReasonCopyLineItemFromDifferentCompanyNotAllowed
	//
	// Copying line item from different company (advertiser)
	// to the same order is not allowed.
	//
	LineItemErrorReasonReasonCopyLineItemFromDifferentCompanyNotAllowed = "COPY_LINE_ITEM_FROM_DIFFERENT_COMPANY_NOT_ALLOWED"

	// LineItemErrorReasonReasonInvalidSizeForPlatform
	//
	// The size is invalid for the specified platform.
	//
	LineItemErrorReasonReasonInvalidSizeForPlatform = "INVALID_SIZE_FOR_PLATFORM"

	// LineItemErrorReasonReasonInvalidLineItemTypeForPlatform
	//
	// The line item type is invalid for the specified platform.
	//
	LineItemErrorReasonReasonInvalidLineItemTypeForPlatform = "INVALID_LINE_ITEM_TYPE_FOR_PLATFORM"

	// LineItemErrorReasonReasonInvalidWebPropertyForPlatform
	//
	// The web property cannot be served on the specified platform.
	//
	LineItemErrorReasonReasonInvalidWebPropertyForPlatform = "INVALID_WEB_PROPERTY_FOR_PLATFORM"

	// LineItemErrorReasonReasonInvalidWebPropertyForEnvironment
	//
	// The web property cannot be served on the specified environment.
	//
	LineItemErrorReasonReasonInvalidWebPropertyForEnvironment = "INVALID_WEB_PROPERTY_FOR_ENVIRONMENT"

	// LineItemErrorReasonReasonAfmaBackfillNotAllowed
	//
	// AFMA backfill not supported.
	//
	LineItemErrorReasonReasonAfmaBackfillNotAllowed = "AFMA_BACKFILL_NOT_ALLOWED"

	// LineItemErrorReasonReasonUpdateEnvironmentTypeNotAllowed
	//
	// Environment type cannot change once saved.
	//
	LineItemErrorReasonReasonUpdateEnvironmentTypeNotAllowed = "UPDATE_ENVIRONMENT_TYPE_NOT_ALLOWED"

	// LineItemErrorReasonReasonCompanionsNotAllowed
	//
	// The placeholders are invalid because they contain companions,
	// but the line item does not support companions.
	//
	LineItemErrorReasonReasonCompanionsNotAllowed = "COMPANIONS_NOT_ALLOWED"

	// LineItemErrorReasonReasonRoadblocksWithNonroadblocksNotAllowed
	//
	// The placeholders are invalid because some of them are roadblocks,
	// and some are not.  Either all roadblock placeholders must contain
	// companions, or no placeholders may contain companions.  This does
	// not apply to video creative sets.
	//
	LineItemErrorReasonReasonRoadblocksWithNonroadblocksNotAllowed = "ROADBLOCKS_WITH_NONROADBLOCKS_NOT_ALLOWED"

	// LineItemErrorReasonReasonCannotUpdateToOrFromCreativeSetRoadblock
	//
	// A line item cannot be updated from having
	// {@link RoadblockingType#CREATIVE_SET} to having a different
	// RoadblockingType, or vice versa.
	//
	LineItemErrorReasonReasonCannotUpdateToOrFromCreativeSetRoadblock = "CANNOT_UPDATE_TO_OR_FROM_CREATIVE_SET_ROADBLOCK"

	// LineItemErrorReasonReasonUpdateFromBackfillLineItemTypeNotAllowed
	//
	// Can not change from a backfill line item type once creatives have been
	// assigned.
	//
	LineItemErrorReasonReasonUpdateFromBackfillLineItemTypeNotAllowed = "UPDATE_FROM_BACKFILL_LINE_ITEM_TYPE_NOT_ALLOWED"

	// LineItemErrorReasonReasonUpdateToBackfillLineItemTypeNotAllowed
	//
	// Can not change to a backfill line item type once creatives have been
	// assigned.
	//
	LineItemErrorReasonReasonUpdateToBackfillLineItemTypeNotAllowed = "UPDATE_TO_BACKFILL_LINE_ITEM_TYPE_NOT_ALLOWED"

	// LineItemErrorReasonReasonUpdateBackfillWebPropertyNotAllowed
	//
	// Can not change to backfill web property once creatives have been
	// assigned.
	//
	LineItemErrorReasonReasonUpdateBackfillWebPropertyNotAllowed = "UPDATE_BACKFILL_WEB_PROPERTY_NOT_ALLOWED"

	// LineItemErrorReasonReasonInvalidCompanionDeliveryOptionForEnvironmentType
	//
	// The companion delivery option is not valid for your environment type.
	//
	LineItemErrorReasonReasonInvalidCompanionDeliveryOptionForEnvironmentType = "INVALID_COMPANION_DELIVERY_OPTION_FOR_ENVIRONMENT_TYPE"

	// LineItemErrorReasonReasonCompanionBackfillRequiresVideo
	//
	// Companion backfill is enabled but environment type not video.
	//
	LineItemErrorReasonReasonCompanionBackfillRequiresVideo = "COMPANION_BACKFILL_REQUIRES_VIDEO"

	// LineItemErrorReasonReasonCompanionDeliveryOptionRequirePremium
	//
	// Companion delivery options require Ad Manager 360 networks.
	//
	LineItemErrorReasonReasonCompanionDeliveryOptionRequirePremium = "COMPANION_DELIVERY_OPTION_REQUIRE_PREMIUM"

	// LineItemErrorReasonReasonDuplicateMasterSizes
	//
	// The master size of placeholders have duplicates.
	//
	LineItemErrorReasonReasonDuplicateMasterSizes = "DUPLICATE_MASTER_SIZES"

	// LineItemErrorReasonReasonInvalidPriorityForLineItemType
	//
	// The line item priority is invalid if for dynamic allocation line items
	// it is different than the default for free publishers.  When allowed,
	// Ad Manager 360 users can change the priority to any value.
	//
	LineItemErrorReasonReasonInvalidPriorityForLineItemType = "INVALID_PRIORITY_FOR_LINE_ITEM_TYPE"

	// LineItemErrorReasonReasonInvalidEnvironmentType
	//
	// The environment type is not valid.
	//
	LineItemErrorReasonReasonInvalidEnvironmentType = "INVALID_ENVIRONMENT_TYPE"

	// LineItemErrorReasonReasonInvalidEnvironmentTypeForPlatform
	//
	// The environment type is not valid for the target platform.
	//
	LineItemErrorReasonReasonInvalidEnvironmentTypeForPlatform = "INVALID_ENVIRONMENT_TYPE_FOR_PLATFORM"

	// LineItemErrorReasonReasonInvalidTypeForAutoExtension
	//
	// Only {@link LineItemType#STANDARD} line items can be auto extended.
	//
	LineItemErrorReasonReasonInvalidTypeForAutoExtension = "INVALID_TYPE_FOR_AUTO_EXTENSION"

	// LineItemErrorReasonReasonVideoInvalidRoadblocking
	//
	// Video line items cannot change the roadblocking type.
	//
	LineItemErrorReasonReasonVideoInvalidRoadblocking = "VIDEO_INVALID_ROADBLOCKING"

	// LineItemErrorReasonReasonBackfillTypeNotAllowed
	//
	// The backfill feature is not enabled according to your features.
	//
	LineItemErrorReasonReasonBackfillTypeNotAllowed = "BACKFILL_TYPE_NOT_ALLOWED"

	// LineItemErrorReasonReasonInvalidBackfillLinkType
	//
	// The web property is invalid. A line item must have an appropriate web property selected.
	//
	LineItemErrorReasonReasonInvalidBackfillLinkType = "INVALID_BACKFILL_LINK_TYPE"

	// LineItemErrorReasonReasonDifferentBackfillAccount
	//
	// All line items in a programmatic order must have web property codes from the same account.
	//
	LineItemErrorReasonReasonDifferentBackfillAccount = "DIFFERENT_BACKFILL_ACCOUNT"

	// LineItemErrorReasonReasonCompanionDeliveryOptionsNotAllowedWithBackfill
	//
	// Companion delivery options are not allowed with dynamic allocation line
	// items.
	//
	LineItemErrorReasonReasonCompanionDeliveryOptionsNotAllowedWithBackfill = "COMPANION_DELIVERY_OPTIONS_NOT_ALLOWED_WITH_BACKFILL"

	// LineItemErrorReasonReasonInvalidWebPropertyForAdxBackfill
	//
	// Dynamic allocation using the AdExchange should always use an AFC web
	// property.
	//
	LineItemErrorReasonReasonInvalidWebPropertyForAdxBackfill = "INVALID_WEB_PROPERTY_FOR_ADX_BACKFILL"

	// LineItemErrorReasonReasonInvalidCostPerUnitForBackfill
	//
	// CPM for backfill inventory must be 0.
	//
	LineItemErrorReasonReasonInvalidCostPerUnitForBackfill = "INVALID_COST_PER_UNIT_FOR_BACKFILL"

	// LineItemErrorReasonReasonInvalidSizeForEnvironment
	//
	// Aspect ratio sizes cannot be used with video line items.
	//
	LineItemErrorReasonReasonInvalidSizeForEnvironment = "INVALID_SIZE_FOR_ENVIRONMENT"

	// LineItemErrorReasonReasonTargetPlatofrmNotAllowed
	//
	// The specified target platform is not allowed.
	//
	LineItemErrorReasonReasonTargetPlatofrmNotAllowed = "TARGET_PLATOFRM_NOT_ALLOWED"

	// LineItemErrorReasonReasonInvalidLineItemCurrency
	//
	// Currency on a line item must be one of the specified network currencies.
	//
	LineItemErrorReasonReasonInvalidLineItemCurrency = "INVALID_LINE_ITEM_CURRENCY"

	// LineItemErrorReasonReasonLineItemCannotHaveMultipleCurrencies
	//
	// All money fields on a line item must specify the same currency.
	//
	LineItemErrorReasonReasonLineItemCannotHaveMultipleCurrencies = "LINE_ITEM_CANNOT_HAVE_MULTIPLE_CURRENCIES"

	// LineItemErrorReasonReasonCannotChangeCurrency
	//
	// Once a line item has moved into a a delivering state the currency cannot be changed.
	//
	LineItemErrorReasonReasonCannotChangeCurrency = "CANNOT_CHANGE_CURRENCY"

	// LineItemErrorReasonReasonInvalidLineItemDateTime
	//
	// A DateTime associated with the line item is not valid.
	//
	LineItemErrorReasonReasonInvalidLineItemDateTime = "INVALID_LINE_ITEM_DATE_TIME"

	// LineItemErrorReasonReasonInvalidCostPerUnitForCpa
	//
	// CPA {@link LineItem line items} must specify a zero cost for the
	// {@link LineItem#costPerUnit}.
	//
	LineItemErrorReasonReasonInvalidCostPerUnitForCpa = "INVALID_COST_PER_UNIT_FOR_CPA"

	// LineItemErrorReasonReasonUpdateCpaCostTypeNotAllowed
	//
	// Once a {@link LineItem} is activated its {@link LineItem#costPerUnit} cannot be updated
	// to/from CPA.
	//
	LineItemErrorReasonReasonUpdateCpaCostTypeNotAllowed = "UPDATE_CPA_COST_TYPE_NOT_ALLOWED"

	// LineItemErrorReasonReasonUpdateVcpmCostTypeNotAllowed
	//
	// Once a {@link LineItem} is activated its {@link LineItem#costPerUnit} cannot be updated
	// to/from Viewable CPM.
	//
	LineItemErrorReasonReasonUpdateVcpmCostTypeNotAllowed = "UPDATE_VCPM_COST_TYPE_NOT_ALLOWED"

	// LineItemErrorReasonReasonMasterCompanionLineItemCannotHaveVcpmCostType
	//
	// A {@link LineItem} with master/companion creative placeholders cannot have Viewable CPM
	// as its {@link LineItem#costPerUnit}.
	//
	LineItemErrorReasonReasonMasterCompanionLineItemCannotHaveVcpmCostType = "MASTER_COMPANION_LINE_ITEM_CANNOT_HAVE_VCPM_COST_TYPE"

	// LineItemErrorReasonReasonDuplicatedUnitType
	//
	// There cannot be goals with duplicated unit type among the secondary goals for a
	// {@link LineItem line items}.
	//
	LineItemErrorReasonReasonDuplicatedUnitType = "DUPLICATED_UNIT_TYPE"

	// LineItemErrorReasonReasonMultipleGoalTypeNotAllowed
	//
	// The secondary goals of a {@link LineItem line items} must have the same goal type.
	//
	LineItemErrorReasonReasonMultipleGoalTypeNotAllowed = "MULTIPLE_GOAL_TYPE_NOT_ALLOWED"

	// LineItemErrorReasonReasonInvalidUnitTypeCombinationForSecondaryGoals
	//
	// For a CPA {@link LineItem line item}, the possible combinations for secondary goals must
	// be either click-through conversion only, click-through conversion with view-through
	// conversion or total conversion only. For a Viewable CPM {@link LineItem line item} or a
	// CPM based Sponsorship {@link LineItem line item}, its secondary goal has to be
	// impression-based.
	//
	LineItemErrorReasonReasonInvalidUnitTypeCombinationForSecondaryGoals = "INVALID_UNIT_TYPE_COMBINATION_FOR_SECONDARY_GOALS"

	// LineItemErrorReasonReasonInvalidCreativeTargetingName
	//
	// One or more of the targeting names specified by a creative placeholder or line item
	// creative association were not found on the line item.
	//
	LineItemErrorReasonReasonInvalidCreativeTargetingName = "INVALID_CREATIVE_TARGETING_NAME"

	// LineItemErrorReasonReasonInvalidCreativeCustomTargetingMatchType
	//
	// Creative targeting expressions on the line item can only have custom criteria targeting
	// with {@link CustomTargetingValue.MatchType#EXACT}.
	//
	LineItemErrorReasonReasonInvalidCreativeCustomTargetingMatchType = "INVALID_CREATIVE_CUSTOM_TARGETING_MATCH_TYPE"

	// LineItemErrorReasonReasonInvalidCreativeRotationTypeWithCreativeTargeting
	//
	// Line item with creative targeting expressions cannot have creative rotation type set to
	// {@link CreativeRotationType#SEQUENTIAL}.
	//
	LineItemErrorReasonReasonInvalidCreativeRotationTypeWithCreativeTargeting = "INVALID_CREATIVE_ROTATION_TYPE_WITH_CREATIVE_TARGETING"

	// LineItemErrorReasonReasonCannotOverbookWithCreativeTargeting
	//
	// Line items cannot overbook inventory when applying creative-level targeting if the
	// originating proposal line item did not overbook inventory. Remove creative-level targeting
	// and try again.
	//
	LineItemErrorReasonReasonCannotOverbookWithCreativeTargeting = "CANNOT_OVERBOOK_WITH_CREATIVE_TARGETING"

	// LineItemErrorReasonReasonPlaceholdersDoNotMatchProposal
	//
	// For a managed line item, inventory sizes must match sizes that are set on the originating
	// proposal line item. In the case that a size is broken out by creative-level targeting,
	// the sum of the creative counts for each size must equal the expected creative count that
	// is set for that size on the originating proposal line item.
	//
	LineItemErrorReasonReasonPlaceholdersDoNotMatchProposal = "PLACEHOLDERS_DO_NOT_MATCH_PROPOSAL"

	// LineItemErrorReasonReasonUnsupportedLineItemTypeForThisApiVersion
	//
	// The line item type is not supported for this API version.
	//
	LineItemErrorReasonReasonUnsupportedLineItemTypeForThisApiVersion = "UNSUPPORTED_LINE_ITEM_TYPE_FOR_THIS_API_VERSION"

	// LineItemErrorReasonReasonNativeCreativeTemplateRequired
	//
	// Placeholders can only have native creative templates.
	//
	LineItemErrorReasonReasonNativeCreativeTemplateRequired = "NATIVE_CREATIVE_TEMPLATE_REQUIRED"

	// LineItemErrorReasonReasonCannotHaveCreativeTemplate
	//
	// Non-native placeholders cannot have creative templates.
	//
	LineItemErrorReasonReasonCannotHaveCreativeTemplate = "CANNOT_HAVE_CREATIVE_TEMPLATE"

	// LineItemErrorReasonReasonCannotIncludeNativeCreativeTemplate
	//
	// Cannot include native creative templates in the placeholders for Ad Exchange line items.
	//
	LineItemErrorReasonReasonCannotIncludeNativeCreativeTemplate = "CANNOT_INCLUDE_NATIVE_CREATIVE_TEMPLATE"

	// LineItemErrorReasonReasonCannotIncludeNativePlaceholderWithoutTemplateId
	//
	// Cannot include native placeholders without native creative templates for direct-sold line
	// items.
	//
	LineItemErrorReasonReasonCannotIncludeNativePlaceholderWithoutTemplateId = "CANNOT_INCLUDE_NATIVE_PLACEHOLDER_WITHOUT_TEMPLATE_ID"

	// LineItemErrorReasonReasonNoSizeWithDuration
	//
	// For forecasting only, error when line item has duration, but no creative sizes specified.
	//
	LineItemErrorReasonReasonNoSizeWithDuration = "NO_SIZE_WITH_DURATION"

	// LineItemErrorReasonReasonInvalidViewabilityProviderCompany
	//
	// Used when the company pointed to by the viewabilityProviderCompanyId is not of type
	// VIEWABILITY_PROVIDER.
	//
	LineItemErrorReasonReasonInvalidViewabilityProviderCompany = "INVALID_VIEWABILITY_PROVIDER_COMPANY"

	// LineItemErrorReasonReasonCannotAccessCustomPacingCurveCloudStorageBucket
	//
	// An error occurred while accessing the custom pacing curve Google Cloud Storage bucket.
	//
	LineItemErrorReasonReasonCannotAccessCustomPacingCurveCloudStorageBucket = "CANNOT_ACCESS_CUSTOM_PACING_CURVE_CLOUD_STORAGE_BUCKET"

	// LineItemErrorReasonReasonCmsMetadataLineItemEnvironmentTypeNotSupported
	//
	// CMS Metadata targeting is only supported for video line items.
	//
	LineItemErrorReasonReasonCmsMetadataLineItemEnvironmentTypeNotSupported = "CMS_METADATA_LINE_ITEM_ENVIRONMENT_TYPE_NOT_SUPPORTED"

	// LineItemErrorReasonReasonSkippableAdTypeNotAllowed
	//
	// The {@code SkippableAdType} is not allowed.
	//
	LineItemErrorReasonReasonSkippableAdTypeNotAllowed = "SKIPPABLE_AD_TYPE_NOT_ALLOWED"

	// LineItemErrorReasonReasonCustomPacingCurveStartTimeMustMatchLineItemStartTime
	//
	// Custom pacing curve start time must match the line item's start time.
	//
	LineItemErrorReasonReasonCustomPacingCurveStartTimeMustMatchLineItemStartTime = "CUSTOM_PACING_CURVE_START_TIME_MUST_MATCH_LINE_ITEM_START_TIME"

	// LineItemErrorReasonReasonCustomPacingCurveStartTimePastLineItemEndTime
	//
	// Custom pacing curve goal start time must be before line item end time.
	//
	LineItemErrorReasonReasonCustomPacingCurveStartTimePastLineItemEndTime = "CUSTOM_PACING_CURVE_START_TIME_PAST_LINE_ITEM_END_TIME"

	// LineItemErrorReasonReasonInvalidLineItemTypeForDeliveryForecastSource
	//
	// The line item type is invalid for the specified delivery forecast source.
	//
	LineItemErrorReasonReasonInvalidLineItemTypeForDeliveryForecastSource = "INVALID_LINE_ITEM_TYPE_FOR_DELIVERY_FORECAST_SOURCE"

	// LineItemErrorReasonReasonInvalidTotalCustomPacingGoalAmounts
	//
	// The sum of the custom pacing goal amounts is invalid.
	//
	LineItemErrorReasonReasonInvalidTotalCustomPacingGoalAmounts = "INVALID_TOTAL_CUSTOM_PACING_GOAL_AMOUNTS"

	// LineItemErrorReasonReasonCopyLineItemWithCustomPacingCurveFullyInPastNotAllowed
	//
	// Copying line items with custom pacing curves that are totally in the past is not allowed.
	//
	LineItemErrorReasonReasonCopyLineItemWithCustomPacingCurveFullyInPastNotAllowed = "COPY_LINE_ITEM_WITH_CUSTOM_PACING_CURVE_FULLY_IN_PAST_NOT_ALLOWED"

	// LineItemErrorReasonReasonLastCustomPacingGoalAmountCannotBeZero
	//
	// The last custom pacing goal cannot be zero.
	//
	LineItemErrorReasonReasonLastCustomPacingGoalAmountCannotBeZero = "LAST_CUSTOM_PACING_GOAL_AMOUNT_CANNOT_BE_ZERO"

	// LineItemErrorReasonReasonGrpPacedLineItemCannotHaveAbsoluteCustomPacingCurveGoals
	//
	// GRP paced line items cannot have absolute custom pacing curve goals.
	//
	LineItemErrorReasonReasonGrpPacedLineItemCannotHaveAbsoluteCustomPacingCurveGoals = "GRP_PACED_LINE_ITEM_CANNOT_HAVE_ABSOLUTE_CUSTOM_PACING_CURVE_GOALS"

	// LineItemErrorReasonReasonInvalidMaxVideoCreativeDuration
	//
	// {@link LineItem line item} has invalid video creative duration.
	//
	LineItemErrorReasonReasonInvalidMaxVideoCreativeDuration = "INVALID_MAX_VIDEO_CREATIVE_DURATION"

	// LineItemErrorReasonReasonInvalidNativeSize
	//
	// Native size services must by 1x1.
	//
	LineItemErrorReasonReasonInvalidNativeSize = "INVALID_NATIVE_SIZE"

	// LineItemErrorReasonReasonInvalidTargetedRequestPlatformForWebPropertyCode
	//
	// For AdExchange Line Items, the targeted request platform must match the syndication type of
	// the web property code.
	//
	LineItemErrorReasonReasonInvalidTargetedRequestPlatformForWebPropertyCode = "INVALID_TARGETED_REQUEST_PLATFORM_FOR_WEB_PROPERTY_CODE"

	// LineItemErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LineItemErrorReasonReasonUnknown = "UNKNOWN"
)

// LineItemFlightDateErrorReasonReason
//
// The reasons for the target error.
const (

	// LineItemFlightDateErrorReasonReasonStartDateTimeIsInPast
	LineItemFlightDateErrorReasonReasonStartDateTimeIsInPast = "START_DATE_TIME_IS_IN_PAST"

	// LineItemFlightDateErrorReasonReasonEndDateTimeIsInPast
	LineItemFlightDateErrorReasonReasonEndDateTimeIsInPast = "END_DATE_TIME_IS_IN_PAST"

	// LineItemFlightDateErrorReasonReasonEndDateTimeNotAfterStartTime
	LineItemFlightDateErrorReasonReasonEndDateTimeNotAfterStartTime = "END_DATE_TIME_NOT_AFTER_START_TIME"

	// LineItemFlightDateErrorReasonReasonEndDateTimeTooLate
	LineItemFlightDateErrorReasonReasonEndDateTimeTooLate = "END_DATE_TIME_TOO_LATE"

	// LineItemFlightDateErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LineItemFlightDateErrorReasonReasonUnknown = "UNKNOWN"
)

// LineItemOperationErrorReasonReason
//
// The reasons for the target error.
const (

	// LineItemOperationErrorReasonReasonNotAllowed
	//
	// The operation is not allowed due to lack of permissions.
	//
	LineItemOperationErrorReasonReasonNotAllowed = "NOT_ALLOWED"

	// LineItemOperationErrorReasonReasonNotApplicable
	//
	// The operation is not applicable for the current state of the
	// {@link LineItem}.
	//
	LineItemOperationErrorReasonReasonNotApplicable = "NOT_APPLICABLE"

	// LineItemOperationErrorReasonReasonHasCompleted
	//
	// The {@link LineItem} is completed. A {@link LineItemAction} cannot
	// be applied to a line item that is completed.
	//
	LineItemOperationErrorReasonReasonHasCompleted = "HAS_COMPLETED"

	// LineItemOperationErrorReasonReasonHasNoActiveCreatives
	//
	// The {@link LineItem} has no active creatives. A line item cannot be
	// activated with no active creatives.
	//
	LineItemOperationErrorReasonReasonHasNoActiveCreatives = "HAS_NO_ACTIVE_CREATIVES"

	// LineItemOperationErrorReasonReasonCannotActivateLegacyDfpLineItem
	//
	// A {@link LineItem} of type {@link LineItemType#LEGACY_DFP} cannot be
	// Activated.
	//
	LineItemOperationErrorReasonReasonCannotActivateLegacyDfpLineItem = "CANNOT_ACTIVATE_LEGACY_DFP_LINE_ITEM"

	// LineItemOperationErrorReasonReasonCannotActivateUnconfiguredLineItem
	//
	// A {@link LineItem} with publisher creative source cannot be activated if the corresponding
	// deal is not yet configured by the buyer.
	//
	LineItemOperationErrorReasonReasonCannotActivateUnconfiguredLineItem = "CANNOT_ACTIVATE_UNCONFIGURED_LINE_ITEM"

	// LineItemOperationErrorReasonReasonCannotDeleteDeliveredLineItem
	//
	// Deleting an {@link LineItem} that has delivered is not allowed
	//
	LineItemOperationErrorReasonReasonCannotDeleteDeliveredLineItem = "CANNOT_DELETE_DELIVERED_LINE_ITEM"

	// LineItemOperationErrorReasonReasonCannotReserveCompanyCreditStatusNotActive
	//
	// Reservation cannot be made for line item because the
	// {@link LineItem#advertiserId} it is associated with has
	// {@link Company#creditStatus} that is not {@code ACTIVE}
	// or {@code ON_HOLD}.
	//
	LineItemOperationErrorReasonReasonCannotReserveCompanyCreditStatusNotActive = "CANNOT_RESERVE_COMPANY_CREDIT_STATUS_NOT_ACTIVE"

	// LineItemOperationErrorReasonReasonCannotActivateInvalidCompanyCreditStatus
	//
	// Cannot activate line item  because the {@link LineItem#advertiserId}
	// it is associated with has {@link Company#creditStatus} that is not
	// {@code ACTIVE}, {@code INACTIVE}, or {@code ON_HOLD}.
	//
	LineItemOperationErrorReasonReasonCannotActivateInvalidCompanyCreditStatus = "CANNOT_ACTIVATE_INVALID_COMPANY_CREDIT_STATUS"

	// LineItemOperationErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LineItemOperationErrorReasonReasonUnknown = "UNKNOWN"
)

// LineItemSummaryReservationStatusType
//
// Specifies the reservation status of the {@link LineItem}.
type LineItemSummaryReservationStatus string

const (

	// LineItemSummaryReservationStatusTypeReserved
	//
	// Indicates that inventory has been reserved for the line item.
	//
	LineItemSummaryReservationStatusTypeReserved LineItemSummaryReservationStatus = "RESERVED"

	// LineItemSummaryReservationStatusTypeUnreserved
	//
	// Indicates that inventory has not been reserved for the line item.
	//
	LineItemSummaryReservationStatusTypeUnreserved LineItemSummaryReservationStatus = "UNRESERVED"
)

// LineItemType
//
// {@code LineItemType} indicates the priority of a {@link LineItem}, determined
// by the way in which impressions are reserved to be served for it.
type LineItemType string

const (

	// LineItemTypeSponsorship
	//
	// The type of {@link LineItem} for which a percentage of all the impressions that are being sold
	// are reserved.
	//
	LineItemTypeSponsorship LineItemType = "SPONSORSHIP"

	// LineItemTypeStandard
	//
	// The type of {@link LineItem} for which a fixed quantity of impressions or clicks are reserved.
	//
	LineItemTypeStandard LineItemType = "STANDARD"

	// LineItemTypeNetwork
	//
	// The type of {@link LineItem} most commonly used to fill a site's unsold
	// inventory if not contractually obligated to deliver a requested number of
	// impressions. Users specify the daily percentage of unsold impressions or
	// clicks when creating this line item.
	//
	LineItemTypeNetwork LineItemType = "NETWORK"

	// LineItemTypeBulk
	//
	// The type of {@link LineItem} for which a fixed quantity of impressions or
	// clicks will be delivered at a priority lower than the
	// {@link LineItemType#STANDARD} type.
	//
	LineItemTypeBulk LineItemType = "BULK"

	// LineItemTypePricePriority
	//
	// The type of {@link LineItem} most commonly used to fill a site's unsold
	// inventory if not contractually obligated to deliver a requested number of
	// impressions. Users specify the fixed quantity of unsold impressions or
	// clicks when creating this line item.
	//
	LineItemTypePricePriority LineItemType = "PRICE_PRIORITY"

	// LineItemTypeHouse
	//
	// The type of {@link LineItem} typically used for ads that promote products
	// and services chosen by the publisher. These usually do not generate revenue
	// and have the lowest delivery priority.
	//
	LineItemTypeHouse LineItemType = "HOUSE"

	// LineItemTypeLegacyDfp
	//
	// Represents a legacy {@link LineItem} that has been migrated from the DFP
	// system. Such line items cannot be created any more. Also, these line items
	// cannot be activated or resumed.
	//
	LineItemTypeLegacyDfp LineItemType = "LEGACY_DFP"

	// LineItemTypeClickTracking
	//
	// The type of {@link LineItem} used for ads that track ads being served
	// externally of Ad Manager, for example an email newsletter. The click through would
	// reference this ad, and the click would be tracked via this ad.
	//
	LineItemTypeClickTracking LineItemType = "CLICK_TRACKING"

	// LineItemTypeAdsense
	//
	// A {@link LineItem} using dynamic allocation backed by AdSense.
	//
	LineItemTypeAdsense LineItemType = "ADSENSE"

	// LineItemTypeAdExchange
	//
	// A {@link LineItem} using dynamic allocation backed by the Google Ad Exchange.
	//
	LineItemTypeAdExchange LineItemType = "AD_EXCHANGE"

	// LineItemTypeBumper
	//
	// Represents a non-monetizable video {@link LineItem} that targets one or
	// more bumper positions, which are short house video messages used by
	// publishers to separate content from ad breaks.
	//
	LineItemTypeBumper LineItemType = "BUMPER"

	// LineItemTypeAdmob
	//
	// A {@link LineItem} using dynamic allocation backed by AdMob.
	//
	LineItemTypeAdmob LineItemType = "ADMOB"

	// LineItemTypePreferredDeal
	//
	// The type of {@link LineItem} for which there are no impressions reserved, and will serve for a
	// second price bid. All {@link LineItem}s of type {@link LineItemType#PREFERRED_DEAL} should
	// be created via a {@link ProposalLineItem} with a matching  type. When creating a
	// {@link LineItem} of type {@link LineItemType#PREFERRED_DEAL}, the
	// {@link ProposalLineItem#estimatedMinimumImpressions} field is required.
	//
	LineItemTypePreferredDeal LineItemType = "PREFERRED_DEAL"

	// LineItemTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API
	// version.
	//
	LineItemTypeUnknown LineItemType = "UNKNOWN"
)

// MinuteOfHour
//
// Minutes in an hour. Currently, only 0, 15, 30, and 45 are supported. This
// field is required.
type MinuteOfHour string

const (

	// MinuteOfHourZero
	//
	// Zero minutes past hour.
	//
	MinuteOfHourZero MinuteOfHour = "ZERO"

	// MinuteOfHourFifteen
	//
	// Fifteen minutes past hour.
	//
	MinuteOfHourFifteen MinuteOfHour = "FIFTEEN"

	// MinuteOfHourThirty
	//
	// Thirty minutes past hour.
	//
	MinuteOfHourThirty MinuteOfHour = "THIRTY"

	// MinuteOfHourFortyFive
	//
	// Forty-five minutes past hour.
	//
	MinuteOfHourFortyFive MinuteOfHour = "FORTY_FIVE"
)

// MobileApplicationTargetingErrorReasonReason
//
// {@link ApiErrorReason} enum for user domain targeting error.
const (

	// MobileApplicationTargetingErrorReasonReasonCannotTargetUnlinkedApplication
	//
	// Only applications that are linked to a store entry may be targeted.
	//
	MobileApplicationTargetingErrorReasonReasonCannotTargetUnlinkedApplication = "CANNOT_TARGET_UNLINKED_APPLICATION"

	// MobileApplicationTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	MobileApplicationTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// NielsenCtvPacingType
//
// Represents the pacing computation method for impressions on connected devices for a Nielsen
// measured line item. This only applies when Nielsen measurement is enabled for connected devices.
type NielsenCtvPacingType string

const (

	// NielsenCtvPacingTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NielsenCtvPacingTypeUnknown NielsenCtvPacingType = "UNKNOWN"

	// NielsenCtvPacingTypeNone
	//
	// The value returned if Nielsen measurement is disabled for connected devices.
	//
	NielsenCtvPacingTypeNone NielsenCtvPacingType = "NONE"

	// NielsenCtvPacingTypeCoview
	//
	// Indicates that Nielsen impressions on connected devices are included, and we apply coviewing in
	// pacing.
	//
	NielsenCtvPacingTypeCoview NielsenCtvPacingType = "COVIEW"

	// NielsenCtvPacingTypeStrictCoview
	//
	// Indicates that Nielsen impressions on connected devices are included, and we apply strict
	// coviewing in pacing.
	//
	NielsenCtvPacingTypeStrictCoview NielsenCtvPacingType = "STRICT_COVIEW"
)

// NotNullErrorReasonReason
//
// The reasons for the target error.
const (

	// NotNullErrorReasonReasonArg1Null
	//
	// Assuming that a method will not have more than 3 arguments, if it does,
	// return NULL
	//
	NotNullErrorReasonReasonArg1Null = "ARG1_NULL"

	// NotNullErrorReasonReasonArg2Null
	NotNullErrorReasonReasonArg2Null = "ARG2_NULL"

	// NotNullErrorReasonReasonArg3Null
	NotNullErrorReasonReasonArg3Null = "ARG3_NULL"

	// NotNullErrorReasonReasonNull
	NotNullErrorReasonReasonNull = "NULL"

	// NotNullErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NotNullErrorReasonReasonUnknown = "UNKNOWN"
)

// NullErrorReasonReason
//
// The reasons for the validation error.
const (

	// NullErrorReasonReasonNullContent
	//
	// Specified list/container must not contain any null elements
	//
	NullErrorReasonReasonNullContent = "NULL_CONTENT"
)

// OrderActionErrorReasonReason
//
// The reasons for the target error.
const (

	// OrderActionErrorReasonReasonPermissionDenied
	//
	// The operation is not allowed due to lack of permissions.
	//
	OrderActionErrorReasonReasonPermissionDenied = "PERMISSION_DENIED"

	// OrderActionErrorReasonReasonNotApplicable
	//
	// The operation is not applicable for the current state of the
	// {@link Order}.
	//
	OrderActionErrorReasonReasonNotApplicable = "NOT_APPLICABLE"

	// OrderActionErrorReasonReasonIsArchived
	//
	// The {@link Order} is archived, an {@link OrderAction} cannot be applied
	// to an archived order.
	//
	OrderActionErrorReasonReasonIsArchived = "IS_ARCHIVED"

	// OrderActionErrorReasonReasonHasEnded
	//
	// The {@link Order} is past its end date, An {@link OrderAction} cannot
	// be applied to a order that has ended.
	//
	OrderActionErrorReasonReasonHasEnded = "HAS_ENDED"

	// OrderActionErrorReasonReasonCannotApproveWithUnreservedLineItems
	//
	// A {@link Order} cannot be approved if it contains reservable
	// {@link LineItem}s that are unreserved.
	//
	OrderActionErrorReasonReasonCannotApproveWithUnreservedLineItems = "CANNOT_APPROVE_WITH_UNRESERVED_LINE_ITEMS"

	// OrderActionErrorReasonReasonCannotDeleteOrderWithDeliveredLineitems
	//
	// Deleting an {@link Order} with delivered line items is not allowed
	//
	OrderActionErrorReasonReasonCannotDeleteOrderWithDeliveredLineitems = "CANNOT_DELETE_ORDER_WITH_DELIVERED_LINEITEMS"

	// OrderActionErrorReasonReasonCannotApproveCompanyCreditStatusNotActive
	//
	// Cannot approve because company credit status is not active.
	//
	OrderActionErrorReasonReasonCannotApproveCompanyCreditStatusNotActive = "CANNOT_APPROVE_COMPANY_CREDIT_STATUS_NOT_ACTIVE"

	// OrderActionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	OrderActionErrorReasonReasonUnknown = "UNKNOWN"
)

// OrderErrorReasonReason
//
// The reasons for the target error.
const (

	// OrderErrorReasonReasonUpdateCanceledOrderNotAllowed
	//
	// Updating a canceled order is not allowed.
	//
	OrderErrorReasonReasonUpdateCanceledOrderNotAllowed = "UPDATE_CANCELED_ORDER_NOT_ALLOWED"

	// OrderErrorReasonReasonUpdatePendingApprovalOrderNotAllowed
	//
	// Updating an order that has its approval pending is not allowed.
	//
	OrderErrorReasonReasonUpdatePendingApprovalOrderNotAllowed = "UPDATE_PENDING_APPROVAL_ORDER_NOT_ALLOWED"

	// OrderErrorReasonReasonUpdateArchivedOrderNotAllowed
	//
	// Updating an archived order is not allowed.
	//
	OrderErrorReasonReasonUpdateArchivedOrderNotAllowed = "UPDATE_ARCHIVED_ORDER_NOT_ALLOWED"

	// OrderErrorReasonReasonCannotModifyProposalId
	//
	// DSM can set the proposal ID only at the time of creation of order.
	// Setting or changing proposal ID at the time of order update is not
	// allowed.
	//
	OrderErrorReasonReasonCannotModifyProposalId = "CANNOT_MODIFY_PROPOSAL_ID"

	// OrderErrorReasonReasonPrimaryUserRequired
	//
	// Cannot have secondary user without a primary user.
	//
	OrderErrorReasonReasonPrimaryUserRequired = "PRIMARY_USER_REQUIRED"

	// OrderErrorReasonReasonPrimaryUserCannotBeSecondary
	//
	// Primary user cannot be added as a secondary user too.
	//
	OrderErrorReasonReasonPrimaryUserCannotBeSecondary = "PRIMARY_USER_CANNOT_BE_SECONDARY"

	// OrderErrorReasonReasonOrderTeamNotAssociatedWithAdvertiser
	//
	// A team associated with the order must also be associated with the
	// advertiser.
	//
	OrderErrorReasonReasonOrderTeamNotAssociatedWithAdvertiser = "ORDER_TEAM_NOT_ASSOCIATED_WITH_ADVERTISER"

	// OrderErrorReasonReasonUserNotOnOrdersTeams
	//
	// The user assigned to the order, like salesperson or trafficker, must
	// be on one of the order's teams.
	//
	OrderErrorReasonReasonUserNotOnOrdersTeams = "USER_NOT_ON_ORDERS_TEAMS"

	// OrderErrorReasonReasonAgencyNotOnOrdersTeams
	//
	// The agency assigned to the order must belong to one of the order's teams.
	//
	OrderErrorReasonReasonAgencyNotOnOrdersTeams = "AGENCY_NOT_ON_ORDERS_TEAMS"

	// OrderErrorReasonReasonInvalidFieldsSetForNonProgrammaticOrder
	//
	// Programmatic info fields should not be set for a non-programmatic order.
	//
	OrderErrorReasonReasonInvalidFieldsSetForNonProgrammaticOrder = "INVALID_FIELDS_SET_FOR_NON_PROGRAMMATIC_ORDER"

	// OrderErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	OrderErrorReasonReasonUnknown = "UNKNOWN"
)

// PacingDeviceCategorizationType
//
// Represents whose device categorization to use on Nielsen measured line item with auto-pacing
// enabled.
type PacingDeviceCategorizationType string

const (

	// PacingDeviceCategorizationTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PacingDeviceCategorizationTypeUnknown PacingDeviceCategorizationType = "UNKNOWN"

	// PacingDeviceCategorizationTypeGoogle
	//
	// Use Google's device categorization in auto-pacing.
	//
	PacingDeviceCategorizationTypeGoogle PacingDeviceCategorizationType = "GOOGLE"

	// PacingDeviceCategorizationTypeNielsen
	//
	// Use Nielsen device categorization in auto-pacing
	//
	PacingDeviceCategorizationTypeNielsen PacingDeviceCategorizationType = "NIELSEN"
)

// ParseErrorReasonReason
//
// The reasons for the target error.
const (

	// ParseErrorReasonReasonUnparsable
	//
	// Indicates an error in parsing an attribute.
	//
	ParseErrorReasonReasonUnparsable = "UNPARSABLE"

	// ParseErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ParseErrorReasonReasonUnknown = "UNKNOWN"
)

// PermissionErrorReasonReason
//
// Describes reasons for permission errors.
const (

	// PermissionErrorReasonReasonPermissionDenied
	//
	// User does not have the required permission for the request.
	//
	PermissionErrorReasonReasonPermissionDenied = "PERMISSION_DENIED"

	// PermissionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PermissionErrorReasonReasonUnknown = "UNKNOWN"
)

// PrecisionErrorReasonReason
//
// Describes reasons for precision errors.
const (

	// PrecisionErrorReasonReasonWrongPrecision
	//
	// The lowest N digits of the number must be zero.
	//
	PrecisionErrorReasonReasonWrongPrecision = "WRONG_PRECISION"

	// PrecisionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PrecisionErrorReasonReasonUnknown = "UNKNOWN"
)

// ProgrammaticCreativeSource
//
// Types of programmatic creative sources.
type ProgrammaticCreativeSource string

const (

	// ProgrammaticCreativeSourcePublisher
	//
	// Indicates that the programmatic line item is associated with creatives provided by
	// the publisher.
	//
	ProgrammaticCreativeSourcePublisher ProgrammaticCreativeSource = "PUBLISHER"

	// ProgrammaticCreativeSourceAdvertiser
	//
	// Indicates that the programmatic line item is associated with creatives provided by
	// the advertiser.
	//
	ProgrammaticCreativeSourceAdvertiser ProgrammaticCreativeSource = "ADVERTISER"

	// ProgrammaticCreativeSourceUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProgrammaticCreativeSourceUnknown ProgrammaticCreativeSource = "UNKNOWN"
)

// ProgrammaticErrorReasonReason
//
// Possible error reasons for a programmatic error.
const (

	// ProgrammaticErrorReasonReasonAudienceExtensionNotSupported
	//
	// Audience extension is not supported by programmatic line items.
	//
	ProgrammaticErrorReasonReasonAudienceExtensionNotSupported = "AUDIENCE_EXTENSION_NOT_SUPPORTED"

	// ProgrammaticErrorReasonReasonAutoExtensionDaysNotSupported
	//
	// Auto extension days is not supported by programmatic line items.
	//
	ProgrammaticErrorReasonReasonAutoExtensionDaysNotSupported = "AUTO_EXTENSION_DAYS_NOT_SUPPORTED"

	// ProgrammaticErrorReasonReasonVideoNotSupported
	//
	// Video is currently not supported.
	//
	ProgrammaticErrorReasonReasonVideoNotSupported = "VIDEO_NOT_SUPPORTED"

	// ProgrammaticErrorReasonReasonRoadblockingNotSupported
	//
	// Roadblocking is not supported by programmatic line items.
	//
	ProgrammaticErrorReasonReasonRoadblockingNotSupported = "ROADBLOCKING_NOT_SUPPORTED"

	// ProgrammaticErrorReasonReasonInvalidCreativeRotation
	//
	// Programmatic line items do not support {@link CreativeRotationType#SEQUENTIAL}.
	//
	ProgrammaticErrorReasonReasonInvalidCreativeRotation = "INVALID_CREATIVE_ROTATION"

	// ProgrammaticErrorReasonReasonInvalidLineItemType
	//
	// Programmatic line items only support {@link LineItemType#STANDARD} and
	// {@link LineItemType#SPONSORSHIP} if the relevant feature is on.
	//
	ProgrammaticErrorReasonReasonInvalidLineItemType = "INVALID_LINE_ITEM_TYPE"

	// ProgrammaticErrorReasonReasonInvalidCostType
	//
	// Programmatic line items only support {@link CostType#CPM}.
	//
	ProgrammaticErrorReasonReasonInvalidCostType = "INVALID_COST_TYPE"

	// ProgrammaticErrorReasonReasonSizeNotSupported
	//
	// Programmatic line items only support a creative size that is supported by AdX.
	// The list of supported sizes is maintained based on the list published in the help docs:
	// <a href="https://support.google.com/adxseller/answer/1100453">
	// https://support.google.com/adxseller/answer/1100453</a>
	//
	ProgrammaticErrorReasonReasonSizeNotSupported = "SIZE_NOT_SUPPORTED"

	// ProgrammaticErrorReasonReasonZeroCostPerUnitNotSupported
	//
	// Zero cost per unit is not supported by programmatic line items.
	//
	ProgrammaticErrorReasonReasonZeroCostPerUnitNotSupported = "ZERO_COST_PER_UNIT_NOT_SUPPORTED"

	// ProgrammaticErrorReasonReasonCannotUpdateFieldForApprovedLineItems
	//
	// Some fields cannot be updated on approved line items.
	//
	ProgrammaticErrorReasonReasonCannotUpdateFieldForApprovedLineItems = "CANNOT_UPDATE_FIELD_FOR_APPROVED_LINE_ITEMS"

	// ProgrammaticErrorReasonReasonCannotCreateLineItemForApprovedOrder
	//
	// Creating a new line item in an approved order is not allowed.
	//
	ProgrammaticErrorReasonReasonCannotCreateLineItemForApprovedOrder = "CANNOT_CREATE_LINE_ITEM_FOR_APPROVED_ORDER"

	// ProgrammaticErrorReasonReasonCannotUpdateBackfillWebPropertyForApprovedLineItems
	//
	// Cannot change backfill web property for a programmatic line item whose order has been
	// approved.
	//
	ProgrammaticErrorReasonReasonCannotUpdateBackfillWebPropertyForApprovedLineItems = "CANNOT_UPDATE_BACKFILL_WEB_PROPERTY_FOR_APPROVED_LINE_ITEMS"

	// ProgrammaticErrorReasonReasonCostPerUnitTooLow
	//
	// Cost per unit is too low. It has to be at least 0.005 USD.
	//
	ProgrammaticErrorReasonReasonCostPerUnitTooLow = "COST_PER_UNIT_TOO_LOW"

	// ProgrammaticErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProgrammaticErrorReasonReasonUnknown = "UNKNOWN"
)

// PublisherQueryLanguageContextErrorReasonReason
//
// The reasons for the target error.
const (

	// PublisherQueryLanguageContextErrorReasonReasonUnexecutable
	//
	// Indicates that there was an error executing the PQL.
	//
	PublisherQueryLanguageContextErrorReasonReasonUnexecutable = "UNEXECUTABLE"

	// PublisherQueryLanguageContextErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageContextErrorReasonReasonUnknown = "UNKNOWN"
)

// PublisherQueryLanguageSyntaxErrorReasonReason
//
// The reasons for the target error.
const (

	// PublisherQueryLanguageSyntaxErrorReasonReasonUnparsable
	//
	// Indicates that there was a PQL syntax error.
	//
	PublisherQueryLanguageSyntaxErrorReasonReasonUnparsable = "UNPARSABLE"

	// PublisherQueryLanguageSyntaxErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageSyntaxErrorReasonReasonUnknown = "UNKNOWN"
)

// QuotaErrorReasonReason
const (

	// QuotaErrorReasonReasonExceededQuota
	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>Another way to mitigate this error is to limit requests to 8 per second for Ad Manager
	// 360 accounts, or 2 per second for Ad Manager accounts. Once again
	// this does not guarantee that every request will succeed, but may help
	// reduce the number of times you receive this error.
	//
	QuotaErrorReasonReasonExceededQuota = "EXCEEDED_QUOTA"

	// QuotaErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	QuotaErrorReasonReasonUnknown = "UNKNOWN"

	// QuotaErrorReasonReasonReportJobLimit
	//
	// This user has exceeded the allowed number of new report requests per hour
	// (this includes both reports run via the UI and reports
	// run via {@link ReportService#runReportJob}).
	// The recommended approach to handle this error is to wait about 10 minutes
	// and then retry the request. Note that this does not guarantee the request
	// will succeed. If it fails again, try increasing the wait time.
	// <p>Another way to mitigate this error is to limit the number of new report
	// requests to 250 per hour per user. Once again, this does not guarantee that
	// every request will succeed, but may help reduce the number of times you
	// receive this error.
	//
	QuotaErrorReasonReasonReportJobLimit = "REPORT_JOB_LIMIT"

	// QuotaErrorReasonReasonSegmentPopulationLimit
	//
	// This network has exceeded the allowed number of identifiers uploaded within a 24 hour period.
	// The recommended approach to handle this error is to wait 30 minutes and then retry the
	// request. Note that this does not guarantee the request will succeed. If it fails again, try
	// increasing the wait time.
	//
	QuotaErrorReasonReasonSegmentPopulationLimit = "SEGMENT_POPULATION_LIMIT"
)

// RangeErrorReasonReason
const (

	// RangeErrorReasonReasonTooHigh
	RangeErrorReasonReasonTooHigh = "TOO_HIGH"

	// RangeErrorReasonReasonTooLow
	RangeErrorReasonReasonTooLow = "TOO_LOW"

	// RangeErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RangeErrorReasonReasonUnknown = "UNKNOWN"
)

// RegExErrorReasonReason
//
// The reasons for the target error.
const (

	// RegExErrorReasonReasonInvalid
	//
	// Invalid value found.
	//
	RegExErrorReasonReasonInvalid = "INVALID"

	// RegExErrorReasonReasonNull
	//
	// Null value found.
	//
	RegExErrorReasonReasonNull = "NULL"

	// RegExErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RegExErrorReasonReasonUnknown = "UNKNOWN"
)

// RequestPlatform
//
// Represents the platform which requests and renders the ad.
type RequestPlatform string

const (

	// RequestPlatformUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequestPlatformUnknown RequestPlatform = "UNKNOWN"

	// RequestPlatformBrowser
	//
	// Represents a request made from a web browser. This includes both desktop and mobile web.
	//
	RequestPlatformBrowser RequestPlatform = "BROWSER"

	// RequestPlatformMobileApp
	//
	// Represents a request made from a mobile application. This includes mobile app interstitial and
	// rewarded video requests.
	//
	RequestPlatformMobileApp RequestPlatform = "MOBILE_APP"

	// RequestPlatformVideoPlayer
	//
	// Represents a request made from a video player that is playing publisher content. This includes
	// video players embedded in web pages and mobile applications, and connected TV screens.
	//
	RequestPlatformVideoPlayer RequestPlatform = "VIDEO_PLAYER"
)

// RequestPlatformTargetingErrorReasonReason
//
// {@link ApiErrorReason} enum for the request platform targeting error.
const (

	// RequestPlatformTargetingErrorReasonReasonRequestPlatformTypeNotSupportedByLineItemType
	//
	// The line item type does not support the targeted request platform type.
	//
	RequestPlatformTargetingErrorReasonReasonRequestPlatformTypeNotSupportedByLineItemType = "REQUEST_PLATFORM_TYPE_NOT_SUPPORTED_BY_LINE_ITEM_TYPE"

	// RequestPlatformTargetingErrorReasonReasonRequestPlatformTypeNotSupportedByEnvironmentType
	//
	// The line item environment type does not support the targeted request platform type.
	//
	RequestPlatformTargetingErrorReasonReasonRequestPlatformTypeNotSupportedByEnvironmentType = "REQUEST_PLATFORM_TYPE_NOT_SUPPORTED_BY_ENVIRONMENT_TYPE"

	// RequestPlatformTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequestPlatformTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// RequiredCollectionErrorReasonReason
const (

	// RequiredCollectionErrorReasonReasonRequired
	//
	// A required collection is missing.
	//
	RequiredCollectionErrorReasonReasonRequired = "REQUIRED"

	// RequiredCollectionErrorReasonReasonTooLarge
	//
	// Collection size is too large.
	//
	RequiredCollectionErrorReasonReasonTooLarge = "TOO_LARGE"

	// RequiredCollectionErrorReasonReasonTooSmall
	//
	// Collection size is too small.
	//
	RequiredCollectionErrorReasonReasonTooSmall = "TOO_SMALL"

	// RequiredCollectionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredCollectionErrorReasonReasonUnknown = "UNKNOWN"
)

// RequiredErrorReasonReason
//
// The reasons for the target error.
const (

	// RequiredErrorReasonReasonRequired
	//
	// Missing required field.
	//
	RequiredErrorReasonReasonRequired = "REQUIRED"
)

// RequiredNumberErrorReasonReason
//
// Describes reasons for a number to be invalid.
const (

	// RequiredNumberErrorReasonReasonRequired
	RequiredNumberErrorReasonReasonRequired = "REQUIRED"

	// RequiredNumberErrorReasonReasonTooLarge
	RequiredNumberErrorReasonReasonTooLarge = "TOO_LARGE"

	// RequiredNumberErrorReasonReasonTooSmall
	RequiredNumberErrorReasonReasonTooSmall = "TOO_SMALL"

	// RequiredNumberErrorReasonReasonTooLargeWithDetails
	RequiredNumberErrorReasonReasonTooLargeWithDetails = "TOO_LARGE_WITH_DETAILS"

	// RequiredNumberErrorReasonReasonTooSmallWithDetails
	RequiredNumberErrorReasonReasonTooSmallWithDetails = "TOO_SMALL_WITH_DETAILS"

	// RequiredNumberErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredNumberErrorReasonReasonUnknown = "UNKNOWN"
)

// RequiredSizeErrorReasonReason
const (

	// RequiredSizeErrorReasonReasonRequired
	//
	// {@link Creative#size} or {@link LineItem#creativePlaceholders} size is
	// missing.
	//
	RequiredSizeErrorReasonReasonRequired = "REQUIRED"

	// RequiredSizeErrorReasonReasonNotAllowed
	//
	// {@link LineItemCreativeAssociation#sizes} must be a subset of
	// {@link LineItem#creativePlaceholders} sizes.
	//
	RequiredSizeErrorReasonReasonNotAllowed = "NOT_ALLOWED"

	// RequiredSizeErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredSizeErrorReasonReasonUnknown = "UNKNOWN"
)

// ReservationDetailsErrorReasonReason
//
// The reasons for the target error.
const (

	// ReservationDetailsErrorReasonReasonUnlimitedUnitsBoughtNotAllowed
	//
	// There is no limit on the number of ads delivered for a line item when you
	// set {@link LineItem#duration} to be
	// {@link LineItemSummary.Duration#NONE}. This can only be set for line
	// items of type {@link LineItemType#PRICE_PRIORITY}.
	//
	ReservationDetailsErrorReasonReasonUnlimitedUnitsBoughtNotAllowed = "UNLIMITED_UNITS_BOUGHT_NOT_ALLOWED"

	// ReservationDetailsErrorReasonReasonUnlimitedEndDateTimeNotAllowed
	//
	// {@link LineItem#unlimitedEndDateTime} can be set to true for only
	// line items of type {@link LineItemType#SPONSORSHIP},
	// {@link LineItemType#NETWORK}, {@link LineItemType#PRICE_PRIORITY} and
	// {@link LineItemType#HOUSE}.
	//
	ReservationDetailsErrorReasonReasonUnlimitedEndDateTimeNotAllowed = "UNLIMITED_END_DATE_TIME_NOT_ALLOWED"

	// ReservationDetailsErrorReasonReasonPercentageUnitsBoughtTooHigh
	//
	// When {@link LineItem#lineItemType} is
	// {@link LineItemType#SPONSORSHIP}, then
	// {@link LineItem#unitsBought} represents the percentage of
	// available impressions reserved. That value cannot exceed 100.
	//
	ReservationDetailsErrorReasonReasonPercentageUnitsBoughtTooHigh = "PERCENTAGE_UNITS_BOUGHT_TOO_HIGH"

	// ReservationDetailsErrorReasonReasonDurationNotAllowed
	//
	// The line item type does not support the specified duration. See
	// {@link LineItemSummary.Duration} for allowed values.
	//
	ReservationDetailsErrorReasonReasonDurationNotAllowed = "DURATION_NOT_ALLOWED"

	// ReservationDetailsErrorReasonReasonUnitTypeNotAllowed
	//
	// The {@link LineItem#unitType} is not allowed for the given
	// {@link LineItem#lineItemType}. See {@link UnitType} for allowed
	// values.
	//
	ReservationDetailsErrorReasonReasonUnitTypeNotAllowed = "UNIT_TYPE_NOT_ALLOWED"

	// ReservationDetailsErrorReasonReasonCostTypeNotAllowed
	//
	// The {@link LineItem#costType} is not allowed for the
	// {@link LineItem#lineItemType}. See {@link CostType} for allowed
	// values.
	//
	ReservationDetailsErrorReasonReasonCostTypeNotAllowed = "COST_TYPE_NOT_ALLOWED"

	// ReservationDetailsErrorReasonReasonCostTypeUnitTypeMismatchNotAllowed
	//
	// When {@link LineItem#costType} is {@link CostType#CPM},
	// {@link LineItem#unitType} must be {@link UnitType#IMPRESSIONS}
	// and when {@link LineItem#costType} is {@link CostType#CPC},
	// {@link LineItem#unitType} must be {@link UnitType#CLICKS}.
	//
	ReservationDetailsErrorReasonReasonCostTypeUnitTypeMismatchNotAllowed = "COST_TYPE_UNIT_TYPE_MISMATCH_NOT_ALLOWED"

	// ReservationDetailsErrorReasonReasonLineItemTypeNotAllowed
	//
	// Inventory cannot be reserved for line items which are not of type
	// {@link LineItemType#SPONSORSHIP} or {@link LineItemType#STANDARD}.
	//
	ReservationDetailsErrorReasonReasonLineItemTypeNotAllowed = "LINE_ITEM_TYPE_NOT_ALLOWED"

	// ReservationDetailsErrorReasonReasonNetworkRemnantOrderCannotUpdateLineitemType
	//
	// Network remnant line items cannot be changed to other line item services once delivery begins.
	// This restriction does not apply to any new line items created in Ad Manager.
	//
	ReservationDetailsErrorReasonReasonNetworkRemnantOrderCannotUpdateLineitemType = "NETWORK_REMNANT_ORDER_CANNOT_UPDATE_LINEITEM_TYPE"

	// ReservationDetailsErrorReasonReasonBackfillWebpropertyCodeNotAllowed
	//
	// A dynamic allocation web property can only be set on a line item of type
	// AdSense or Ad Exchange.
	//
	ReservationDetailsErrorReasonReasonBackfillWebpropertyCodeNotAllowed = "BACKFILL_WEBPROPERTY_CODE_NOT_ALLOWED"

	// ReservationDetailsErrorReasonReasonCpaDeprecated
	//
	// CPA {@link LineItem}s can't have end dates older than February 22, 2024.
	//
	ReservationDetailsErrorReasonReasonCpaDeprecated = "CPA_DEPRECATED"

	// ReservationDetailsErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ReservationDetailsErrorReasonReasonUnknown = "UNKNOWN"
)

// RoadblockingType
//
// Describes the roadblocking services.
type RoadblockingType string

const (

	// RoadblockingTypeOnlyOne
	//
	// Only one creative from a line item can serve at a time.
	//
	RoadblockingTypeOnlyOne RoadblockingType = "ONLY_ONE"

	// RoadblockingTypeOneOrMore
	//
	// Any number of creatives from a line item can serve together at a time.
	//
	RoadblockingTypeOneOrMore RoadblockingType = "ONE_OR_MORE"

	// RoadblockingTypeAsManyAsPossible
	//
	// As many creatives from a line item as can fit on a page will serve. This
	// could mean anywhere from one to all of a line item's creatives given the
	// size constraints of ad slots on a page.
	//
	RoadblockingTypeAsManyAsPossible RoadblockingType = "AS_MANY_AS_POSSIBLE"

	// RoadblockingTypeAllRoadblock
	//
	// All or none of the creatives from a line item will serve. This option will only work if
	// served to a GPT tag using SRA (single request architecture mode).
	//
	RoadblockingTypeAllRoadblock RoadblockingType = "ALL_ROADBLOCK"

	// RoadblockingTypeCreativeSet
	//
	// A master/companion {@link CreativeSet} roadblocking type.
	// A {@link LineItem#creativePlaceholders} must be set accordingly.
	//
	RoadblockingTypeCreativeSet RoadblockingType = "CREATIVE_SET"
)

// AudienceSegmentErrorReasonReason
//
// Reason of the given {@link AudienceSegmentError}.
const (

	// AudienceSegmentErrorReasonReasonFirstPartyAudienceSegmentNotSupported
	//
	// First party audience segment is not supported.
	//
	AudienceSegmentErrorReasonReasonFirstPartyAudienceSegmentNotSupported = "FIRST_PARTY_AUDIENCE_SEGMENT_NOT_SUPPORTED"

	// AudienceSegmentErrorReasonReasonOnlyRuleBasedFirstPartyAudienceSegmentsCanBeCreated
	//
	// Only rule-based first-party audience segments can be created.
	//
	AudienceSegmentErrorReasonReasonOnlyRuleBasedFirstPartyAudienceSegmentsCanBeCreated = "ONLY_RULE_BASED_FIRST_PARTY_AUDIENCE_SEGMENTS_CAN_BE_CREATED"

	// AudienceSegmentErrorReasonReasonAudienceSegmentIdNotFound
	//
	// Audience segment for the given id is not found.
	//
	AudienceSegmentErrorReasonReasonAudienceSegmentIdNotFound = "AUDIENCE_SEGMENT_ID_NOT_FOUND"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentRule
	//
	// Audience segment rule is invalid.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentRule = "INVALID_AUDIENCE_SEGMENT_RULE"

	// AudienceSegmentErrorReasonReasonAudienceSegmentRuleTooLong
	//
	// Audience segment rule contains too many ad units and/or custom criteria.
	//
	AudienceSegmentErrorReasonReasonAudienceSegmentRuleTooLong = "AUDIENCE_SEGMENT_RULE_TOO_LONG"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentName
	//
	// Audience segment name is invalid.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentName = "INVALID_AUDIENCE_SEGMENT_NAME"

	// AudienceSegmentErrorReasonReasonDuplicateAudienceSegmentName
	//
	// Audience segment with this name already exists.
	//
	AudienceSegmentErrorReasonReasonDuplicateAudienceSegmentName = "DUPLICATE_AUDIENCE_SEGMENT_NAME"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentDescription
	//
	// Audience segment description is invalid.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentDescription = "INVALID_AUDIENCE_SEGMENT_DESCRIPTION"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentPageviews
	//
	// Audience segment pageviews value is invalid. It must be between 1 and 12.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentPageviews = "INVALID_AUDIENCE_SEGMENT_PAGEVIEWS"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentRecency
	//
	// Audience segment recency value is invalid. It must be between 1 and 90 if pageviews > 1.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentRecency = "INVALID_AUDIENCE_SEGMENT_RECENCY"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentMembershipExpiration
	//
	// Audience segment membership expiration value is invalid. It must be between 1 and 180.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentMembershipExpiration = "INVALID_AUDIENCE_SEGMENT_MEMBERSHIP_EXPIRATION"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomKeyName
	//
	// The given custom key cannot be part of audience segment rule due to unsupported characters.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomKeyName = "INVALID_AUDIENCE_SEGMENT_CUSTOM_KEY_NAME"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomValueName
	//
	// The given custom value cannot be part of audience segment rule due to unsupported characters.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomValueName = "INVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_NAME"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomValueMatchType
	//
	// Broad-match custom value cannot be part of audience segment rule.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomValueMatchType = "INVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_MATCH_TYPE"

	// AudienceSegmentErrorReasonReasonInvalidNestedFirstPartyAudienceSegment
	//
	// Audience segment rule cannot contain itself.
	//
	AudienceSegmentErrorReasonReasonInvalidNestedFirstPartyAudienceSegment = "INVALID_NESTED_FIRST_PARTY_AUDIENCE_SEGMENT"

	// AudienceSegmentErrorReasonReasonSharedSellingPartnerRootCannotBeIncluded
	//
	// Audience segment rule cannot contain shared selling inventory unit.
	//
	AudienceSegmentErrorReasonReasonSharedSellingPartnerRootCannotBeIncluded = "SHARED_SELLING_PARTNER_ROOT_CANNOT_BE_INCLUDED"

	// AudienceSegmentErrorReasonReasonInvalidNestedThirdPartyAudienceSegment
	//
	// Audience segment rule cannot contain a nested third-party segment.
	//
	AudienceSegmentErrorReasonReasonInvalidNestedThirdPartyAudienceSegment = "INVALID_NESTED_THIRD_PARTY_AUDIENCE_SEGMENT"

	// AudienceSegmentErrorReasonReasonInactiveNestedAudienceSegment
	//
	// Audience segment rule cannot contain a nested inactive segment.
	//
	AudienceSegmentErrorReasonReasonInactiveNestedAudienceSegment = "INACTIVE_NESTED_AUDIENCE_SEGMENT"

	// AudienceSegmentErrorReasonReasonAudienceSegmentGlobalLicenseError
	//
	// An error occurred when purchasing global licenses.
	//
	AudienceSegmentErrorReasonReasonAudienceSegmentGlobalLicenseError = "AUDIENCE_SEGMENT_GLOBAL_LICENSE_ERROR"

	// AudienceSegmentErrorReasonReasonSegmentViolatedPolicy
	//
	// Segment cannot be activated as it violates Google's Platform Policy.
	//
	AudienceSegmentErrorReasonReasonSegmentViolatedPolicy = "SEGMENT_VIOLATED_POLICY"

	// AudienceSegmentErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegmentErrorReasonReasonUnknown = "UNKNOWN"
)

// ServerErrorReasonReason
//
// Describes reasons for server errors
const (

	// ServerErrorReasonReasonServerError
	//
	// Indicates that an unexpected error occured.
	//
	ServerErrorReasonReasonServerError = "SERVER_ERROR"

	// ServerErrorReasonReasonServerBusy
	//
	// Indicates that the server is currently experiencing a high load. Please
	// wait and try your request again.
	//
	ServerErrorReasonReasonServerBusy = "SERVER_BUSY"

	// ServerErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ServerErrorReasonReasonUnknown = "UNKNOWN"
)

// SetTopBoxLineItemErrorReasonReason
//
// Reason for set-top box error.
const (

	// SetTopBoxLineItemErrorReasonReasonNonSetTopBoxAdUnitTargeted
	//
	// The set-top box line item cannot target an ad unit that doesn't have an external
	// set-top box channel ID.
	//
	SetTopBoxLineItemErrorReasonReasonNonSetTopBoxAdUnitTargeted = "NON_SET_TOP_BOX_AD_UNIT_TARGETED"

	// SetTopBoxLineItemErrorReasonReasonAtLeastOneAdUnitMustBeTargeted
	//
	// The set-top box line item must target at least one ad unit.
	//
	SetTopBoxLineItemErrorReasonReasonAtLeastOneAdUnitMustBeTargeted = "AT_LEAST_ONE_AD_UNIT_MUST_BE_TARGETED"

	// SetTopBoxLineItemErrorReasonReasonCannotExcludeAdUnits
	//
	// The set-top box line item cannot exclude ad units.
	//
	SetTopBoxLineItemErrorReasonReasonCannotExcludeAdUnits = "CANNOT_EXCLUDE_AD_UNITS"

	// SetTopBoxLineItemErrorReasonReasonPodPositionOutOfRange
	//
	// The set-top box line item can only target pod positions 1 - 15.
	//
	SetTopBoxLineItemErrorReasonReasonPodPositionOutOfRange = "POD_POSITION_OUT_OF_RANGE"

	// SetTopBoxLineItemErrorReasonReasonMidrollPositionOutOfRange
	//
	// The set-top box line item can only target midroll positions 4 - 100.
	//
	SetTopBoxLineItemErrorReasonReasonMidrollPositionOutOfRange = "MIDROLL_POSITION_OUT_OF_RANGE"

	// SetTopBoxLineItemErrorReasonReasonFeatureNotEnabled
	//
	// The set-top box feature is not enabled.
	//
	SetTopBoxLineItemErrorReasonReasonFeatureNotEnabled = "FEATURE_NOT_ENABLED"

	// SetTopBoxLineItemErrorReasonReasonInvalidEnvironmentType
	//
	// Only {@link EnvironmentType#VIDEO_PLAYER} is supported for set-top box line items.
	//
	SetTopBoxLineItemErrorReasonReasonInvalidEnvironmentType = "INVALID_ENVIRONMENT_TYPE"

	// SetTopBoxLineItemErrorReasonReasonCompanionsNotSupported
	//
	// Companions are not supported for set-top box line items.
	//
	SetTopBoxLineItemErrorReasonReasonCompanionsNotSupported = "COMPANIONS_NOT_SUPPORTED"

	// SetTopBoxLineItemErrorReasonReasonInvalidCreativeSize
	//
	// Set-top box line items only support sizes supported by Canoe.
	//
	SetTopBoxLineItemErrorReasonReasonInvalidCreativeSize = "INVALID_CREATIVE_SIZE"

	// SetTopBoxLineItemErrorReasonReasonInvalidLineItemType
	//
	// Set-top box line items only support {@link LineItemType#STANDARD},
	// {@link LineItemType#HOUSE}, and {@link LineItemType#SPONSORSHIP} line item services.
	//
	SetTopBoxLineItemErrorReasonReasonInvalidLineItemType = "INVALID_LINE_ITEM_TYPE"

	// SetTopBoxLineItemErrorReasonReasonOrdersWithStandardLineItemsCannotContainHouseOrSponsorshipLineItems
	//
	// {@link Order orders} containing {@link LineItemType#STANDARD} set-top box line items cannot
	// contain set-top box line items of type {@link LineItemType#HOUSE} or
	// {@link LineItemType#SPONSORSHIP}.
	//
	SetTopBoxLineItemErrorReasonReasonOrdersWithStandardLineItemsCannotContainHouseOrSponsorshipLineItems = "ORDERS_WITH_STANDARD_LINE_ITEMS_CANNOT_CONTAIN_HOUSE_OR_SPONSORSHIP_LINE_ITEMS"

	// SetTopBoxLineItemErrorReasonReasonInvalidCostType
	//
	// Set-top box line items only support {@link CostType#CPM}.
	//
	SetTopBoxLineItemErrorReasonReasonInvalidCostType = "INVALID_COST_TYPE"

	// SetTopBoxLineItemErrorReasonReasonCostPerUnitNotAllowed
	//
	// Set-top box line items do not support a cost per unit.
	//
	SetTopBoxLineItemErrorReasonReasonCostPerUnitNotAllowed = "COST_PER_UNIT_NOT_ALLOWED"

	// SetTopBoxLineItemErrorReasonReasonDiscountNotAllowed
	//
	// Set-top box line items do not support discounts.
	//
	SetTopBoxLineItemErrorReasonReasonDiscountNotAllowed = "DISCOUNT_NOT_ALLOWED"

	// SetTopBoxLineItemErrorReasonReasonFrontloadedDeliveryRateNotSupported
	//
	// Set-top box line items do not support {@link DeliveryRateType#FRONTLOADED}.
	//
	SetTopBoxLineItemErrorReasonReasonFrontloadedDeliveryRateNotSupported = "FRONTLOADED_DELIVERY_RATE_NOT_SUPPORTED"

	// SetTopBoxLineItemErrorReasonReasonInvalidLineItemStatusChange
	//
	// Set-top box line items cannot go from a state that is ready to be synced to a
	// state that is not ready to be synced.
	//
	SetTopBoxLineItemErrorReasonReasonInvalidLineItemStatusChange = "INVALID_LINE_ITEM_STATUS_CHANGE"

	// SetTopBoxLineItemErrorReasonReasonInvalidLineItemPriority
	//
	// Set-top box line items can only have certain priorities for different
	// {@link ReservationType reservation services}:
	// <ul>
	// <li>{@link ReservationType#SPONSORSHIP} => 1</li>
	// <li>{@link ReservationType#HOUSE} => 16</li>
	// <li>{@link ReservationType#STANDARD} => Between 1 and 16 inclusive.</li>
	// </ul>
	//
	SetTopBoxLineItemErrorReasonReasonInvalidLineItemPriority = "INVALID_LINE_ITEM_PRIORITY"

	// SetTopBoxLineItemErrorReasonReasonSyncRevisionNotIncreasing
	//
	// When a set-top box line item is pushed to Canoe, a revision number is used to keep track of
	// the last version of the line item that Ad Manager synced with Canoe. The only change
	// allowed on revisions within Ad Manager is increasing the revision number.
	//
	SetTopBoxLineItemErrorReasonReasonSyncRevisionNotIncreasing = "SYNC_REVISION_NOT_INCREASING"

	// SetTopBoxLineItemErrorReasonReasonSyncRevisionMustBeGreaterThanZero
	//
	// When a set-top box line item is pushed to Canoe, a revision number is used to keep track of
	// the last version of the line item that Ad Manager synced with Canoe. Sync revisions begin
	// at one and can only increase in value.
	//
	SetTopBoxLineItemErrorReasonReasonSyncRevisionMustBeGreaterThanZero = "SYNC_REVISION_MUST_BE_GREATER_THAN_ZERO"

	// SetTopBoxLineItemErrorReasonReasonCannotUnarchiveSetTopBoxLineItems
	//
	// Set Top box line items cannot be unarchived.
	//
	SetTopBoxLineItemErrorReasonReasonCannotUnarchiveSetTopBoxLineItems = "CANNOT_UNARCHIVE_SET_TOP_BOX_LINE_ITEMS"

	// SetTopBoxLineItemErrorReasonReasonCopySetTopBoxEnabledLineItemNotAllowed
	//
	// Set-top box enabled line items cannot be copied for V0 of the video Canoe campaign push.
	//
	SetTopBoxLineItemErrorReasonReasonCopySetTopBoxEnabledLineItemNotAllowed = "COPY_SET_TOP_BOX_ENABLED_LINE_ITEM_NOT_ALLOWED"

	// SetTopBoxLineItemErrorReasonReasonInvalidLineItemTypeChange
	//
	// Standard set-top box line items cannot be updated to be {@link LineItemType#House} or
	// {@link LineItemType#Sponsorship} line items and vice versa.
	//
	SetTopBoxLineItemErrorReasonReasonInvalidLineItemTypeChange = "INVALID_LINE_ITEM_TYPE_CHANGE"

	// SetTopBoxLineItemErrorReasonReasonCreativeRotationTypeMustBeEvenlyOrWeighted
	//
	// Set-top box line items can only have a creative rotation type of
	// {@link CreativeRotationType.EVEN} or {@link CreativeRotationType#MANUAL}.
	//
	SetTopBoxLineItemErrorReasonReasonCreativeRotationTypeMustBeEvenlyOrWeighted = "CREATIVE_ROTATION_TYPE_MUST_BE_EVENLY_OR_WEIGHTED"

	// SetTopBoxLineItemErrorReasonReasonInvalidFrequencyCapTimeUnit
	//
	// Set-top box line items can only have frequency capping with time units of
	// {@link TimeUnit#DAY}, {@link TimeUnit#HOUR}, {@link TimeUnit#POD}, or
	// {@link TimeUnit#STREAM}.
	//
	SetTopBoxLineItemErrorReasonReasonInvalidFrequencyCapTimeUnit = "INVALID_FREQUENCY_CAP_TIME_UNIT"

	// SetTopBoxLineItemErrorReasonReasonInvalidFrequencyCapTimeRange
	//
	// Set-top box line items can only have specific time ranges for certain time units:
	// <ul>
	// <li>{@link TimeUnit#HOUR} => 1, 2, 6</li>
	// <li>{@link TimeUnit#DAY} => 1, 3</li>
	// </ul>
	//
	SetTopBoxLineItemErrorReasonReasonInvalidFrequencyCapTimeRange = "INVALID_FREQUENCY_CAP_TIME_RANGE"

	// SetTopBoxLineItemErrorReasonReasonInvalidPrimaryGoalUnitType
	//
	// Set-top box line items can only have a unit type of {@link UnitType#IMPRESSIONS}.
	//
	SetTopBoxLineItemErrorReasonReasonInvalidPrimaryGoalUnitType = "INVALID_PRIMARY_GOAL_UNIT_TYPE"

	// SetTopBoxLineItemErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	SetTopBoxLineItemErrorReasonReasonUnknown = "UNKNOWN"
)

// SkippableAdType
//
// The different services of skippable ads.
type SkippableAdType string

const (

	// SkippableAdTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	SkippableAdTypeUnknown SkippableAdType = "UNKNOWN"

	// SkippableAdTypeDisabled
	//
	// Skippable ad type is disabled.
	//
	SkippableAdTypeDisabled SkippableAdType = "DISABLED"

	// SkippableAdTypeEnabled
	//
	// Skippable ad type is enabled.
	//
	SkippableAdTypeEnabled SkippableAdType = "ENABLED"

	// SkippableAdTypeInstreamSelect
	//
	// Skippable in-stream ad type.
	//
	SkippableAdTypeInstreamSelect SkippableAdType = "INSTREAM_SELECT"

	// SkippableAdTypeAny
	//
	// Any skippable or not skippable. This is only for programmatic case when the creative
	// skippability is decided by the buyside.
	//
	SkippableAdTypeAny SkippableAdType = "ANY"
)

// StartDateTimeType
//
// Specifies the start type to use for an entity with a start date time field.
// For example, a {@link LineItem} or {@link LineItemCreativeAssociation}.
type StartDateTimeType string

const (

	// StartDateTimeTypeUseStartDateTime
	//
	// Use the value in {@link #startDateTime}.
	//
	StartDateTimeTypeUseStartDateTime StartDateTimeType = "USE_START_DATE_TIME"

	// StartDateTimeTypeImmediately
	//
	// The entity will start serving immediately. {@link #startDateTime} in the
	// request is ignored and will be set to the current time. Additionally,
	// {@link #startDateTimeType} will be set to
	// {@link StartDateTimeType#USE_START_DATE_TIME}.
	//
	StartDateTimeTypeImmediately StartDateTimeType = "IMMEDIATELY"

	// StartDateTimeTypeOneHourFromNow
	//
	// The entity will start serving one hour from now. {@link #startDateTime}
	// in the request is ignored and will be set to one hour from the current
	// time. Additionally, {@link #startDateTimeType} will be set to
	// {@link StartDateTimeType#USE_START_DATE_TIME}.
	//
	StartDateTimeTypeOneHourFromNow StartDateTimeType = "ONE_HOUR_FROM_NOW"

	// StartDateTimeTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StartDateTimeTypeUnknown StartDateTimeType = "UNKNOWN"
)

// StatementErrorReasonReason
const (

	// StatementErrorReasonReasonVariableNotBoundToValue
	//
	// A bind variable has not been bound to a value.
	//
	StatementErrorReasonReasonVariableNotBoundToValue = "VARIABLE_NOT_BOUND_TO_VALUE"

	// StatementErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StatementErrorReasonReasonUnknown = "UNKNOWN"
)

// StringFormatErrorReasonReason
//
// The reasons for the target error.
const (

	// StringFormatErrorReasonReasonUnknown
	StringFormatErrorReasonReasonUnknown = "UNKNOWN"

	// StringFormatErrorReasonReasonIllegalChars
	//
	// The input string value contains disallowed characters.
	//
	StringFormatErrorReasonReasonIllegalChars = "ILLEGAL_CHARS"

	// StringFormatErrorReasonReasonInvalidFormat
	//
	// The input string value is invalid for the associated field.
	//
	StringFormatErrorReasonReasonInvalidFormat = "INVALID_FORMAT"
)

// StringLengthErrorReasonReason
const (

	// StringLengthErrorReasonReasonTooLong
	StringLengthErrorReasonReasonTooLong = "TOO_LONG"

	// StringLengthErrorReasonReasonTooShort
	StringLengthErrorReasonReasonTooShort = "TOO_SHORT"

	// StringLengthErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StringLengthErrorReasonReasonUnknown = "UNKNOWN"
)

// TeamErrorReasonReason
//
// The reasons for the target error.
const (

	// TeamErrorReasonReasonEntityNotOnUsersTeams
	//
	// User cannot use this entity because it is not on any of the user's teams.
	//
	TeamErrorReasonReasonEntityNotOnUsersTeams = "ENTITY_NOT_ON_USERS_TEAMS"

	// TeamErrorReasonReasonAdUnitsNotOnOrderTeams
	//
	// The targeted or excluded ad unit must be on the order's teams.
	//
	TeamErrorReasonReasonAdUnitsNotOnOrderTeams = "AD_UNITS_NOT_ON_ORDER_TEAMS"

	// TeamErrorReasonReasonPlacementsNotOnOrderTeams
	//
	// The targeted placement must be on the order's teams.
	//
	TeamErrorReasonReasonPlacementsNotOnOrderTeams = "PLACEMENTS_NOT_ON_ORDER_TEAMS"

	// TeamErrorReasonReasonMissingUsersTeam
	//
	// Entity cannot be created because it is not on any of the user's teams.
	//
	TeamErrorReasonReasonMissingUsersTeam = "MISSING_USERS_TEAM"

	// TeamErrorReasonReasonAllTeamAssociationNotAllowed
	//
	// A team that gives access to all entities of a given type cannot be
	// associated with an entity of that type.
	//
	TeamErrorReasonReasonAllTeamAssociationNotAllowed = "ALL_TEAM_ASSOCIATION_NOT_ALLOWED"

	// TeamErrorReasonReasonInvalidTeamAssignment
	//
	// The assignment of team to entities is invalid.
	//
	TeamErrorReasonReasonInvalidTeamAssignment = "INVALID_TEAM_ASSIGNMENT"

	// TeamErrorReasonReasonCannotUpdateInactiveTeam
	//
	// Cannot modify or create a team with an inactive status.
	//
	TeamErrorReasonReasonCannotUpdateInactiveTeam = "CANNOT_UPDATE_INACTIVE_TEAM"

	// TeamErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TeamErrorReasonReasonUnknown = "UNKNOWN"
)

// TechnologyTargetingErrorReasonReason
//
// The reasons for the target error.
const (

	// TechnologyTargetingErrorReasonReasonMobileLineItemContainsWebTechCriteria
	//
	// Mobile line item cannot target web-only targeting criteria.
	//
	TechnologyTargetingErrorReasonReasonMobileLineItemContainsWebTechCriteria = "MOBILE_LINE_ITEM_CONTAINS_WEB_TECH_CRITERIA"

	// TechnologyTargetingErrorReasonReasonWebLineItemContainsMobileTechCriteria
	//
	// Web line item cannot target mobile-only targeting criteria.
	//
	TechnologyTargetingErrorReasonReasonWebLineItemContainsMobileTechCriteria = "WEB_LINE_ITEM_CONTAINS_MOBILE_TECH_CRITERIA"

	// TechnologyTargetingErrorReasonReasonMobileCarrierTargetingFeatureNotEnabled
	//
	// The mobile carrier targeting feature is not enabled.
	//
	TechnologyTargetingErrorReasonReasonMobileCarrierTargetingFeatureNotEnabled = "MOBILE_CARRIER_TARGETING_FEATURE_NOT_ENABLED"

	// TechnologyTargetingErrorReasonReasonDeviceCapabilityTargetingFeatureNotEnabled
	//
	// The device capability targeting feature is not enabled.
	//
	TechnologyTargetingErrorReasonReasonDeviceCapabilityTargetingFeatureNotEnabled = "DEVICE_CAPABILITY_TARGETING_FEATURE_NOT_ENABLED"

	// TechnologyTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TechnologyTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// ThirdPartyBrandLiftIntegrationPartner
//
// Possible options for third-party brand lift integration.
type ThirdPartyBrandLiftIntegrationPartner string

const (

	// ThirdPartyBrandLiftIntegrationPartnerUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ThirdPartyBrandLiftIntegrationPartnerUnknown ThirdPartyBrandLiftIntegrationPartner = "UNKNOWN"

	// ThirdPartyBrandLiftIntegrationPartnerNone
	//
	// Indicates there's no third-party brand lift integration partner.
	//
	ThirdPartyBrandLiftIntegrationPartnerNone ThirdPartyBrandLiftIntegrationPartner = "NONE"

	// ThirdPartyBrandLiftIntegrationPartnerKantarMillwardBrown
	//
	// Indicates third-party brand lift integration partner Kantar.
	//
	ThirdPartyBrandLiftIntegrationPartnerKantarMillwardBrown ThirdPartyBrandLiftIntegrationPartner = "KANTAR_MILLWARD_BROWN"

	// ThirdPartyBrandLiftIntegrationPartnerDynata
	//
	// Indicates third-party brand lift integration partner Dynata.
	//
	ThirdPartyBrandLiftIntegrationPartnerDynata ThirdPartyBrandLiftIntegrationPartner = "DYNATA"

	// ThirdPartyBrandLiftIntegrationPartnerIntage
	//
	// Indicates third-party brand lift integration partner Intage.
	//
	ThirdPartyBrandLiftIntegrationPartnerIntage ThirdPartyBrandLiftIntegrationPartner = "INTAGE"

	// ThirdPartyBrandLiftIntegrationPartnerMacromill
	//
	// Indicates third-party brand lift integration partner Macromill.
	//
	ThirdPartyBrandLiftIntegrationPartnerMacromill ThirdPartyBrandLiftIntegrationPartner = "MACROMILL"
)

// ThirdPartyReachIntegrationPartner
//
// Possible options for third-party reach integration.
type ThirdPartyReachIntegrationPartner string

const (

	// ThirdPartyReachIntegrationPartnerNone
	//
	// Indicates there's no third-party reach integration partner.
	//
	ThirdPartyReachIntegrationPartnerNone ThirdPartyReachIntegrationPartner = "NONE"

	// ThirdPartyReachIntegrationPartnerComscore
	//
	// Indicates third-party reach integration partner Comscore.
	//
	ThirdPartyReachIntegrationPartnerComscore ThirdPartyReachIntegrationPartner = "COMSCORE"

	// ThirdPartyReachIntegrationPartnerNielsen
	//
	// Indicates third-party reach integration partner Nielsen.
	//
	ThirdPartyReachIntegrationPartnerNielsen ThirdPartyReachIntegrationPartner = "NIELSEN"

	// ThirdPartyReachIntegrationPartnerKantarMillwardBrown
	//
	// Indicates third-party reach integration partner Kantar.
	//
	ThirdPartyReachIntegrationPartnerKantarMillwardBrown ThirdPartyReachIntegrationPartner = "KANTAR_MILLWARD_BROWN"

	// ThirdPartyReachIntegrationPartnerVideoResearch
	//
	// Indicates third-party reach integration partner Video Research.
	//
	ThirdPartyReachIntegrationPartnerVideoResearch ThirdPartyReachIntegrationPartner = "VIDEO_RESEARCH"

	// ThirdPartyReachIntegrationPartnerGemius
	//
	// Indicates third-party reach integration partner Gemius.
	//
	ThirdPartyReachIntegrationPartnerGemius ThirdPartyReachIntegrationPartner = "GEMIUS"

	// ThirdPartyReachIntegrationPartnerVideoAmp
	//
	// Indicates third-party reach integration partner VideoAmp
	//
	ThirdPartyReachIntegrationPartnerVideoAmp ThirdPartyReachIntegrationPartner = "VIDEO_AMP"

	// ThirdPartyReachIntegrationPartnerIspotTv
	//
	// Indicates third-party reach integration partner iSpot.TV
	//
	ThirdPartyReachIntegrationPartnerIspotTv ThirdPartyReachIntegrationPartner = "ISPOT_TV"

	// ThirdPartyReachIntegrationPartnerAudienceProject
	//
	// Indicates third-party reach integration partner Audience Project
	//
	ThirdPartyReachIntegrationPartnerAudienceProject ThirdPartyReachIntegrationPartner = "AUDIENCE_PROJECT"

	// ThirdPartyReachIntegrationPartnerUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ThirdPartyReachIntegrationPartnerUnknown ThirdPartyReachIntegrationPartner = "UNKNOWN"
)

// ThirdPartyViewabilityIntegrationPartner
//
// Possible options for third-party viewabitility integration.
type ThirdPartyViewabilityIntegrationPartner string

const (

	// ThirdPartyViewabilityIntegrationPartnerNone
	//
	// Indicates there's no third-party viewability integration partner.
	//
	ThirdPartyViewabilityIntegrationPartnerNone ThirdPartyViewabilityIntegrationPartner = "NONE"

	// ThirdPartyViewabilityIntegrationPartnerMoat
	//
	// Indicates third-party viewability integration partner Oracle Moat.
	//
	ThirdPartyViewabilityIntegrationPartnerMoat ThirdPartyViewabilityIntegrationPartner = "MOAT"

	// ThirdPartyViewabilityIntegrationPartnerDoubleVerify
	//
	// Indicates third-party viewability integration partner Double Verify.
	//
	ThirdPartyViewabilityIntegrationPartnerDoubleVerify ThirdPartyViewabilityIntegrationPartner = "DOUBLE_VERIFY"

	// ThirdPartyViewabilityIntegrationPartnerIntegralAdScience
	//
	// Indicates third-party viewability integration partner Integral Ad Science.
	//
	ThirdPartyViewabilityIntegrationPartnerIntegralAdScience ThirdPartyViewabilityIntegrationPartner = "INTEGRAL_AD_SCIENCE"

	// ThirdPartyViewabilityIntegrationPartnerComscore
	//
	// Indicates third-party viewability integration partner Comscore.
	//
	ThirdPartyViewabilityIntegrationPartnerComscore ThirdPartyViewabilityIntegrationPartner = "COMSCORE"

	// ThirdPartyViewabilityIntegrationPartnerTelemetry
	//
	// Indicates third-party viewability integration partner Telemetry.
	//
	ThirdPartyViewabilityIntegrationPartnerTelemetry ThirdPartyViewabilityIntegrationPartner = "TELEMETRY"

	// ThirdPartyViewabilityIntegrationPartnerUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ThirdPartyViewabilityIntegrationPartnerUnknown ThirdPartyViewabilityIntegrationPartner = "UNKNOWN"
)

// TimeUnit
//
// Represent the possible time units for frequency capping.
type TimeUnit string

const (

	// TimeUnitMinute
	TimeUnitMinute TimeUnit = "MINUTE"

	// TimeUnitHour
	TimeUnitHour TimeUnit = "HOUR"

	// TimeUnitDay
	TimeUnitDay TimeUnit = "DAY"

	// TimeUnitWeek
	TimeUnitWeek TimeUnit = "WEEK"

	// TimeUnitMonth
	TimeUnitMonth TimeUnit = "MONTH"

	// TimeUnitLifetime
	TimeUnitLifetime TimeUnit = "LIFETIME"

	// TimeUnitPod
	//
	// Per pod of ads in a video stream. Only valid for entities in a
	// {@link EnvironmentType#VIDEO_PLAYER} environment.
	//
	TimeUnitPod TimeUnit = "POD"

	// TimeUnitStream
	//
	// Per video stream. Only valid for entities in a
	// {@link EnvironmentType#VIDEO_PLAYER} environment.
	//
	TimeUnitStream TimeUnit = "STREAM"

	// TimeUnitUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TimeUnitUnknown TimeUnit = "UNKNOWN"
)

// TimeZoneErrorReasonReason
//
// Describes reasons for invalid timezone.
const (

	// TimeZoneErrorReasonReasonInvalidTimezoneId
	//
	// Indicates that the timezone ID provided is not supported.
	//
	TimeZoneErrorReasonReasonInvalidTimezoneId = "INVALID_TIMEZONE_ID"

	// TimeZoneErrorReasonReasonTimezoneIdInWrongFormat
	//
	// Indicates that the timezone ID provided is in the wrong format.
	// The timezone ID must be in tz database format (e.g. "America/Los_Angeles").
	//
	TimeZoneErrorReasonReasonTimezoneIdInWrongFormat = "TIMEZONE_ID_IN_WRONG_FORMAT"

	// TimeZoneErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TimeZoneErrorReasonReasonUnknown = "UNKNOWN"
)

// TranscodingErrorReasonReason
//
// The type of transcode request rejection.
const (

	// TranscodingErrorReasonReasonCannotCopyCreativePendingTranscode
	//
	// The request to copy the creative(s) was rejected because the source is not transcoded.
	//
	TranscodingErrorReasonReasonCannotCopyCreativePendingTranscode = "CANNOT_COPY_CREATIVE_PENDING_TRANSCODE"

	// TranscodingErrorReasonReasonCannotCopyInvalidCreative
	//
	// The request to copy the creative(s) was rejected because the source is invalid.
	//
	TranscodingErrorReasonReasonCannotCopyInvalidCreative = "CANNOT_COPY_INVALID_CREATIVE"

	// TranscodingErrorReasonReasonTranscodingIsInProgress
	//
	// The creative is still being transcoded or processed. Please try again later.
	//
	TranscodingErrorReasonReasonTranscodingIsInProgress = "TRANSCODING_IS_IN_PROGRESS"

	// TranscodingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TranscodingErrorReasonReasonUnknown = "UNKNOWN"
)

// UnitType
//
// Indicates the type of unit used for defining a reservation. The
// {@link CostType} can differ from the {@link UnitType} - an
// ad can have an impression goal, but be billed by its click. Usually
// {@link CostType} and {@link UnitType} will refer to the
// same unit.
type UnitType string

const (

	// UnitTypeImpressions
	//
	// The number of impressions served by creatives associated with the line
	// item. Line items of all {@link LineItemType} support this {@code UnitType}.
	//
	UnitTypeImpressions UnitType = "IMPRESSIONS"

	// UnitTypeClicks
	//
	// The number of clicks reported by creatives associated with the line item.
	// The {@link LineItem#lineItemType} must be
	// {@link LineItemType#STANDARD}, {@link LineItemType#BULK} or
	// {@link LineItemType#PRICE_PRIORITY}.
	//
	UnitTypeClicks UnitType = "CLICKS"

	// UnitTypeClickThroughCpaConversions
	//
	// The number of click-through Cost-Per-Action (CPA) conversions from creatives
	// associated with the line item. This is only supported as secondary goal and the
	// {@link LineItem#costType} must be {@link CostType#CPA}.
	//
	UnitTypeClickThroughCpaConversions UnitType = "CLICK_THROUGH_CPA_CONVERSIONS"

	// UnitTypeViewThroughCpaConversions
	//
	// The number of view-through Cost-Per-Action (CPA) conversions from creatives
	// associated with the line item. This is only supported as secondary goal and the
	// {@link LineItem#costType} must be {@link CostType#CPA}.
	//
	UnitTypeViewThroughCpaConversions UnitType = "VIEW_THROUGH_CPA_CONVERSIONS"

	// UnitTypeTotalCpaConversions
	//
	// The number of total Cost-Per-Action (CPA) conversions from creatives
	// associated with the line item. This is only supported as secondary goal and the
	// {@link LineItem#costType} must be {@link CostType#CPA}.
	//
	UnitTypeTotalCpaConversions UnitType = "TOTAL_CPA_CONVERSIONS"

	// UnitTypeViewableImpressions
	//
	// The number of viewable impressions reported by creatives associated with the line item.
	// The {@link LineItem#lineItemType} must be {@link LineItemType#STANDARD}.
	//
	UnitTypeViewableImpressions UnitType = "VIEWABLE_IMPRESSIONS"

	// UnitTypeInTargetImpressions
	//
	// The number of in-target impressions reported by third party measurements.
	// The {@link LineItem#lineItemType} must be {@link LineItemType#STANDARD}.
	//
	UnitTypeInTargetImpressions UnitType = "IN_TARGET_IMPRESSIONS"

	// UnitTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	UnitTypeUnknown UnitType = "UNKNOWN"
)

// UserDomainTargetingErrorReasonReason
//
// {@link ApiErrorReason} enum for user domain targeting error.
const (

	// UserDomainTargetingErrorReasonReasonInvalidDomainNames
	//
	// Invalid domain names. Domain names must be at most 67 characters long.
	// And must contain only alphanumeric characters and hyphens.
	//
	UserDomainTargetingErrorReasonReasonInvalidDomainNames = "INVALID_DOMAIN_NAMES"

	// UserDomainTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	UserDomainTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// VideoBumperType
//
// Represents the options for targetable bumper positions, surrounding an ad
// pod, within a video stream. This includes before and after the supported ad
// pod positions, {@link VideoPositionType#PREROLL},
// {@link VideoPositionType#MIDROLL}, and {@link VideoPositionType#POSTROLL}.
type VideoBumperType string

const (

	// VideoBumperTypeBefore
	//
	// Represents the bumper position before the ad pod.
	//
	VideoBumperTypeBefore VideoBumperType = "BEFORE"

	// VideoBumperTypeAfter
	//
	// Represents the bumper position after the ad pod.
	//
	VideoBumperTypeAfter VideoBumperType = "AFTER"
)

// VideoPositionTypeType
//
// Represents a targetable position within a video.
type VideoPositionType string

const (

	// VideoPositionTypeTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	VideoPositionTypeTypeUnknown VideoPositionType = "UNKNOWN"

	// VideoPositionTypeTypeAll
	//
	// This position targets all of the above video positions.
	//
	VideoPositionTypeTypeAll VideoPositionType = "ALL"

	// VideoPositionTypeTypePreroll
	//
	// The position defined as showing before the video starts playing.
	//
	VideoPositionTypeTypePreroll VideoPositionType = "PREROLL"

	// VideoPositionTypeTypeMidroll
	//
	// The position defined as showing within the middle of the playing video.
	//
	VideoPositionTypeTypeMidroll VideoPositionType = "MIDROLL"

	// VideoPositionTypeTypePostroll
	//
	// The position defined as showing after the video is completed.
	//
	VideoPositionTypeTypePostroll VideoPositionType = "POSTROLL"
)

// VideoPositionTargetingErrorReasonReason
//
// The reasons for the video position targeting error.
const (

	// VideoPositionTargetingErrorReasonReasonCannotMixBumperAndNonBumperTargeting
	//
	// Video position targeting cannot contain both bumper and non-bumper targeting values.
	//
	VideoPositionTargetingErrorReasonReasonCannotMixBumperAndNonBumperTargeting = "CANNOT_MIX_BUMPER_AND_NON_BUMPER_TARGETING"

	// VideoPositionTargetingErrorReasonReasonInvalidBumperTargeting
	//
	// The bumper video position targeting is invalid.
	//
	VideoPositionTargetingErrorReasonReasonInvalidBumperTargeting = "INVALID_BUMPER_TARGETING"

	// VideoPositionTargetingErrorReasonReasonCanOnlyTargetCustomAdSpots
	//
	// Only custom spot {@link AdSpot} objects can be targeted.
	//
	VideoPositionTargetingErrorReasonReasonCanOnlyTargetCustomAdSpots = "CAN_ONLY_TARGET_CUSTOM_AD_SPOTS"

	// VideoPositionTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	VideoPositionTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// createLineItems
//
// Creates new {@link LineItem} objects.
type CreateLineItems struct {
	LineItems []*LineItem `xml:"lineItems"`
}

// createLineItemsResponse
type CreateLineItemsResponse struct {
	Rval []*LineItem `xml:"rval"`
}

// getLineItemsByStatement
//
// Gets a {@link LineItemPage} of {@link LineItem} objects that satisfy the given {@link
// Statement#query}. The following fields are supported for filtering:
//
// <table>
// <tbody>
// <tr>
// <th>PQL property</th>
// <th>Entity property</th>
// </tr>
// <tr>
// <td>
// {@code CostType}
// </td>
// <td>
// {@link LineItem#costType}
// </td>
// </tr>
// <tr>
// <td>
// {@code CreationDateTime}
// </td>
// <td>
// {@link LineItem#creationDateTime}
// </td>
// </tr>
// <tr>
// <td>
// {@code DeliveryRateType}
// </td>
// <td>
// {@link LineItem#deliveryRateType}
// </td>
// </tr>
// <tr>
// <td>
// {@code EndDateTime}
// </td>
// <td>
// {@link LineItem#endDateTime}
// </td>
// </tr>
// <tr>
// <td>
// {@code ExternalId}
// </td>
// <td>
// {@link LineItem#externalId}
// </td>
// </tr>
// <tr>
// <td>
// {@code Id}
// </td>
// <td>
// {@link LineItem#id}
// </td>
// </tr>
// <tr>
// <td>
// {@code IsMissingCreatives}
// </td>
// <td>
// {@link LineItem#isMissingCreatives}
// </td>
// </tr>
// <tr>
// <td>
// {@code IsSetTopBoxEnabled}
// </td>
// <td>
// {@link LineItem#isSetTopBoxEnabled}
// </td>
// </tr>
// <tr>
// <td>
// {@code LastModifiedDateTime}
// </td>
// <td>
// {@link LineItem#lastModifiedDateTime}
// </td>
// </tr>
// <tr>
// <td>
// {@code LineItemType}
// </td>
// <td>
// {@link LineItem#lineItemType}
// </td>
// </tr>
// <tr>
// <td>
// {@code Name}
// </td>
// <td>
// {@link LineItem#name}
// </td>
// </tr>
// <tr>
// <td>
// {@code OrderId}
// </td>
// <td>
// {@link LineItem#orderId}
// </td>
// </tr>
// <tr>
// <td>
// {@code StartDateTime}
// </td>
// <td>
// {@link LineItem#startDateTime}
// </td>
// </tr>
// <tr>
// <td>
// {@code Status}
// </td>
// <td>
// {@link LineItem#status}
// </td>
// </tr>
// <tr>
// <td>
// {@code UnitsBought}
// </td>
// <td>
// {@link LineItem#unitsBought}
// </td>
// </tr>
// </tbody>
// </table>
type GetLineItemsByStatement struct {
	FilterStatement *Statement `xml:"filterStatement"`
}

// getLineItemsByStatementResponse
type GetLineItemsByStatementResponse struct {
	Rval *LineItemPage `xml:"rval"`
}

// performLineItemAction
//
// Performs actions on {@link LineItem} objects that match the given {@link Statement#query}.
type PerformLineItemAction struct {
	LineItemAction *LineItemAction `xml:"lineItemAction"`

	FilterStatement *Statement `xml:"filterStatement"`
}

// performLineItemActionResponse
type PerformLineItemActionResponse struct {
	Rval *UpdateResult `xml:"rval"`
}

// updateLineItems
//
// Updates the specified {@link LineItem} objects.
type UpdateLineItems struct {
	LineItems []*LineItem `xml:"lineItems"`
}

// updateLineItemsResponse
type UpdateLineItemsResponse struct {
	Rval []*LineItem `xml:"rval"`
}

// RequestHeader
type RequestHeader struct {
}

// ResponseHeader
type ResponseHeader struct {
}
