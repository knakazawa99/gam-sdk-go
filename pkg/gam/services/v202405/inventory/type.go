// Code generated by gamwsdl/main.go. DO NOT EDIT.
package inventory

import (
	"github.com/knakazawa99/gam-sdk-go/pkg/gam/requestbody"
	gamxml "github.com/knakazawa99/gam-sdk-go/pkg/xml"
)

// ObjectValue
//
// Contains an object value.
// <p>
// <b>This object is experimental!
// <code>ObjectValue</code> is an experimental, innovative, and rapidly
// changing new feature for Ad Manager. Unfortunately, being on the bleeding edge means that
// we may make backwards-incompatible changes to
// <code>ObjectValue</code>. We will inform the community when this feature
// is no longer experimental.</b>
//

type ObjectValue struct {
}

// ActivateAdUnits
//
// The action used for activating {@link AdUnit} objects.
//

type ActivateAdUnits struct {
}

func NewActivateAdUnits() (requestbody.PerformAction, error) {
	return &ActivateAdUnits{}, nil
}
func (a ActivateAdUnits) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ActivateAdUnits) GetActionType() string {
	return "ActivateAdUnits"
}

// AdSenseAccountError
//
// Error for AdSense related API calls.
//

type AdSenseAccountError struct {
	Reason string `xml:"reason"`
}

// AdSenseSettings
//
// Contains the AdSense configuration for an {@link AdUnit}.
//

type AdSenseSettings struct {

	// AdSenseEnabled
	//
	// Specifies whether or not the {@link AdUnit} is enabled for serving ads from the AdSense content
	// network. This attribute is optional and defaults to the ad unit's parent or ancestor's setting
	// if one has been set. If no ancestor of the ad unit has set {@code adSenseEnabled}, the
	// attribute is defaulted to {@code true}.
	//

	AdSenseEnabled *bool `xml:"adSenseEnabled"`

	// BorderColor
	//
	// Specifies the Hexadecimal border color, from {@code 000000} to {@code FFFFFF}. This attribute
	// is optional and defaults to the ad unit's parent or ancestor's setting if one has been set. If
	// no ancestor of the ad unit has set {@code borderColor}, the attribute is defaulted to {@code
	// FFFFFF}.
	//

	BorderColor *string `xml:"borderColor"`

	// TitleColor
	//
	// Specifies the Hexadecimal title color of an ad, from {@code 000000} to {@code FFFFFF}. This
	// attribute is optional and defaults to the ad unit's parent or ancestor's setting if one has
	// been set. If no ancestor of the ad unit has set {@code titleColor}, the attribute is defaulted
	// to {@code 0000FF}.
	//

	TitleColor *string `xml:"titleColor"`

	// BackgroundColor
	//
	// Specifies the Hexadecimal background color of an ad, from {@code 000000} to {@code FFFFFF}.
	// This attribute is optional and defaults to the ad unit's parent or ancestor's setting if one
	// has been set. If no ancestor of the ad unit has set {@code backgroundColor}, the attribute is
	// defaulted to {@code FFFFFF}.
	//

	BackgroundColor *string `xml:"backgroundColor"`

	// TextColor
	//
	// Specifies the Hexadecimal color of the text of an ad, from {@code 000000} to {@code FFFFFF}.
	// This attribute is optional and defaults to the ad unit's parent or ancestor's setting if one
	// has been set. If no ancestor of the ad unit has set {@code textColor}, the attribute is
	// defaulted to {@code 000000}.
	//

	TextColor *string `xml:"textColor"`

	// UrlColor
	//
	// Specifies the Hexadecimal color of the URL of an ad, from {@code 000000} to {@code FFFFFF}.
	// This attribute is optional and defaults to the ad unit's parent or ancestor's setting if one
	// has been set. If no ancestor of the ad unit has set {@code urlColor}, the attribute is
	// defaulted to {@code 008000} .
	//

	UrlColor *string `xml:"urlColor"`

	// AdType
	//
	// Specifies what kind of ad can be served by this {@link AdUnit} from the AdSense Content
	// Network. This attribute is optional and defaults to the ad unit's parent or ancestor's setting
	// if one has been set. If no ancestor of the ad unit has set {@code adType}, the attribute is
	// defaulted to {@link AdType#TEXT_AND_IMAGE}.
	//

	AdType *AdSenseSettingsAdType `xml:"adType"`

	// BorderStyle
	//
	// Specifies the border-style of the {@link AdUnit}. This attribute is optional and defaults to
	// the ad unit's parent or ancestor's setting if one has been set. If no ancestor of the ad unit
	// has set {@code borderStyle}, the attribute is defaulted to {@link BorderStyle#DEFAULT}.
	//

	BorderStyle *AdSenseSettingsBorderStyle `xml:"borderStyle"`

	// FontFamily
	//
	// Specifies the font family of the {@link AdUnit}. This attribute is optional and defaults to the
	// ad unit's parent or ancestor's setting if one has been set. If no ancestor of the ad unit has
	// set {@code fontFamily}, the attribute is defaulted to {@link FontFamily#DEFAULT}.
	//

	FontFamily *AdSenseSettingsFontFamily `xml:"fontFamily"`

	// FontSize
	//
	// Specifies the font size of the {@link AdUnit}. This attribute is optional and defaults to the
	// ad unit's parent or ancestor's setting if one has been set. If no ancestor of the ad unit has
	// set {@code fontSize}, the attribute is defaulted to {@link FontSize#DEFAULT}.
	//

	FontSize *AdSenseSettingsFontSize `xml:"fontSize"`
}

// AdUnitAction
//
// Represents the actions that can be performed on {@link AdUnit} objects.
//

type AdUnitAction struct {
}

// AdUnitCodeError
//
// Lists the generic errors associated with {@link AdUnit#adUnitCode}.
//

type AdUnitCodeError struct {
	Reason string `xml:"reason"`
}

// AdUnit
//
// An {@code AdUnit} represents a chunk of identified inventory for the publisher. It contains all
// the settings that need to be associated with inventory in order to serve ads to it. An {@code
// AdUnit} can also be the parent of other ad units in the inventory hierarchy.
//

type AdUnit struct {

	// Id
	//
	// Uniquely identifies the {@code AdUnit}. This value is read-only and is assigned by Google when
	// an ad unit is created. This attribute is required for updates.
	//

	Id *string `xml:"id"`

	// ParentId
	//
	// The ID of the ad unit's parent. Every ad unit has a parent except for the root ad unit, which
	// is created by Google. This attribute is required when creating the ad unit. Once the ad unit is
	// created this value will be read-only.
	//

	ParentId *string `xml:"parentId"`

	// HasChildren
	//
	// This field is set to {@code true} if the ad unit has any children. This attribute is read-only
	// and is populated by Google.
	//

	HasChildren *bool `xml:"hasChildren"`

	// ParentPath
	//
	// The path to this ad unit in the ad unit hierarchy represented as a list from the root to this
	// ad unit's parent. For root ad units, this list is empty. This attribute is read-only and is
	// populated by Google.
	//

	ParentPath []*AdUnitParent `xml:"parentPath"`

	// Name
	//
	// The name of the ad unit. This attribute is required and its maximum length is 255 characters.
	// This attribute must also be case-insensitive unique.
	//

	Name *string `xml:"name"`

	// Description
	//
	// A description of the ad unit. This value is optional and its maximum length is 65,535
	// characters.
	//

	Description *string `xml:"description"`

	// TargetWindow
	//
	// The value to use for the HTML link's {@code target} attribute. This value is optional and will
	// be interpreted as {@link TargetWindow#TOP} if left blank.
	//

	TargetWindow *AdUnitTargetWindow `xml:"targetWindow"`

	// Status
	//
	// The status of this ad unit. It defaults to {@link InventoryStatus#ACTIVE}. This value cannot be
	// updated directly using {@link InventoryService#updateAdUnit}. It can only be modified by
	// performing actions via {@link InventoryService#performAdUnitAction}.
	//

	Status *InventoryStatus `xml:"status"`

	// AdUnitCode
	//
	// A string used to uniquely identify the ad unit for the purposes of serving the ad. This
	// attribute is optional and can be set during ad unit creation. If it is not provided, it will be
	// assigned by Google based off of the inventory unit ID. Once an ad unit is created, its {@code
	// adUnitCode} cannot be changed.
	//

	AdUnitCode *string `xml:"adUnitCode"`

	// AdUnitSizes
	//
	// The permissible creative sizes that can be served inside this ad unit. This attribute is
	// optional. This attribute replaces the {@code sizes} attribute.
	//

	AdUnitSizes []*AdUnitSize `xml:"adUnitSizes"`

	// IsInterstitial
	//
	// Whether this is an interstitial ad unit.
	//

	IsInterstitial *bool `xml:"isInterstitial"`

	// IsNative
	//
	// Whether this is a native ad unit.
	//

	IsNative *bool `xml:"isNative"`

	// IsFluid
	//
	// Whether this is a fluid ad unit.
	//

	IsFluid *bool `xml:"isFluid"`

	// ExplicitlyTargeted
	//
	// If this field is set to {@code true}, then the {@code AdUnit} will not be implicitly targeted
	// when its parent is. Traffickers must explicitly target such an ad unit or else no line items
	// will serve to it. This feature is only available for Ad Manager 360 accounts.
	//

	ExplicitlyTargeted *bool `xml:"explicitlyTargeted"`

	// AdSenseSettings
	//
	// AdSense specific settings. To overwrite this, set the {@link #adSenseSettingsSource} to {@link
	// PropertySourceType#DIRECTLY_SPECIFIED} when setting the value of this field.
	//

	AdSenseSettings *AdSenseSettings `xml:"adSenseSettings"`

	// AdSenseSettingsSource
	//
	// Specifies the source of {@link #adSenseSettings} value. To revert an overridden value to its
	// default, set this field to {@link PropertySourceType#PARENT}.
	//

	AdSenseSettingsSource *ValueSourceType `xml:"adSenseSettingsSource"`

	// AppliedLabelFrequencyCaps
	//
	// The set of label frequency caps applied directly to this ad unit. There is a limit of 10 label
	// frequency caps per ad unit.
	//

	AppliedLabelFrequencyCaps []*LabelFrequencyCap `xml:"appliedLabelFrequencyCaps"`

	// EffectiveLabelFrequencyCaps
	//
	// Contains the set of labels applied directly to the ad unit as well as those inherited from
	// parent ad units. This field is readonly and is assigned by Google.
	//

	EffectiveLabelFrequencyCaps []*LabelFrequencyCap `xml:"effectiveLabelFrequencyCaps"`

	// AppliedLabels
	//
	// The set of labels applied directly to this ad unit.
	//

	AppliedLabels []*AppliedLabel `xml:"appliedLabels"`

	// EffectiveAppliedLabels
	//
	// Contains the set of labels applied directly to the ad unit as well as those inherited from the
	// parent ad units. If a label has been negated, only the negated label is returned. This field is
	// readonly and is assigned by Google.
	//

	EffectiveAppliedLabels []*AppliedLabel `xml:"effectiveAppliedLabels"`

	// EffectiveTeamIds
	//
	// The IDs of all teams that this ad unit is on as well as those inherited from parent ad units.
	// This value is read-only and is set by Google.
	//

	EffectiveTeamIds []*int64 `xml:"effectiveTeamIds"`

	// AppliedTeamIds
	//
	// The IDs of all teams that this ad unit is on directly.
	//

	AppliedTeamIds []*int64 `xml:"appliedTeamIds"`

	// LastModifiedDateTime
	//
	// The date and time this ad unit was last modified.
	//

	LastModifiedDateTime *DateTime `xml:"lastModifiedDateTime"`

	// SmartSizeMode
	//
	// The smart size mode for this ad unit. This attribute is optional and defaults to {@link
	// SmartSizeMode#NONE} for fixed sizes.
	//

	SmartSizeMode *SmartSizeMode `xml:"smartSizeMode"`

	// RefreshRate
	//
	// The interval in seconds which ad units in mobile apps automatically refresh. Valid values are
	// between 30 and 120 seconds. This attribute is optional and only applies to ad units in mobile
	// apps. If this value is not set, then the mobile app ad will not refresh.
	//

	RefreshRate *int `xml:"refreshRate"`

	// ExternalSetTopBoxChannelId
	//
	// Specifies an ID for a channel in an external set-top box campaign management system. This
	// attribute is only meaningful if {@link #isSetTopBoxEnabled} is {@code true}. This attribute is
	// read-only.
	//

	ExternalSetTopBoxChannelId *string `xml:"externalSetTopBoxChannelId"`

	// IsSetTopBoxEnabled
	//
	// Flag that specifies whether this ad unit represents an external set-top box channel. This
	// attribute is read-only.
	//

	IsSetTopBoxEnabled *bool `xml:"isSetTopBoxEnabled"`

	// ApplicationId
	//
	// The {@link MobileApplication#applicationId} for the CTV application that this ad unit is
	// within. This attribute is optional.
	//

	ApplicationId *int64 `xml:"applicationId"`
}

// AdUnitHierarchyError
//
// Caused by creating an {@link AdUnit} object with an invalid hierarchy.
//

type AdUnitHierarchyError struct {
	Reason string `xml:"reason"`
}

// AdUnitPage
//
// Captures a page of {@link AdUnit} objects.
//

type AdUnitPage struct {

	// TotalResultSetSize
	//
	// The size of the total result set to which this page belongs.
	//

	TotalResultSetSize *int `xml:"totalResultSetSize"`

	// StartIndex
	//
	// The absolute index in the total result set on which this page begins.
	//

	StartIndex *int `xml:"startIndex"`

	// Results
	//
	// The collection of ad units contained within this page.
	//

	Results []*AdUnit `xml:"results"`
}

// AdUnitParent
//
// The summary of a parent {@link AdUnit}.
//

type AdUnitParent struct {

	// Id
	//
	// The ID of the parent {@code AdUnit}. This value is readonly and is populated by Google.
	//

	Id *string `xml:"id"`

	// Name
	//
	// The name of the parent {@code AdUnit}. This value is readonly and is populated by Google.
	//

	Name *string `xml:"name"`

	// AdUnitCode
	//
	// A string used to uniquely identify the ad unit for the purposes of serving the ad. This
	// attribute is read-only and is assigned by Google when an ad unit is created.
	//

	AdUnitCode *string `xml:"adUnitCode"`
}

// ApiError
//
// The API error base class that provides details about an error that occurred
// while processing a service request.
//
// <p>The OGNL field path is provided for parsers to identify the request data
// element that may have caused the error.</p>
//

type ApiError struct {
	Reason string `xml:"reason"`
}

// ApiException
//
// Exception class for holding a list of service errors.
//

type ApiException struct {
	Reason string `xml:"reason"`
}

// ApiVersionError
//
// Errors related to the usage of API versions.
//

type ApiVersionError struct {
	Reason string `xml:"reason"`
}

// ApplicationException
//
// Base class for exceptions.
//

type ApplicationException struct {
	Reason string `xml:"reason"`
}

// AppliedLabel
//
// Represents a {@link Label} that can be applied to an entity. To negate an inherited label, create
// an {@code AppliedLabel} with {@code labelId} as the inherited label's ID and {@code isNegated}
// set to true.
//

type AppliedLabel struct {

	// LabelId
	//
	// The ID of a created {@link Label}.
	//

	LabelId *int64 `xml:"labelId"`

	// IsNegated
	//
	// {@code isNegated} should be set to {@code true} to negate the effects of {@code labelId}.
	//

	IsNegated *bool `xml:"isNegated"`
}

// ArchiveAdUnits
//
// The action used for archiving {@link AdUnit} objects.
//

type ArchiveAdUnits struct {
}

func NewArchiveAdUnits() (requestbody.PerformAction, error) {
	return &ArchiveAdUnits{}, nil
}
func (a ArchiveAdUnits) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ArchiveAdUnits) GetActionType() string {
	return "ArchiveAdUnits"
}

// AuthenticationError
//
// An error for an exception that occurred when authenticating.
//

type AuthenticationError struct {
	Reason string `xml:"reason"`
}

// BooleanValue
//
// Contains a boolean value.
//

type BooleanValue struct {

	// Value
	//
	// The boolean value.
	//

	Value *bool `xml:"value"`
}

// CollectionSizeError
//
// Error for the size of the collection being too large
//

type CollectionSizeError struct {
	Reason string `xml:"reason"`
}

// CommonError
//
// A place for common errors that can be used across services.
//

type CommonError struct {
	Reason string `xml:"reason"`
}

// CompanyError
//
// A list of all errors associated with companies.
//

type CompanyError struct {
	Reason string `xml:"reason"`
}

// CreativeWrapperError
//
// Errors specific to creative wrappers.
//

type CreativeWrapperError struct {
	Reason string `xml:"reason"`
}

// CrossSellError
//
// Lists all errors associated with cross selling.
//

type CrossSellError struct {
	Reason string `xml:"reason"`
}

// Date
//
// Represents a date.
//

type Date struct {

	// Year
	//
	// Year (e.g., 2009)
	//

	Year *int `xml:"year"`

	// Month
	//
	// Month (1..12)
	//

	Month *int `xml:"month"`

	// Day
	//
	// Day (1..31)
	//

	Day *int `xml:"day"`
}

// DateTime
//
// Represents a date combined with the time of day.
//

type DateTime struct {

	// Date

	Date *Date `xml:"date"`

	// Hour

	Hour *int `xml:"hour"`

	// Minute

	Minute *int `xml:"minute"`

	// Second

	Second *int `xml:"second"`

	// TimeZoneId

	TimeZoneId *string `xml:"timeZoneId"`
}

// DateTimeValue
//
// Contains a date-time value.
//

type DateTimeValue struct {

	// Value
	//
	// The {@code DateTime} value.
	//

	Value *DateTime `xml:"value"`
}

// DateValue
//
// Contains a date value.
//

type DateValue struct {

	// Value
	//
	// The {@code Date} value.
	//

	Value *Date `xml:"value"`
}

// DeactivateAdUnits
//
// The action used for deactivating {@link AdUnit} objects.
//

type DeactivateAdUnits struct {
}

func NewDeactivateAdUnits() (requestbody.PerformAction, error) {
	return &DeactivateAdUnits{}, nil
}
func (a DeactivateAdUnits) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a DeactivateAdUnits) GetActionType() string {
	return "DeactivateAdUnits"
}

// EntityChildrenLimitReachedError
//
// Lists errors relating to having too many children on an entity.
//

type EntityChildrenLimitReachedError struct {
	Reason string `xml:"reason"`
}

// EntityLimitReachedError
//
// An error that occurs when creating an entity if the limit on the number of allowed entities for
// a network has already been reached.
//

type EntityLimitReachedError struct {
	Reason string `xml:"reason"`
}

// FeatureError
//
// Errors related to feature management.  If you attempt using a feature that is not available to
// the current network you'll receive a FeatureError with the missing feature as the trigger.
//

type FeatureError struct {
	Reason string `xml:"reason"`
}

// FieldPathElement
//
// A segment of a field path. Each dot in a field path defines a new segment.
//

type FieldPathElement struct {

	// Field
	//
	// The name of a field in lower camelcase. (e.g. "biddingStrategy")
	//

	Field *string `xml:"field"`

	// Index
	//
	// For list fields, this is a 0-indexed position in the list. Null for non-list fields.
	//

	Index *int `xml:"index"`
}

// FrequencyCap
//
// Represents a limit on the number of times a single viewer can be exposed to the same {@link
// LineItem} in a specified time period.
//

type FrequencyCap struct {

	// MaxImpressions
	//
	// The maximum number of impressions than can be served to a user within a specified time period.
	//

	MaxImpressions *int `xml:"maxImpressions"`

	// NumTimeUnits
	//
	// The number of {@code FrequencyCap#timeUnit} to represent the total time period.
	//

	NumTimeUnits *int `xml:"numTimeUnits"`

	// TimeUnit
	//
	// The unit of time for specifying the time period.
	//

	TimeUnit *TimeUnit `xml:"timeUnit"`
}

// FrequencyCapError
//
// Lists all errors associated with frequency caps.
//

type FrequencyCapError struct {
	Reason string `xml:"reason"`
}

// InternalApiError
//
// Indicates that a server-side error has occured. {@code InternalApiError}s
// are generally not the result of an invalid request or message sent by the
// client.
//

type InternalApiError struct {
	Reason string `xml:"reason"`
}

// InvalidColorError
//
// A list of all errors associated with a color attribute.
//

type InvalidColorError struct {
	Reason string `xml:"reason"`
}

// InvalidUrlError
//
// Lists all errors associated with URLs.
//

type InvalidUrlError struct {
	Reason string `xml:"reason"`
}

// InventoryUnitError
//
// Lists the generic errors associated with {@link AdUnit} objects.
//

type InventoryUnitError struct {
	Reason string `xml:"reason"`
}

// InventoryUnitRefreshRateError
//
// Lists errors relating to {@link AdUnit#refreshRate}.
//

type InventoryUnitRefreshRateError struct {
	Reason string `xml:"reason"`
}

// AdUnitSize
//
// An {@code AdUnitSize} represents the size of an ad in an ad unit. This also represents the
// environment and companions of a particular ad in an ad unit. In most cases, it is a simple size
// with just a width and a height (sometimes representing an aspect ratio).
//

type AdUnitSize struct {

	// Size
	//
	// The permissible creative size that can be served inside this ad unit.
	//

	Size *Size `xml:"size"`

	// EnvironmentType
	//
	// The environment type of the ad unit size. The default value is {@link EnvironmentType#BROWSER}.
	//

	EnvironmentType *EnvironmentType `xml:"environmentType"`

	// Companions
	//
	// The companions for this ad unit size. Companions are only valid if the environment is {@link
	// EnvironmentType#VIDEO_PLAYER}. If the environment is {@link EnvironmentType#BROWSER} including
	// companions results in an error.
	//

	Companions []*AdUnitSize `xml:"companions"`

	// FullDisplayString
	//
	// The full (including companion sizes, if applicable) display string of the size, e.g. {@code
	// "300x250"} or {@code "300x250v (180x150)"}
	//

	FullDisplayString *string `xml:"fullDisplayString"`

	// IsAudio
	//
	// Whether the inventory size is audio. If set to true, {@code Size} will be set to {@code "1x1"}
	// and {@code EnvironmentType} will be set to {@link EnvironmentType#VIDEO_PLAYER} regardless of
	// user input.
	//

	IsAudio *bool `xml:"isAudio"`
}

// InventoryUnitSizesError
//
// An error specifically for InventoryUnitSizes.
//

type InventoryUnitSizesError struct {
	Reason string `xml:"reason"`
}

// LabelEntityAssociationError
//
// Errors specific to creating label entity associations.
//

type LabelEntityAssociationError struct {
	Reason string `xml:"reason"`
}

// LabelFrequencyCap
//
// A {@code LabelFrequencyCap} assigns a frequency cap to a label. The frequency cap will limit the
// cumulative number of impressions of any ad units with this label that may be shown to a
// particular user over a time unit.
//

type LabelFrequencyCap struct {

	// FrequencyCap
	//
	// The frequency cap to be applied with this label.
	//

	FrequencyCap *FrequencyCap `xml:"frequencyCap"`

	// LabelId
	//
	// ID of the label being capped on the {@link AdUnit}.
	//

	LabelId *int64 `xml:"labelId"`
}

// NotNullError
//
// Caused by supplying a null value for an attribute that cannot be null.
//

type NotNullError struct {
	Reason string `xml:"reason"`
}

// NullError
//
// Errors associated with violation of a NOT NULL check.
//

type NullError struct {
	Reason string `xml:"reason"`
}

// NumberValue
//
// Contains a numeric value.
//

type NumberValue struct {

	// Value
	//
	// The numeric value represented as a string.
	//

	Value *string `xml:"value"`
}

// ParseError
//
// Lists errors related to parsing.
//

type ParseError struct {
	Reason string `xml:"reason"`
}

// PermissionError
//
// Errors related to incorrect permission.
//

type PermissionError struct {
	Reason string `xml:"reason"`
}

// PublisherQueryLanguageContextError
//
// An error that occurs while executing a PQL query contained in
// a {@link Statement} object.
//

type PublisherQueryLanguageContextError struct {
	Reason string `xml:"reason"`
}

// PublisherQueryLanguageSyntaxError
//
// An error that occurs while parsing a PQL query contained in a
// {@link Statement} object.
//

type PublisherQueryLanguageSyntaxError struct {
	Reason string `xml:"reason"`
}

// QuotaError
//
// Describes a client-side error on which a user is attempting
// to perform an action to which they have no quota remaining.
//

type QuotaError struct {
	Reason string `xml:"reason"`
}

// RangeError
//
// A list of all errors associated with the Range constraint.
//

type RangeError struct {
	Reason string `xml:"reason"`
}

// RegExError
//
// Caused by supplying a value for an object attribute that does not conform
// to a documented valid regular expression.
//

type RegExError struct {
	Reason string `xml:"reason"`
}

// RequiredCollectionError
//
// A list of all errors to be used for validating sizes of collections.
//

type RequiredCollectionError struct {
	Reason string `xml:"reason"`
}

// RequiredError
//
// Errors due to missing required field.
//

type RequiredError struct {
	Reason string `xml:"reason"`
}

// RequiredNumberError
//
// A list of all errors to be used in conjunction with required number
// validators.
//

type RequiredNumberError struct {
	Reason string `xml:"reason"`
}

// ServerError
//
// Errors related to the server.
//

type ServerError struct {
	Reason string `xml:"reason"`
}

// SetValue
//
// Contains a set of {@link Value Values}. May not contain duplicates.
//

type SetValue struct {

	// Value
	*Value

	// Values
	//
	// The values. They must all be the same type of {@code Value} and not contain duplicates.
	//

	Values []*Value `xml:"values"`
}

// Size
//
// Represents the dimensions of an {@link AdUnit}, {@link LineItem} or {@link Creative}.
//
// <p>For interstitial size (out-of-page), native, ignored and fluid size, {@link Size} must be 1x1.
//

type Size struct {

	// Width
	//
	// The width of the {@link AdUnit}, {@link LineItem} or {@link Creative}.
	//

	Width *int `xml:"width"`

	// Height
	//
	// The height of the {@link AdUnit}, {@link LineItem} or {@link Creative}.
	//

	Height *int `xml:"height"`

	// IsAspectRatio
	//
	// Whether this size represents an aspect ratio.
	//

	IsAspectRatio *bool `xml:"isAspectRatio"`
}

// SoapRequestHeader
//
// Represents the SOAP request header used by API requests.
//

type SoapRequestHeader struct {

	// NetworkCode
	//
	// The network code to use in the context of a request.
	//

	NetworkCode *string `xml:"networkCode"`

	// ApplicationName
	//
	// The name of client library application.
	//

	ApplicationName *string `xml:"applicationName"`
}

// SoapResponseHeader
//
// Represents the SOAP request header used by API responses.
//

type SoapResponseHeader struct {

	// RequestId

	RequestId *string `xml:"requestId"`

	// ResponseTime

	ResponseTime *int64 `xml:"responseTime"`
}

// Statement
//
// Captures the {@code WHERE}, {@code ORDER BY} and {@code LIMIT} clauses of a
// PQL query. Statements are typically used to retrieve objects of a predefined
// domain type, which makes SELECT clause unnecessary.
// <p>
// An example query text might be {@code "WHERE status = 'ACTIVE' ORDER BY id
// LIMIT 30"}.
// </p>
// <p>
// Statements support bind variables. These are substitutes for literals
// and can be thought of as input parameters to a PQL query.
// </p>
// <p>
// An example of such a query might be {@code "WHERE id = :idValue"}.
// </p>
// <p>
// Statements also support use of the LIKE keyword. This provides wildcard string matching.
// </p>
// <p>
// An example of such a query might be {@code "WHERE name LIKE '%searchString%'"}.
// </p>
// The value for the variable idValue must then be set with an object of type
// {@link Value}, e.g., {@link NumberValue}, {@link TextValue} or
// {@link BooleanValue}.
//

type Statement struct {

	// Query
	//
	// Holds the query in PQL syntax. The syntax is:<br>
	// <code>[WHERE <condition> {[AND | OR] <condition> ...}]</code><br>
	// <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	// <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>
	// <p>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <value></code><br>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <bind variable></code><br>
	// <code><condition> := <property> IN <list></code><br>
	// <code><condition> := <property> IS NULL</code><br>
	// <code><condition> := <property> LIKE <wildcard%match></code><br>
	// <code><bind variable> := :<name></code><br>
	// </p>
	//

	Query *string `xml:"query"`

	// Values
	//
	// Holds keys and values for bind variables and their values. The key is the
	// name of the bind variable. The value is the literal value of the variable.
	// <p>
	// In the example {@code "WHERE status = :bindStatus ORDER BY id LIMIT 30"},
	// the bind variable, represented by {@code :bindStatus} is named {@code
	// bindStatus}, which would also be the parameter map key. The bind variable's
	// value would be represented by a parameter map value of type
	// {@link TextValue}. The final result, for example, would be an entry of
	// {@code "bindStatus" => StringParam("ACTIVE")}.
	// </p>
	//

	Values []*String_ValueMapEntry `xml:"values"`
}

// StatementError
//
// An error that occurs while parsing {@link Statement} objects.
//

type StatementError struct {
	Reason string `xml:"reason"`
}

// StringFormatError
//
// A list of error code for reporting invalid content of input strings.
//

type StringFormatError struct {
	Reason string `xml:"reason"`
}

// StringLengthError
//
// Errors for Strings which do not meet given length constraints.
//

type StringLengthError struct {
	Reason string `xml:"reason"`
}

// String_ValueMapEntry
//
// This represents an entry in a map with a key of type String
// and value of type Value.
//

type String_ValueMapEntry struct {

	// Key

	Key *string `xml:"key"`

	// Value

	Value *Value `xml:"value"`
}

// TeamError
//
// Errors related to a Team.
//

type TeamError struct {
	Reason string `xml:"reason"`
}

// TextValue
//
// Contains a string value.
//

type TextValue struct {

	// Value
	//
	// The string value.
	//

	Value *string `xml:"value"`
}

// TypeError
//
// An error for a field which is an invalid type.
//

type TypeError struct {
	Reason string `xml:"reason"`
}

// UniqueError
//
// An error for a field which must satisfy a uniqueness constraint
//

type UniqueError struct {
	Reason string `xml:"reason"`
}

// UpdateResult
//
// Represents the result of performing an action on objects.
//

type UpdateResult struct {

	// NumChanges
	//
	// The number of objects that were changed as a result of performing the
	// action.
	//

	NumChanges *int `xml:"numChanges"`
}

// Value
//
// {@code Value} represents a value.
//

type Value struct {
}

// AdSenseAccountErrorReasonReason
const (

	// AdSenseAccountErrorReasonReasonAssociateAccountApiError
	//
	// An error occurred while trying to associate an AdSense account with Ad Manager. Unable to
	// create an association with AdSense or Ad Exchange account.
	//
	AdSenseAccountErrorReasonReasonAssociateAccountApiError = "ASSOCIATE_ACCOUNT_API_ERROR"

	// AdSenseAccountErrorReasonReasonGetAdSlotApiError
	//
	// An error occured while trying to get an associated web property's ad slots. Unable to
	// retrieve ad slot information from AdSense or Ad Exchange account.
	//
	AdSenseAccountErrorReasonReasonGetAdSlotApiError = "GET_AD_SLOT_API_ERROR"

	// AdSenseAccountErrorReasonReasonGetChannelApiError
	//
	// An error occurred while trying to get an associated web property's ad channels.
	//
	AdSenseAccountErrorReasonReasonGetChannelApiError = "GET_CHANNEL_API_ERROR"

	// AdSenseAccountErrorReasonReasonGetBulkAccountStatusesApiError
	//
	// An error occured while trying to retrieve account statues from AdSense API. Unable to
	// retrieve account status information. Please try again later.
	//
	AdSenseAccountErrorReasonReasonGetBulkAccountStatusesApiError = "GET_BULK_ACCOUNT_STATUSES_API_ERROR"

	// AdSenseAccountErrorReasonReasonResendVerificationEmailError
	//
	// An error occured while trying to resend the account association verification email. Error
	// resending verification email. Please try again.
	//
	AdSenseAccountErrorReasonReasonResendVerificationEmailError = "RESEND_VERIFICATION_EMAIL_ERROR"

	// AdSenseAccountErrorReasonReasonUnexpectedApiResponseError
	//
	// An error occured while trying to retrieve a response from the AdSense API. There was a
	// problem processing your request. Please try again later.
	//
	AdSenseAccountErrorReasonReasonUnexpectedApiResponseError = "UNEXPECTED_API_RESPONSE_ERROR"

	// AdSenseAccountErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AdSenseAccountErrorReasonReasonUnknown = "UNKNOWN"
)

// AdSenseSettingsAdTypeType
//
// Specifies the type of ads that can be served through this {@link AdUnit}.
type AdSenseSettingsAdType string

const (

	// AdSenseSettingsAdTypeTypeText
	//
	// Allows text-only ads.
	//
	AdSenseSettingsAdTypeTypeText AdSenseSettingsAdType = "TEXT"

	// AdSenseSettingsAdTypeTypeImage
	//
	// Allows image-only ads.
	//
	AdSenseSettingsAdTypeTypeImage AdSenseSettingsAdType = "IMAGE"

	// AdSenseSettingsAdTypeTypeTextAndImage
	//
	// Allows both text and image ads.
	//
	AdSenseSettingsAdTypeTypeTextAndImage AdSenseSettingsAdType = "TEXT_AND_IMAGE"
)

// AdSenseSettingsBorderStyleType
//
// Describes the border of the HTML elements used to surround an ad displayed by the {@link
// AdUnit}.
type AdSenseSettingsBorderStyle string

const (

	// AdSenseSettingsBorderStyleTypeDefault
	//
	// Uses the default border-style of the browser.
	//
	AdSenseSettingsBorderStyleTypeDefault AdSenseSettingsBorderStyle = "DEFAULT"

	// AdSenseSettingsBorderStyleTypeNotRounded
	//
	// Uses a cornered border-style.
	//
	AdSenseSettingsBorderStyleTypeNotRounded AdSenseSettingsBorderStyle = "NOT_ROUNDED"

	// AdSenseSettingsBorderStyleTypeSlightlyRounded
	//
	// Uses a slightly rounded border-style.
	//
	AdSenseSettingsBorderStyleTypeSlightlyRounded AdSenseSettingsBorderStyle = "SLIGHTLY_ROUNDED"

	// AdSenseSettingsBorderStyleTypeVeryRounded
	//
	// Uses a rounded border-style.
	//
	AdSenseSettingsBorderStyleTypeVeryRounded AdSenseSettingsBorderStyle = "VERY_ROUNDED"
)

// AdSenseSettingsFontFamilyType
//
// List of all possible font families.
type AdSenseSettingsFontFamily string

const (

	// AdSenseSettingsFontFamilyTypeDefault
	AdSenseSettingsFontFamilyTypeDefault AdSenseSettingsFontFamily = "DEFAULT"

	// AdSenseSettingsFontFamilyTypeArial
	AdSenseSettingsFontFamilyTypeArial AdSenseSettingsFontFamily = "ARIAL"

	// AdSenseSettingsFontFamilyTypeTahoma
	AdSenseSettingsFontFamilyTypeTahoma AdSenseSettingsFontFamily = "TAHOMA"

	// AdSenseSettingsFontFamilyTypeGeorgia
	AdSenseSettingsFontFamilyTypeGeorgia AdSenseSettingsFontFamily = "GEORGIA"

	// AdSenseSettingsFontFamilyTypeTimes
	AdSenseSettingsFontFamilyTypeTimes AdSenseSettingsFontFamily = "TIMES"

	// AdSenseSettingsFontFamilyTypeVerdana
	AdSenseSettingsFontFamilyTypeVerdana AdSenseSettingsFontFamily = "VERDANA"
)

// AdSenseSettingsFontSizeType
//
// List of all possible font sizes the user can choose.
type AdSenseSettingsFontSize string

const (

	// AdSenseSettingsFontSizeTypeDefault
	AdSenseSettingsFontSizeTypeDefault AdSenseSettingsFontSize = "DEFAULT"

	// AdSenseSettingsFontSizeTypeSmall
	AdSenseSettingsFontSizeTypeSmall AdSenseSettingsFontSize = "SMALL"

	// AdSenseSettingsFontSizeTypeMedium
	AdSenseSettingsFontSizeTypeMedium AdSenseSettingsFontSize = "MEDIUM"

	// AdSenseSettingsFontSizeTypeLarge
	AdSenseSettingsFontSizeTypeLarge AdSenseSettingsFontSize = "LARGE"
)

// AdUnitCodeErrorReasonReason
const (

	// AdUnitCodeErrorReasonReasonInvalidCharacters
	//
	// For {@link AdUnit#adUnitCode}, only alpha-numeric characters,
	// underscores, hyphens, periods, asterisks, double quotes, back slashes,
	// forward slashes, exclamations, left angle brackets, colons and
	// parentheses are allowed.
	//
	AdUnitCodeErrorReasonReasonInvalidCharacters = "INVALID_CHARACTERS"

	// AdUnitCodeErrorReasonReasonInvalidCharactersWhenUtfCharactersAreAllowed
	//
	// For {@link AdUnit#adUnitCode}, only letters, numbers,
	// underscores, hyphens, periods, asterisks, double quotes, back slashes,
	// forward slashes, exclamations, left angle brackets, colons and
	// parentheses are allowed.
	//
	AdUnitCodeErrorReasonReasonInvalidCharactersWhenUtfCharactersAreAllowed = "INVALID_CHARACTERS_WHEN_UTF_CHARACTERS_ARE_ALLOWED"

	// AdUnitCodeErrorReasonReasonInvalidCharactersForLegacyAdExchangeTag
	//
	// For {@link AdUnit#adUnitCode} representing slot codes, only alphanumeric characters,
	// underscores, hyphens, periods and colons are allowed.
	//
	AdUnitCodeErrorReasonReasonInvalidCharactersForLegacyAdExchangeTag = "INVALID_CHARACTERS_FOR_LEGACY_AD_EXCHANGE_TAG"

	// AdUnitCodeErrorReasonReasonLeadingForwardSlash
	//
	// For {@link AdUnit#adUnitCode}, forward slashes are not allowed as
	// the first character.
	//
	AdUnitCodeErrorReasonReasonLeadingForwardSlash = "LEADING_FORWARD_SLASH"

	// AdUnitCodeErrorReasonReasonReservedCode
	//
	// Specific codes matching ca-*pub-*-tag are reserved for "Web Property IUs"
	// generated as part of the SlotCode migration.
	//
	AdUnitCodeErrorReasonReasonReservedCode = "RESERVED_CODE"

	// AdUnitCodeErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AdUnitCodeErrorReasonReasonUnknown = "UNKNOWN"
)

// AdUnitTargetWindowType
//
// Corresponds to an HTML link's {@code target} attribute.
type AdUnitTargetWindow string

const (

	// AdUnitTargetWindowTypeTop
	//
	// Specifies that the link should open in the full body of the page.
	//
	AdUnitTargetWindowTypeTop AdUnitTargetWindow = "TOP"

	// AdUnitTargetWindowTypeBlank
	//
	// Specifies that the link should open in a new window.
	//
	AdUnitTargetWindowTypeBlank AdUnitTargetWindow = "BLANK"
)

// AdUnitHierarchyErrorReasonReason
const (

	// AdUnitHierarchyErrorReasonReasonInvalidDepth
	//
	// The depth of the {@link AdUnit} in the inventory hierarchy is greater
	// than is allowed. The maximum allowed depth is two below the effective
	// root ad unit for Ad Manager 360 accounts and is one level below the
	// effective root ad unit for Ad Manager accounts.
	//
	AdUnitHierarchyErrorReasonReasonInvalidDepth = "INVALID_DEPTH"

	// AdUnitHierarchyErrorReasonReasonInvalidParent
	//
	// The only valid {@link AdUnit#parentId} for an Ad Manager account is the
	// {@link Network#effectiveRootAdUnitId}, Ad Manager 360 accounts can specify an ad unit
	// hierarchy with more than two levels.
	//
	AdUnitHierarchyErrorReasonReasonInvalidParent = "INVALID_PARENT"

	// AdUnitHierarchyErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AdUnitHierarchyErrorReasonReasonUnknown = "UNKNOWN"
)

// ApiVersionErrorReasonReason
const (

	// ApiVersionErrorReasonReasonUpdateToNewerVersion
	//
	// Indicates that the operation is not allowed in the version the request
	// was made in.
	//
	ApiVersionErrorReasonReasonUpdateToNewerVersion = "UPDATE_TO_NEWER_VERSION"

	// ApiVersionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ApiVersionErrorReasonReasonUnknown = "UNKNOWN"
)

// AuthenticationErrorReasonReason
const (

	// AuthenticationErrorReasonReasonAmbiguousSoapRequestHeader
	//
	// The SOAP message contains a request header with an ambiguous definition of the authentication
	// header fields. This means either the {@code authToken} and {@code oAuthToken} fields were
	// both null or both were specified. Exactly one value should be specified with each request.
	//
	AuthenticationErrorReasonReasonAmbiguousSoapRequestHeader = "AMBIGUOUS_SOAP_REQUEST_HEADER"

	// AuthenticationErrorReasonReasonInvalidEmail
	//
	// The login provided is invalid.
	//
	AuthenticationErrorReasonReasonInvalidEmail = "INVALID_EMAIL"

	// AuthenticationErrorReasonReasonAuthenticationFailed
	//
	// Tried to authenticate with provided information, but failed.
	//
	AuthenticationErrorReasonReasonAuthenticationFailed = "AUTHENTICATION_FAILED"

	// AuthenticationErrorReasonReasonInvalidOauthSignature
	//
	// The OAuth provided is invalid.
	//
	AuthenticationErrorReasonReasonInvalidOauthSignature = "INVALID_OAUTH_SIGNATURE"

	// AuthenticationErrorReasonReasonInvalidService
	//
	// The specified service to use was not recognized.
	//
	AuthenticationErrorReasonReasonInvalidService = "INVALID_SERVICE"

	// AuthenticationErrorReasonReasonMissingSoapRequestHeader
	//
	// The SOAP message is missing a request header with an {@code authToken} and optional {@code
	// networkCode}.
	//
	AuthenticationErrorReasonReasonMissingSoapRequestHeader = "MISSING_SOAP_REQUEST_HEADER"

	// AuthenticationErrorReasonReasonMissingAuthenticationHttpHeader
	//
	// The HTTP request is missing a request header with an {@code authToken}
	//
	AuthenticationErrorReasonReasonMissingAuthenticationHttpHeader = "MISSING_AUTHENTICATION_HTTP_HEADER"

	// AuthenticationErrorReasonReasonMissingAuthentication
	//
	// The request is missing an {@code authToken}
	//
	AuthenticationErrorReasonReasonMissingAuthentication = "MISSING_AUTHENTICATION"

	// AuthenticationErrorReasonReasonNetworkApiAccessDisabled
	//
	// The network does not have API access enabled.
	//
	AuthenticationErrorReasonReasonNetworkApiAccessDisabled = "NETWORK_API_ACCESS_DISABLED"

	// AuthenticationErrorReasonReasonNoNetworksToAccess
	//
	// The user is not associated with any network.
	//
	AuthenticationErrorReasonReasonNoNetworksToAccess = "NO_NETWORKS_TO_ACCESS"

	// AuthenticationErrorReasonReasonNetworkNotFound
	//
	// No network for the given {@code networkCode} was found.
	//
	AuthenticationErrorReasonReasonNetworkNotFound = "NETWORK_NOT_FOUND"

	// AuthenticationErrorReasonReasonNetworkCodeRequired
	//
	// The user has access to more than one network, but did not provide a {@code networkCode}.
	//
	AuthenticationErrorReasonReasonNetworkCodeRequired = "NETWORK_CODE_REQUIRED"

	// AuthenticationErrorReasonReasonConnectionError
	//
	// An error happened on the server side during connection to authentication service.
	//
	AuthenticationErrorReasonReasonConnectionError = "CONNECTION_ERROR"

	// AuthenticationErrorReasonReasonGoogleAccountAlreadyAssociatedWithNetwork
	//
	// The user tried to create a test network using an account that already is associated with a
	// network.
	//
	AuthenticationErrorReasonReasonGoogleAccountAlreadyAssociatedWithNetwork = "GOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK"

	// AuthenticationErrorReasonReasonUnderInvestigation
	//
	// The account is blocked and under investigation by the collections team. Please contact Google
	// for more information.
	//
	AuthenticationErrorReasonReasonUnderInvestigation = "UNDER_INVESTIGATION"

	// AuthenticationErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AuthenticationErrorReasonReasonUnknown = "UNKNOWN"
)

// CollectionSizeErrorReasonReason
const (

	// CollectionSizeErrorReasonReasonTooLarge
	CollectionSizeErrorReasonReasonTooLarge = "TOO_LARGE"

	// CollectionSizeErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CollectionSizeErrorReasonReasonUnknown = "UNKNOWN"
)

// CommonErrorReasonReason
//
// Describes reasons for common errors
const (

	// CommonErrorReasonReasonNotFound
	//
	// Indicates that an attempt was made to retrieve an entity that does not
	// exist.
	//
	CommonErrorReasonReasonNotFound = "NOT_FOUND"

	// CommonErrorReasonReasonAlreadyExists
	//
	// Indicates that an attempt was made to create an entity that already
	// exists.
	//
	CommonErrorReasonReasonAlreadyExists = "ALREADY_EXISTS"

	// CommonErrorReasonReasonNotApplicable
	//
	// Indicates that a value is not applicable for given use case.
	//
	CommonErrorReasonReasonNotApplicable = "NOT_APPLICABLE"

	// CommonErrorReasonReasonDuplicateObject
	//
	// Indicates that two elements in the collection were identical.
	//
	CommonErrorReasonReasonDuplicateObject = "DUPLICATE_OBJECT"

	// CommonErrorReasonReasonCannotUpdate
	//
	// Indicates that an attempt was made to change an immutable field.
	//
	CommonErrorReasonReasonCannotUpdate = "CANNOT_UPDATE"

	// CommonErrorReasonReasonUnsupportedOperation
	//
	// Indicates that the requested operation is not supported.
	//
	CommonErrorReasonReasonUnsupportedOperation = "UNSUPPORTED_OPERATION"

	// CommonErrorReasonReasonConcurrentModification
	//
	// Indicates that another request attempted to update the same data in the same network
	// at about the same time. Please wait and try the request again.
	//
	CommonErrorReasonReasonConcurrentModification = "CONCURRENT_MODIFICATION"

	// CommonErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CommonErrorReasonReasonUnknown = "UNKNOWN"
)

// CompanyErrorReasonReason
//
// Enumerates all possible company specific errors.
const (

	// CompanyErrorReasonReasonCannotSetThirdPartyCompanyDueToType
	//
	// Indicates that an attempt was made to set a third party company for a
	// company whose type is not the same as the third party company.
	//
	CompanyErrorReasonReasonCannotSetThirdPartyCompanyDueToType = "CANNOT_SET_THIRD_PARTY_COMPANY_DUE_TO_TYPE"

	// CompanyErrorReasonReasonCannotUpdateCompanyType
	//
	// Indicates that an invalid attempt was made to change a company's type.
	//
	CompanyErrorReasonReasonCannotUpdateCompanyType = "CANNOT_UPDATE_COMPANY_TYPE"

	// CompanyErrorReasonReasonInvalidCompanyType
	//
	// Indicates that this type of company is not supported.
	//
	CompanyErrorReasonReasonInvalidCompanyType = "INVALID_COMPANY_TYPE"

	// CompanyErrorReasonReasonPrimaryContactDoesNotBelongToThisCompany
	//
	// Indicates that an attempt was made to assign a primary contact who
	// does not belong to the specified company.
	//
	CompanyErrorReasonReasonPrimaryContactDoesNotBelongToThisCompany = "PRIMARY_CONTACT_DOES_NOT_BELONG_TO_THIS_COMPANY"

	// CompanyErrorReasonReasonThirdPartyStatsProviderIsWrongRoleType
	//
	// Indicates that the user specified as the third party stats provider
	// is of the wrong role type.  The user must have the third party stats
	// provider role.
	//
	CompanyErrorReasonReasonThirdPartyStatsProviderIsWrongRoleType = "THIRD_PARTY_STATS_PROVIDER_IS_WRONG_ROLE_TYPE"

	// CompanyErrorReasonReasonInvalidLabelAssociation
	//
	// Labels can only be applied to {@link Company.Type#ADVERTISER},
	// {@link Company.Type#HOUSE_ADVERTISER}, and {@link Company.Type#AD_NETWORK} company services.
	//
	CompanyErrorReasonReasonInvalidLabelAssociation = "INVALID_LABEL_ASSOCIATION"

	// CompanyErrorReasonReasonInvalidCompanyTypeForDefaultBillingSetting
	//
	// Indicates that the {@link Company.Type} does not support default billing settings.
	//
	CompanyErrorReasonReasonInvalidCompanyTypeForDefaultBillingSetting = "INVALID_COMPANY_TYPE_FOR_DEFAULT_BILLING_SETTING"

	// CompanyErrorReasonReasonInvalidDefaultBillingSetting
	//
	// Indicates that the format of the default billing setting is wrong.
	//
	CompanyErrorReasonReasonInvalidDefaultBillingSetting = "INVALID_DEFAULT_BILLING_SETTING"

	// CompanyErrorReasonReasonCompanyHasActiveShareAssignments
	//
	// Cannot remove the cross selling config from a company that has active share assignments.
	//
	CompanyErrorReasonReasonCompanyHasActiveShareAssignments = "COMPANY_HAS_ACTIVE_SHARE_ASSIGNMENTS"

	// CompanyErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CompanyErrorReasonReasonUnknown = "UNKNOWN"
)

// CreativeWrapperErrorReasonReason
//
// The reasons for the creative wrapper error.
const (

	// CreativeWrapperErrorReasonReasonLabelAlreadyAssociatedWithCreativeWrapper
	//
	// The label is already associated with a {@link CreativeWrapper}.
	//
	CreativeWrapperErrorReasonReasonLabelAlreadyAssociatedWithCreativeWrapper = "LABEL_ALREADY_ASSOCIATED_WITH_CREATIVE_WRAPPER"

	// CreativeWrapperErrorReasonReasonInvalidLabelType
	//
	// The label type of a creative wrapper must be {@link LabelType#CREATIVE_WRAPPER}.
	//
	CreativeWrapperErrorReasonReasonInvalidLabelType = "INVALID_LABEL_TYPE"

	// CreativeWrapperErrorReasonReasonUnrecognizedMacro
	//
	// A macro used inside the snippet is not recognized.
	//
	CreativeWrapperErrorReasonReasonUnrecognizedMacro = "UNRECOGNIZED_MACRO"

	// CreativeWrapperErrorReasonReasonNeitherHeaderNorFooterSpecified
	//
	// When creating a new creative wrapper, either header or footer should exist.
	//
	CreativeWrapperErrorReasonReasonNeitherHeaderNorFooterSpecified = "NEITHER_HEADER_NOR_FOOTER_SPECIFIED"

	// CreativeWrapperErrorReasonReasonNeitherHeaderNorFooterNorVideoTrackingUrlsSpecified
	//
	// Creative wrapper must have either header and/or footer, or video tracking URLs.
	//
	CreativeWrapperErrorReasonReasonNeitherHeaderNorFooterNorVideoTrackingUrlsSpecified = "NEITHER_HEADER_NOR_FOOTER_NOR_VIDEO_TRACKING_URLS_SPECIFIED"

	// CreativeWrapperErrorReasonReasonCannotUseCreativeWrapperType
	//
	// The network has not been enabled for creating labels of type
	// {@link LabelType#CREATIVE_WRAPPER}.
	//
	CreativeWrapperErrorReasonReasonCannotUseCreativeWrapperType = "CANNOT_USE_CREATIVE_WRAPPER_TYPE"

	// CreativeWrapperErrorReasonReasonCannotUpdateLabelId
	//
	// Cannot update {@link CreativeWrapper#labelId}.
	//
	CreativeWrapperErrorReasonReasonCannotUpdateLabelId = "CANNOT_UPDATE_LABEL_ID"

	// CreativeWrapperErrorReasonReasonCannotApplyToAdUnitWithVideoSizes
	//
	// Cannot apply {@link LabelType#CREATIVE_WRAPPER} labels to an ad unit
	// if it has no descendants with {@link AdUnit#adUnitSizes} of
	// {@code AdUnitSize#environmentType}  as
	// {@link EnvironmentType#BROWSER}.
	//
	CreativeWrapperErrorReasonReasonCannotApplyToAdUnitWithVideoSizes = "CANNOT_APPLY_TO_AD_UNIT_WITH_VIDEO_SIZES"

	// CreativeWrapperErrorReasonReasonCannotApplyToAdUnitWithoutVideoSizes
	//
	// Cannot apply {@link LabelType#CREATIVE_WRAPPER} labels with a {@link
	// CreativeWrapper#VIDEO_TRACKING_URL} type to an ad unit if it has no descendants with {@link
	// AdUnit#adUnitSizes} of {@code AdUnitSize#environmentType} as {@link
	// EnvironmentType#VIDEO_PLAYER}.
	//
	CreativeWrapperErrorReasonReasonCannotApplyToAdUnitWithoutVideoSizes = "CANNOT_APPLY_TO_AD_UNIT_WITHOUT_VIDEO_SIZES"

	// CreativeWrapperErrorReasonReasonCannotApplyToAdUnitWithoutLabelAssociation
	//
	// Cannot apply {@link LabelType#CREATIVE_WRAPPER} labels to an ad unit if the label is not
	// associated with a creative wrapper.
	//
	CreativeWrapperErrorReasonReasonCannotApplyToAdUnitWithoutLabelAssociation = "CANNOT_APPLY_TO_AD_UNIT_WITHOUT_LABEL_ASSOCIATION"

	// CreativeWrapperErrorReasonReasonCannotApplyToMobileAdUnit
	//
	// Cannot apply {@link LabelType#CREATIVE_WRAPPER} labels to an ad unit
	// if {@link AdUnit#targetPlatform} is of type {@code TargetPlatform#MOBILE}
	//
	CreativeWrapperErrorReasonReasonCannotApplyToMobileAdUnit = "CANNOT_APPLY_TO_MOBILE_AD_UNIT"

	// CreativeWrapperErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CreativeWrapperErrorReasonReasonUnknown = "UNKNOWN"
)

// CrossSellErrorReasonReason
//
// The reason of the error.
const (

	// CrossSellErrorReasonReasonCompanyIsNotDistributionPartner
	//
	// A company for cross-sell partner must be of type {@link Company.Type#PARTNER}.
	//
	CrossSellErrorReasonReasonCompanyIsNotDistributionPartner = "COMPANY_IS_NOT_DISTRIBUTION_PARTNER"

	// CrossSellErrorReasonReasonChangingPartnerNetworkIsNotSupported
	//
	// The network code of a cross-sell partner cannot be changed.
	//
	CrossSellErrorReasonReasonChangingPartnerNetworkIsNotSupported = "CHANGING_PARTNER_NETWORK_IS_NOT_SUPPORTED"

	// CrossSellErrorReasonReasonMissingDistributorPartnerName
	//
	// A cross-sell partner must have a partner name.
	//
	CrossSellErrorReasonReasonMissingDistributorPartnerName = "MISSING_DISTRIBUTOR_PARTNER_NAME"

	// CrossSellErrorReasonReasonDistributorNetworkMissingPublisherFeature
	//
	// The cross-sell distributor publisher feature must be enabled.
	//
	CrossSellErrorReasonReasonDistributorNetworkMissingPublisherFeature = "DISTRIBUTOR_NETWORK_MISSING_PUBLISHER_FEATURE"

	// CrossSellErrorReasonReasonContentProviderNetworkMissingPublisherFeature
	//
	// The cross-sell publisher features must be enabled on the partner's network.
	//
	CrossSellErrorReasonReasonContentProviderNetworkMissingPublisherFeature = "CONTENT_PROVIDER_NETWORK_MISSING_PUBLISHER_FEATURE"

	// CrossSellErrorReasonReasonInvalidDistributorPartnerName
	//
	// The cross-sell partner name conflicts with an ad unit name on the partner's network.
	//
	CrossSellErrorReasonReasonInvalidDistributorPartnerName = "INVALID_DISTRIBUTOR_PARTNER_NAME"

	// CrossSellErrorReasonReasonInvalidContentProviderNetwork
	//
	// The network code of a cross-sell partner is invalid.
	//
	CrossSellErrorReasonReasonInvalidContentProviderNetwork = "INVALID_CONTENT_PROVIDER_NETWORK"

	// CrossSellErrorReasonReasonContentProviderNetworkCannotBeActiveNetwork
	//
	// The content provider network must be different than the distributor network.
	//
	CrossSellErrorReasonReasonContentProviderNetworkCannotBeActiveNetwork = "CONTENT_PROVIDER_NETWORK_CANNOT_BE_ACTIVE_NETWORK"

	// CrossSellErrorReasonReasonContentProviderNetworkAlreadyEnabledForCrossSelling
	//
	// The same network code was already enabled for cross-sell in a different company.
	//
	CrossSellErrorReasonReasonContentProviderNetworkAlreadyEnabledForCrossSelling = "CONTENT_PROVIDER_NETWORK_ALREADY_ENABLED_FOR_CROSS_SELLING"

	// CrossSellErrorReasonReasonDistributorRuleViolationError
	//
	// A rule defined by the cross selling distributor has been violated by a line item targeting
	// a shared ad unit. Violating this rule is an error.
	//
	CrossSellErrorReasonReasonDistributorRuleViolationError = "DISTRIBUTOR_RULE_VIOLATION_ERROR"

	// CrossSellErrorReasonReasonDistributorRuleViolationWarning
	//
	// A rule defined by the cross selling distributor has been violated by a line item targeting
	// a shared ad unit. Violating this rule is a warning.
	//
	// <p>By setting {@link LineItem#skipCrossSellingRuleWarningChecks}, the content partner can
	// suppress the warning (and create or save the line item).
	//
	// <p>This flag is available beginning in V201411.
	//
	CrossSellErrorReasonReasonDistributorRuleViolationWarning = "DISTRIBUTOR_RULE_VIOLATION_WARNING"

	// CrossSellErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CrossSellErrorReasonReasonUnknown = "UNKNOWN"
)

// EntityChildrenLimitReachedErrorReasonReason
//
// The reasons for the entity children limit reached error.
const (

	// EntityChildrenLimitReachedErrorReasonReasonLineItemLimitForOrderReached
	//
	// The number of line items on the order exceeds the max number of line items allowed per order
	// in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonLineItemLimitForOrderReached = "LINE_ITEM_LIMIT_FOR_ORDER_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonCreativeAssociationLimitForLineItemReached
	//
	// The number of creatives associated with the line item exceeds the max number of creatives
	// allowed to be associated with a line item in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonCreativeAssociationLimitForLineItemReached = "CREATIVE_ASSOCIATION_LIMIT_FOR_LINE_ITEM_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForPlacementReached
	//
	// The number of ad units on the placement exceeds the max number of ad units
	// allowed per placement in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForPlacementReached = "AD_UNIT_LIMIT_FOR_PLACEMENT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForLineItemReached
	//
	// The number of targeting expressions on the line item exceeds the max number of targeting
	// expressions allowed per line item in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForLineItemReached = "TARGETING_EXPRESSION_LIMIT_FOR_LINE_ITEM_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionSizeLimitReached
	//
	// The size of a single targeting expression tree exceeds the max size allowed by the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionSizeLimitReached = "TARGETING_EXPRESSION_SIZE_LIMIT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonCustomTargetingValuesForKeyLimitReached
	//
	// The number of custom targeting values for the free-form or predefined custom targeting key
	// exceeds the max number allowed.
	//
	EntityChildrenLimitReachedErrorReasonReasonCustomTargetingValuesForKeyLimitReached = "CUSTOM_TARGETING_VALUES_FOR_KEY_LIMIT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForCreativesOnLineItemReached
	//
	// The total number of targeting expressions on the creatives for the line item exceeds
	// the max number allowed per line item in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForCreativesOnLineItemReached = "TARGETING_EXPRESSION_LIMIT_FOR_CREATIVES_ON_LINE_ITEM_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonAttachmentLimitForProposalReached
	//
	// The number of attachments added to the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonAttachmentLimitForProposalReached = "ATTACHMENT_LIMIT_FOR_PROPOSAL_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProposalLineItemLimitForProposalReached
	//
	// The number of proposal line items on the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProposalLineItemLimitForProposalReached = "PROPOSAL_LINE_ITEM_LIMIT_FOR_PROPOSAL_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProductLimitForProductPackageReached
	//
	// The number of product package items on the product package exceeds the max number
	// allowed per product package in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProductLimitForProductPackageReached = "PRODUCT_LIMIT_FOR_PRODUCT_PACKAGE_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProductTemplateAndProductBaseRateLimitForRateCardReached
	//
	// The number of product template and product base rates on the rate card (including excluded
	// product base rates) exceeds the max number allowed per rate card in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProductTemplateAndProductBaseRateLimitForRateCardReached = "PRODUCT_TEMPLATE_AND_PRODUCT_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProductPackageItemBaseRateLimitForRateCardReached
	//
	// The number of product package item base rates on the rate card exceeds the max number
	// allowed per rate card in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProductPackageItemBaseRateLimitForRateCardReached = "PRODUCT_PACKAGE_ITEM_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonPremiumLimitForRateCardReached
	//
	// The number of premiums of the rate card exceeds the max number allowed per rate card
	// in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonPremiumLimitForRateCardReached = "PREMIUM_LIMIT_FOR_RATE_CARD_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForAdExclusionRuleTargetingReached
	//
	// The number of ad units on {@link AdExclusionRule#inventoryTargeting} exceeds the max number
	// of ad units allowed per ad exclusion rule inventory targeting in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForAdExclusionRuleTargetingReached = "AD_UNIT_LIMIT_FOR_AD_EXCLUSION_RULE_TARGETING_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonNativeStyleLimitForNativeAdFormatReached
	//
	// The number of native styles under the native creative template exceeds the
	// max number of native styles allowed per native creative template in the
	// network.
	//
	EntityChildrenLimitReachedErrorReasonReasonNativeStyleLimitForNativeAdFormatReached = "NATIVE_STYLE_LIMIT_FOR_NATIVE_AD_FORMAT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForPresentationAssignmentReached
	//
	// The number of targeting expressions on the native style exceeds the max number of targeting
	// expressions allowed per native style in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForPresentationAssignmentReached = "TARGETING_EXPRESSION_LIMIT_FOR_PRESENTATION_ASSIGNMENT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityChildrenLimitReachedErrorReasonReasonUnknown = "UNKNOWN"
)

// EntityLimitReachedErrorReasonReason
//
// The reasons for the entity limit reached error.
const (

	// EntityLimitReachedErrorReasonReasonCustomTargetingValuesLimitReached
	//
	// The number of custom targeting values exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonCustomTargetingValuesLimitReached = "CUSTOM_TARGETING_VALUES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonAdExclusionRulesLimitReached
	//
	// The number of ad exclusion rules exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonAdExclusionRulesLimitReached = "AD_EXCLUSION_RULES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonFirstPartyAudienceSegmentsLimitReached
	//
	// The number of first party audience segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonFirstPartyAudienceSegmentsLimitReached = "FIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonPlacementsLimitReached
	//
	// The number of active placements exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonPlacementsLimitReached = "PLACEMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonLineItemsLimitReached
	//
	// The number of line items excceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonLineItemsLimitReached = "LINE_ITEMS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonActiveLineItemsLimitReached
	//
	// The number of active line items exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonActiveLineItemsLimitReached = "ACTIVE_LINE_ITEMS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonDaiEncodingProfilesLimitReached
	//
	// The number of not-archived encoding profiles exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonDaiEncodingProfilesLimitReached = "DAI_ENCODING_PROFILES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonTrafficForecastSegmentsLimitReached
	//
	// The number of traffic forecast segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonTrafficForecastSegmentsLimitReached = "TRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonForecastAdjustmentsLimitReached
	//
	// The number of forecast adjustments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonForecastAdjustmentsLimitReached = "FORECAST_ADJUSTMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonActiveExperimentsLimitReached
	//
	// The number of active experiments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonActiveExperimentsLimitReached = "ACTIVE_EXPERIMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonSitesLimitReached
	//
	// The number of sites exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonSitesLimitReached = "SITES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonUserTeamsLimitReached
	//
	// The number of teams on the user exceeds the max number allowed.
	//
	EntityLimitReachedErrorReasonReasonUserTeamsLimitReached = "USER_TEAMS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityLimitReachedErrorReasonReasonUnknown = "UNKNOWN"
)

// EnvironmentType
//
// Enum for the valid environments in which ads can be shown.
type EnvironmentType string

const (

	// EnvironmentTypeBrowser
	//
	// A regular web browser.
	//
	EnvironmentTypeBrowser EnvironmentType = "BROWSER"

	// EnvironmentTypeVideoPlayer
	//
	// Video players.
	//
	EnvironmentTypeVideoPlayer EnvironmentType = "VIDEO_PLAYER"
)

// FeatureErrorReasonReason
const (

	// FeatureErrorReasonReasonMissingFeature
	//
	// A feature is being used that is not enabled on the current network.
	//
	FeatureErrorReasonReasonMissingFeature = "MISSING_FEATURE"

	// FeatureErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FeatureErrorReasonReasonUnknown = "UNKNOWN"
)

// FrequencyCapErrorReasonReason
//
// The reasons for the frequency cap error.
const (

	// FrequencyCapErrorReasonReasonImpressionLimitExceeded
	FrequencyCapErrorReasonReasonImpressionLimitExceeded = "IMPRESSION_LIMIT_EXCEEDED"

	// FrequencyCapErrorReasonReasonImpressionsTooLow
	FrequencyCapErrorReasonReasonImpressionsTooLow = "IMPRESSIONS_TOO_LOW"

	// FrequencyCapErrorReasonReasonRangeLimitExceeded
	FrequencyCapErrorReasonReasonRangeLimitExceeded = "RANGE_LIMIT_EXCEEDED"

	// FrequencyCapErrorReasonReasonRangeTooLow
	FrequencyCapErrorReasonReasonRangeTooLow = "RANGE_TOO_LOW"

	// FrequencyCapErrorReasonReasonDuplicateTimeRange
	FrequencyCapErrorReasonReasonDuplicateTimeRange = "DUPLICATE_TIME_RANGE"

	// FrequencyCapErrorReasonReasonDuplicateTimeUnit
	FrequencyCapErrorReasonReasonDuplicateTimeUnit = "DUPLICATE_TIME_UNIT"

	// FrequencyCapErrorReasonReasonTooManyFrequencyCaps
	FrequencyCapErrorReasonReasonTooManyFrequencyCaps = "TOO_MANY_FREQUENCY_CAPS"

	// FrequencyCapErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FrequencyCapErrorReasonReasonUnknown = "UNKNOWN"
)

// InternalApiErrorReasonReason
//
// The single reason for the internal API error.
const (

	// InternalApiErrorReasonReasonUnexpectedInternalApiError
	//
	// API encountered an unexpected internal error.
	//
	InternalApiErrorReasonReasonUnexpectedInternalApiError = "UNEXPECTED_INTERNAL_API_ERROR"

	// InternalApiErrorReasonReasonTransientError
	//
	// A temporary error occurred during the request. Please retry.
	//
	InternalApiErrorReasonReasonTransientError = "TRANSIENT_ERROR"

	// InternalApiErrorReasonReasonUnknown
	//
	// The cause of the error is not known or only defined in newer versions.
	//
	InternalApiErrorReasonReasonUnknown = "UNKNOWN"

	// InternalApiErrorReasonReasonDowntime
	//
	// The API is currently unavailable for a planned downtime.
	//
	InternalApiErrorReasonReasonDowntime = "DOWNTIME"

	// InternalApiErrorReasonReasonErrorGeneratingResponse
	//
	// Mutate succeeded but server was unable to build response. Client should not retry mutate.
	//
	InternalApiErrorReasonReasonErrorGeneratingResponse = "ERROR_GENERATING_RESPONSE"
)

// InvalidColorErrorReasonReason
const (

	// InvalidColorErrorReasonReasonInvalidFormat
	//
	// The provided value is not a valid hexadecimal color.
	//
	InvalidColorErrorReasonReasonInvalidFormat = "INVALID_FORMAT"

	// InvalidColorErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InvalidColorErrorReasonReasonUnknown = "UNKNOWN"
)

// InvalidUrlErrorReasonReason
const (

	// InvalidUrlErrorReasonReasonIllegalCharacters
	//
	// The URL contains invalid characters.
	//
	InvalidUrlErrorReasonReasonIllegalCharacters = "ILLEGAL_CHARACTERS"

	// InvalidUrlErrorReasonReasonInvalidFormat
	//
	// The format of the URL is not allowed. This could occur for a number of
	// reasons. For example, if an invalid scheme is specified (like "ftp://")
	// or if a port is specified when not required, or if a query was specified
	// when not required.
	//
	InvalidUrlErrorReasonReasonInvalidFormat = "INVALID_FORMAT"

	// InvalidUrlErrorReasonReasonInsecureScheme
	//
	// URL contains insecure scheme.
	//
	InvalidUrlErrorReasonReasonInsecureScheme = "INSECURE_SCHEME"

	// InvalidUrlErrorReasonReasonNoScheme
	//
	// The URL does not contain a scheme.
	//
	InvalidUrlErrorReasonReasonNoScheme = "NO_SCHEME"

	// InvalidUrlErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InvalidUrlErrorReasonReasonUnknown = "UNKNOWN"
)

// InventoryStatus
//
// Represents the status of objects that represent inventory - ad units and
// placements.
type InventoryStatus string

const (

	// InventoryStatusActive
	//
	// The object is active.
	//
	InventoryStatusActive InventoryStatus = "ACTIVE"

	// InventoryStatusInactive
	//
	// The object is no longer active.
	//
	InventoryStatusInactive InventoryStatus = "INACTIVE"

	// InventoryStatusArchived
	//
	// The object has been archived.
	//
	InventoryStatusArchived InventoryStatus = "ARCHIVED"
)

// InventoryUnitErrorReasonReason
//
// Possible reasons for the error.
const (

	// InventoryUnitErrorReasonReasonExplicitTargetingNotAllowed
	//
	// {@link AdUnit#explicitlyTargeted} can be set to {@code true} only in an
	// Ad Manager 360 account.
	//
	InventoryUnitErrorReasonReasonExplicitTargetingNotAllowed = "EXPLICIT_TARGETING_NOT_ALLOWED"

	// InventoryUnitErrorReasonReasonTargetPlatformNotApplicable
	//
	// The specified target platform is not applicable for the inventory unit.
	//
	InventoryUnitErrorReasonReasonTargetPlatformNotApplicable = "TARGET_PLATFORM_NOT_APPLICABLE"

	// InventoryUnitErrorReasonReasonAdsenseCannotBeEnabled
	//
	// AdSense cannot be enabled on this inventory unit if it is disabled for the network.
	//
	InventoryUnitErrorReasonReasonAdsenseCannotBeEnabled = "ADSENSE_CANNOT_BE_ENABLED"

	// InventoryUnitErrorReasonReasonRootUnitCannotBeDeactivated
	//
	// A root unit cannot be deactivated.
	//
	InventoryUnitErrorReasonReasonRootUnitCannotBeDeactivated = "ROOT_UNIT_CANNOT_BE_DEACTIVATED"

	// InventoryUnitErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InventoryUnitErrorReasonReasonUnknown = "UNKNOWN"
)

// InventoryUnitRefreshRateErrorReasonReason
//
// Reasons for the error.
const (

	// InventoryUnitRefreshRateErrorReasonReasonInvalidRange
	//
	// The refresh rate must be between 30 and 120 seconds.
	//
	InventoryUnitRefreshRateErrorReasonReasonInvalidRange = "INVALID_RANGE"

	// InventoryUnitRefreshRateErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InventoryUnitRefreshRateErrorReasonReasonUnknown = "UNKNOWN"
)

// InventoryUnitSizesErrorReasonReason
//
// All possible reasons the error can be thrown.
const (

	// InventoryUnitSizesErrorReasonReasonInvalidSizes
	//
	// A size in the ad unit is too large or too small.
	//
	InventoryUnitSizesErrorReasonReasonInvalidSizes = "INVALID_SIZES"

	// InventoryUnitSizesErrorReasonReasonInvalidSizeForPlatform
	//
	// A size is an aspect ratio, but the ad unit is not a mobile ad unit.
	//
	InventoryUnitSizesErrorReasonReasonInvalidSizeForPlatform = "INVALID_SIZE_FOR_PLATFORM"

	// InventoryUnitSizesErrorReasonReasonVideoFeatureMissing
	//
	// A size is video, but the video feature is not enabled.
	//
	InventoryUnitSizesErrorReasonReasonVideoFeatureMissing = "VIDEO_FEATURE_MISSING"

	// InventoryUnitSizesErrorReasonReasonVideoMobileLineItemFeatureMissing
	//
	// A size is video in a mobile ad unit,
	// but the mobile video feature is not enabled.
	//
	InventoryUnitSizesErrorReasonReasonVideoMobileLineItemFeatureMissing = "VIDEO_MOBILE_LINE_ITEM_FEATURE_MISSING"

	// InventoryUnitSizesErrorReasonReasonInvalidSizeForMaster
	//
	// A size that has companions must have an environment of VIDEO_PLAYER.
	//
	InventoryUnitSizesErrorReasonReasonInvalidSizeForMaster = "INVALID_SIZE_FOR_MASTER"

	// InventoryUnitSizesErrorReasonReasonInvalidSizeForCompanion
	//
	// A size that is a companion must have an environment of BROWSER.
	//
	InventoryUnitSizesErrorReasonReasonInvalidSizeForCompanion = "INVALID_SIZE_FOR_COMPANION"

	// InventoryUnitSizesErrorReasonReasonDuplicateMasterSizes
	//
	// Duplicate video master sizes are not allowed.
	//
	InventoryUnitSizesErrorReasonReasonDuplicateMasterSizes = "DUPLICATE_MASTER_SIZES"

	// InventoryUnitSizesErrorReasonReasonAspectRatioNotSupported
	//
	// A size is an aspect ratio, but aspect ratio sizes are not enabled.
	//
	InventoryUnitSizesErrorReasonReasonAspectRatioNotSupported = "ASPECT_RATIO_NOT_SUPPORTED"

	// InventoryUnitSizesErrorReasonReasonVideoCompanionsNotSupported
	//
	// A video size has companions, but companions are not allowed for the network
	//
	InventoryUnitSizesErrorReasonReasonVideoCompanionsNotSupported = "VIDEO_COMPANIONS_NOT_SUPPORTED"

	// InventoryUnitSizesErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InventoryUnitSizesErrorReasonReasonUnknown = "UNKNOWN"
)

// LabelEntityAssociationErrorReasonReason
//
// The reasons for the target error.
const (

	// LabelEntityAssociationErrorReasonReasonDuplicateAssociation
	//
	// The label has already been attached to the entity.
	//
	LabelEntityAssociationErrorReasonReasonDuplicateAssociation = "DUPLICATE_ASSOCIATION"

	// LabelEntityAssociationErrorReasonReasonInvalidAssociation
	//
	// A label is being applied to an entity that does not support that entity
	// type.
	//
	LabelEntityAssociationErrorReasonReasonInvalidAssociation = "INVALID_ASSOCIATION"

	// LabelEntityAssociationErrorReasonReasonNegationNotAllowed
	//
	// Label negation cannot be applied to the entity type.
	//
	LabelEntityAssociationErrorReasonReasonNegationNotAllowed = "NEGATION_NOT_ALLOWED"

	// LabelEntityAssociationErrorReasonReasonDuplicateAssociationWithNegation
	//
	// The same label is being applied and negated to the same entity.
	//
	LabelEntityAssociationErrorReasonReasonDuplicateAssociationWithNegation = "DUPLICATE_ASSOCIATION_WITH_NEGATION"

	// LabelEntityAssociationErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LabelEntityAssociationErrorReasonReasonUnknown = "UNKNOWN"
)

// NotNullErrorReasonReason
//
// The reasons for the target error.
const (

	// NotNullErrorReasonReasonArg1Null
	//
	// Assuming that a method will not have more than 3 arguments, if it does,
	// return NULL
	//
	NotNullErrorReasonReasonArg1Null = "ARG1_NULL"

	// NotNullErrorReasonReasonArg2Null
	NotNullErrorReasonReasonArg2Null = "ARG2_NULL"

	// NotNullErrorReasonReasonArg3Null
	NotNullErrorReasonReasonArg3Null = "ARG3_NULL"

	// NotNullErrorReasonReasonNull
	NotNullErrorReasonReasonNull = "NULL"

	// NotNullErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NotNullErrorReasonReasonUnknown = "UNKNOWN"
)

// NullErrorReasonReason
//
// The reasons for the validation error.
const (

	// NullErrorReasonReasonNullContent
	//
	// Specified list/container must not contain any null elements
	//
	NullErrorReasonReasonNullContent = "NULL_CONTENT"
)

// ParseErrorReasonReason
//
// The reasons for the target error.
const (

	// ParseErrorReasonReasonUnparsable
	//
	// Indicates an error in parsing an attribute.
	//
	ParseErrorReasonReasonUnparsable = "UNPARSABLE"

	// ParseErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ParseErrorReasonReasonUnknown = "UNKNOWN"
)

// PermissionErrorReasonReason
//
// Describes reasons for permission errors.
const (

	// PermissionErrorReasonReasonPermissionDenied
	//
	// User does not have the required permission for the request.
	//
	PermissionErrorReasonReasonPermissionDenied = "PERMISSION_DENIED"

	// PermissionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PermissionErrorReasonReasonUnknown = "UNKNOWN"
)

// ValueSourceType
//
// Identifies the source of a field's value.
type ValueSourceType string

const (

	// ValueSourceTypeParent
	//
	// The field's value is inherited from the parent object.
	//
	ValueSourceTypeParent ValueSourceType = "PARENT"

	// ValueSourceTypeDirectlySpecified
	//
	// The field's value is user specified and not inherited.
	//
	ValueSourceTypeDirectlySpecified ValueSourceType = "DIRECTLY_SPECIFIED"

	// ValueSourceTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ValueSourceTypeUnknown ValueSourceType = "UNKNOWN"
)

// PublisherQueryLanguageContextErrorReasonReason
//
// The reasons for the target error.
const (

	// PublisherQueryLanguageContextErrorReasonReasonUnexecutable
	//
	// Indicates that there was an error executing the PQL.
	//
	PublisherQueryLanguageContextErrorReasonReasonUnexecutable = "UNEXECUTABLE"

	// PublisherQueryLanguageContextErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageContextErrorReasonReasonUnknown = "UNKNOWN"
)

// PublisherQueryLanguageSyntaxErrorReasonReason
//
// The reasons for the target error.
const (

	// PublisherQueryLanguageSyntaxErrorReasonReasonUnparsable
	//
	// Indicates that there was a PQL syntax error.
	//
	PublisherQueryLanguageSyntaxErrorReasonReasonUnparsable = "UNPARSABLE"

	// PublisherQueryLanguageSyntaxErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageSyntaxErrorReasonReasonUnknown = "UNKNOWN"
)

// QuotaErrorReasonReason
const (

	// QuotaErrorReasonReasonExceededQuota
	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>Another way to mitigate this error is to limit requests to 8 per second for Ad Manager
	// 360 accounts, or 2 per second for Ad Manager accounts. Once again
	// this does not guarantee that every request will succeed, but may help
	// reduce the number of times you receive this error.
	//
	QuotaErrorReasonReasonExceededQuota = "EXCEEDED_QUOTA"

	// QuotaErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	QuotaErrorReasonReasonUnknown = "UNKNOWN"

	// QuotaErrorReasonReasonReportJobLimit
	//
	// This user has exceeded the allowed number of new report requests per hour
	// (this includes both reports run via the UI and reports
	// run via {@link ReportService#runReportJob}).
	// The recommended approach to handle this error is to wait about 10 minutes
	// and then retry the request. Note that this does not guarantee the request
	// will succeed. If it fails again, try increasing the wait time.
	// <p>Another way to mitigate this error is to limit the number of new report
	// requests to 250 per hour per user. Once again, this does not guarantee that
	// every request will succeed, but may help reduce the number of times you
	// receive this error.
	//
	QuotaErrorReasonReasonReportJobLimit = "REPORT_JOB_LIMIT"

	// QuotaErrorReasonReasonSegmentPopulationLimit
	//
	// This network has exceeded the allowed number of identifiers uploaded within a 24 hour period.
	// The recommended approach to handle this error is to wait 30 minutes and then retry the
	// request. Note that this does not guarantee the request will succeed. If it fails again, try
	// increasing the wait time.
	//
	QuotaErrorReasonReasonSegmentPopulationLimit = "SEGMENT_POPULATION_LIMIT"
)

// RangeErrorReasonReason
const (

	// RangeErrorReasonReasonTooHigh
	RangeErrorReasonReasonTooHigh = "TOO_HIGH"

	// RangeErrorReasonReasonTooLow
	RangeErrorReasonReasonTooLow = "TOO_LOW"

	// RangeErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RangeErrorReasonReasonUnknown = "UNKNOWN"
)

// RegExErrorReasonReason
//
// The reasons for the target error.
const (

	// RegExErrorReasonReasonInvalid
	//
	// Invalid value found.
	//
	RegExErrorReasonReasonInvalid = "INVALID"

	// RegExErrorReasonReasonNull
	//
	// Null value found.
	//
	RegExErrorReasonReasonNull = "NULL"

	// RegExErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RegExErrorReasonReasonUnknown = "UNKNOWN"
)

// RequiredCollectionErrorReasonReason
const (

	// RequiredCollectionErrorReasonReasonRequired
	//
	// A required collection is missing.
	//
	RequiredCollectionErrorReasonReasonRequired = "REQUIRED"

	// RequiredCollectionErrorReasonReasonTooLarge
	//
	// Collection size is too large.
	//
	RequiredCollectionErrorReasonReasonTooLarge = "TOO_LARGE"

	// RequiredCollectionErrorReasonReasonTooSmall
	//
	// Collection size is too small.
	//
	RequiredCollectionErrorReasonReasonTooSmall = "TOO_SMALL"

	// RequiredCollectionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredCollectionErrorReasonReasonUnknown = "UNKNOWN"
)

// RequiredErrorReasonReason
//
// The reasons for the target error.
const (

	// RequiredErrorReasonReasonRequired
	//
	// Missing required field.
	//
	RequiredErrorReasonReasonRequired = "REQUIRED"
)

// RequiredNumberErrorReasonReason
//
// Describes reasons for a number to be invalid.
const (

	// RequiredNumberErrorReasonReasonRequired
	RequiredNumberErrorReasonReasonRequired = "REQUIRED"

	// RequiredNumberErrorReasonReasonTooLarge
	RequiredNumberErrorReasonReasonTooLarge = "TOO_LARGE"

	// RequiredNumberErrorReasonReasonTooSmall
	RequiredNumberErrorReasonReasonTooSmall = "TOO_SMALL"

	// RequiredNumberErrorReasonReasonTooLargeWithDetails
	RequiredNumberErrorReasonReasonTooLargeWithDetails = "TOO_LARGE_WITH_DETAILS"

	// RequiredNumberErrorReasonReasonTooSmallWithDetails
	RequiredNumberErrorReasonReasonTooSmallWithDetails = "TOO_SMALL_WITH_DETAILS"

	// RequiredNumberErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredNumberErrorReasonReasonUnknown = "UNKNOWN"
)

// ServerErrorReasonReason
//
// Describes reasons for server errors
const (

	// ServerErrorReasonReasonServerError
	//
	// Indicates that an unexpected error occured.
	//
	ServerErrorReasonReasonServerError = "SERVER_ERROR"

	// ServerErrorReasonReasonServerBusy
	//
	// Indicates that the server is currently experiencing a high load. Please
	// wait and try your request again.
	//
	ServerErrorReasonReasonServerBusy = "SERVER_BUSY"

	// ServerErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ServerErrorReasonReasonUnknown = "UNKNOWN"
)

// SmartSizeMode
//
// Represents smart size modes.
type SmartSizeMode string

const (

	// SmartSizeModeUnknown
	//
	// The value returned if the actual value is not exposed by the requested
	// API version.
	//
	SmartSizeModeUnknown SmartSizeMode = "UNKNOWN"

	// SmartSizeModeNone
	//
	// Fixed size mode (default).
	//
	SmartSizeModeNone SmartSizeMode = "NONE"

	// SmartSizeModeSmartBanner
	//
	// The height is fixed for the request, the width is a range.
	//
	SmartSizeModeSmartBanner SmartSizeMode = "SMART_BANNER"

	// SmartSizeModeDynamicSize
	//
	// Height and width are ranges.
	//
	SmartSizeModeDynamicSize SmartSizeMode = "DYNAMIC_SIZE"
)

// StatementErrorReasonReason
const (

	// StatementErrorReasonReasonVariableNotBoundToValue
	//
	// A bind variable has not been bound to a value.
	//
	StatementErrorReasonReasonVariableNotBoundToValue = "VARIABLE_NOT_BOUND_TO_VALUE"

	// StatementErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StatementErrorReasonReasonUnknown = "UNKNOWN"
)

// StringFormatErrorReasonReason
//
// The reasons for the target error.
const (

	// StringFormatErrorReasonReasonUnknown
	StringFormatErrorReasonReasonUnknown = "UNKNOWN"

	// StringFormatErrorReasonReasonIllegalChars
	//
	// The input string value contains disallowed characters.
	//
	StringFormatErrorReasonReasonIllegalChars = "ILLEGAL_CHARS"

	// StringFormatErrorReasonReasonInvalidFormat
	//
	// The input string value is invalid for the associated field.
	//
	StringFormatErrorReasonReasonInvalidFormat = "INVALID_FORMAT"
)

// StringLengthErrorReasonReason
const (

	// StringLengthErrorReasonReasonTooLong
	StringLengthErrorReasonReasonTooLong = "TOO_LONG"

	// StringLengthErrorReasonReasonTooShort
	StringLengthErrorReasonReasonTooShort = "TOO_SHORT"

	// StringLengthErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StringLengthErrorReasonReasonUnknown = "UNKNOWN"
)

// TeamErrorReasonReason
//
// The reasons for the target error.
const (

	// TeamErrorReasonReasonEntityNotOnUsersTeams
	//
	// User cannot use this entity because it is not on any of the user's teams.
	//
	TeamErrorReasonReasonEntityNotOnUsersTeams = "ENTITY_NOT_ON_USERS_TEAMS"

	// TeamErrorReasonReasonAdUnitsNotOnOrderTeams
	//
	// The targeted or excluded ad unit must be on the order's teams.
	//
	TeamErrorReasonReasonAdUnitsNotOnOrderTeams = "AD_UNITS_NOT_ON_ORDER_TEAMS"

	// TeamErrorReasonReasonPlacementsNotOnOrderTeams
	//
	// The targeted placement must be on the order's teams.
	//
	TeamErrorReasonReasonPlacementsNotOnOrderTeams = "PLACEMENTS_NOT_ON_ORDER_TEAMS"

	// TeamErrorReasonReasonMissingUsersTeam
	//
	// Entity cannot be created because it is not on any of the user's teams.
	//
	TeamErrorReasonReasonMissingUsersTeam = "MISSING_USERS_TEAM"

	// TeamErrorReasonReasonAllTeamAssociationNotAllowed
	//
	// A team that gives access to all entities of a given type cannot be
	// associated with an entity of that type.
	//
	TeamErrorReasonReasonAllTeamAssociationNotAllowed = "ALL_TEAM_ASSOCIATION_NOT_ALLOWED"

	// TeamErrorReasonReasonInvalidTeamAssignment
	//
	// The assignment of team to entities is invalid.
	//
	TeamErrorReasonReasonInvalidTeamAssignment = "INVALID_TEAM_ASSIGNMENT"

	// TeamErrorReasonReasonCannotUpdateInactiveTeam
	//
	// Cannot modify or create a team with an inactive status.
	//
	TeamErrorReasonReasonCannotUpdateInactiveTeam = "CANNOT_UPDATE_INACTIVE_TEAM"

	// TeamErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TeamErrorReasonReasonUnknown = "UNKNOWN"
)

// TimeUnit
//
// Represent the possible time units for frequency capping.
type TimeUnit string

const (

	// TimeUnitMinute
	TimeUnitMinute TimeUnit = "MINUTE"

	// TimeUnitHour
	TimeUnitHour TimeUnit = "HOUR"

	// TimeUnitDay
	TimeUnitDay TimeUnit = "DAY"

	// TimeUnitWeek
	TimeUnitWeek TimeUnit = "WEEK"

	// TimeUnitMonth
	TimeUnitMonth TimeUnit = "MONTH"

	// TimeUnitLifetime
	TimeUnitLifetime TimeUnit = "LIFETIME"

	// TimeUnitPod
	//
	// Per pod of ads in a video stream. Only valid for entities in a
	// {@link EnvironmentType#VIDEO_PLAYER} environment.
	//
	TimeUnitPod TimeUnit = "POD"

	// TimeUnitStream
	//
	// Per video stream. Only valid for entities in a
	// {@link EnvironmentType#VIDEO_PLAYER} environment.
	//
	TimeUnitStream TimeUnit = "STREAM"

	// TimeUnitUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TimeUnitUnknown TimeUnit = "UNKNOWN"
)

// createAdUnits
//
// Creates new {@link AdUnit} objects.
type CreateAdUnits struct {
	AdUnits []*AdUnit `xml:"adUnits"`
}

// createAdUnitsResponse
type CreateAdUnitsResponse struct {
	Rval []*AdUnit `xml:"rval"`
}

// getAdUnitSizesByStatement
//
// Returns a set of all relevant {@link AdUnitSize} objects.
//
// <p>The given {@link Statement} is currently ignored but may be honored in future versions.
type GetAdUnitSizesByStatement struct {
	FilterStatement *Statement `xml:"filterStatement"`
}

// getAdUnitSizesByStatementResponse
type GetAdUnitSizesByStatementResponse struct {
	Rval []*AdUnitSize `xml:"rval"`
}

// getAdUnitsByStatement
//
// Gets a {@link AdUnitPage} of {@link AdUnit} objects that satisfy the given {@link
// Statement#query}. The following fields are supported for filtering:
//
// <table>
// <tr>
// <th scope="col">PQL Property</th> <th scope="col">Object Property</th>
// </tr>
// <tr>
// <td>{@code adUnitCode}</td>
// <td>{@link AdUnit#adUnitCode}</td>
// </tr>
// <tr>
// <td>{@code id}</td>
// <td>{@link AdUnit#id}</td>
// </tr>
// <tr>
// <td>{@code name}</td>
// <td>{@link AdUnit#name}</td>
// </tr>
// <tr>
// <td>{@code parentId}</td>
// <td>{@link AdUnit#parentId}</td>
// </tr>
// <tr>
// <td>{@code status}</td>
// <td>{@link AdUnit#status}</td>
// </tr>
// <tr>
// <td>{@code lastModifiedDateTime}</td>
// <td>{@link AdUnit#lastModifiedDateTime}</td>
// </tr>
// </table>
type GetAdUnitsByStatement struct {
	FilterStatement *Statement `xml:"filterStatement"`
}

// getAdUnitsByStatementResponse
type GetAdUnitsByStatementResponse struct {
	Rval *AdUnitPage `xml:"rval"`
}

// performAdUnitAction
//
// Performs actions on {@link AdUnit} objects that match the given {@link Statement#query}.
type PerformAdUnitAction struct {
	AdUnitAction *AdUnitAction `xml:"adUnitAction"`

	FilterStatement *Statement `xml:"filterStatement"`
}

// performAdUnitActionResponse
type PerformAdUnitActionResponse struct {
	Rval *UpdateResult `xml:"rval"`
}

// updateAdUnits
//
// Updates the specified {@link AdUnit} objects.
type UpdateAdUnits struct {
	AdUnits []*AdUnit `xml:"adUnits"`
}

// updateAdUnitsResponse
type UpdateAdUnitsResponse struct {
	Rval []*AdUnit `xml:"rval"`
}

// RequestHeader
type RequestHeader struct {
}

// ResponseHeader
type ResponseHeader struct {
}
