// Code generated by gamwsdl/main.go. DO NOT EDIT.
package cdnconfiguration

import (
	"github.com/knakazawa99/gam-sdk-go/pkg/gam/requestbody"
	gamxml "github.com/knakazawa99/gam-sdk-go/pkg/xml"
)

// ObjectValue
//
// Contains an object value.
// <p>
// <b>This object is experimental!
// <code>ObjectValue</code> is an experimental, innovative, and rapidly
// changing new feature for Ad Manager. Unfortunately, being on the bleeding edge means that
// we may make backwards-incompatible changes to
// <code>ObjectValue</code>. We will inform the community when this feature
// is no longer experimental.</b>
//

type ObjectValue struct {
}

// ActivateCdnConfigurations
//
// The action used for activating {@link CdnConfiguration} objects.
//

type ActivateCdnConfigurations struct {
}

func NewActivateCdnConfigurations() (requestbody.PerformAction, error) {
	return &ActivateCdnConfigurations{}, nil
}
func (a ActivateCdnConfigurations) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ActivateCdnConfigurations) GetActionType() string {
	return "ActivateCdnConfigurations"
}

// ApiError
//
// The API error base class that provides details about an error that occurred
// while processing a service request.
//
// <p>The OGNL field path is provided for parsers to identify the request data
// element that may have caused the error.</p>
//

type ApiError struct {
	Reason string `xml:"reason"`
}

// ApiException
//
// Exception class for holding a list of service errors.
//

type ApiException struct {
	Reason string `xml:"reason"`
}

// ApiVersionError
//
// Errors related to the usage of API versions.
//

type ApiVersionError struct {
	Reason string `xml:"reason"`
}

// ApplicationException
//
// Base class for exceptions.
//

type ApplicationException struct {
	Reason string `xml:"reason"`
}

// ArchiveCdnConfigurations
//
// The action used for archiving {@link CdnConfiguration} objects.
//

type ArchiveCdnConfigurations struct {
}

func NewArchiveCdnConfigurations() (requestbody.PerformAction, error) {
	return &ArchiveCdnConfigurations{}, nil
}
func (a ArchiveCdnConfigurations) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ArchiveCdnConfigurations) GetActionType() string {
	return "ArchiveCdnConfigurations"
}

// AuthenticationError
//
// An error for an exception that occurred when authenticating.
//

type AuthenticationError struct {
	Reason string `xml:"reason"`
}

// BooleanValue
//
// Contains a boolean value.
//

type BooleanValue struct {

	// Value
	//
	// The boolean value.
	//

	Value *bool `xml:"value"`
}

// CdnConfigurationAction
//
// Represents the actions that can be performed on {@link CdnConfiguration} objects.
//

type CdnConfigurationAction struct {
}

// CdnConfiguration
//
// A {@link CdnConfiguration} encapsulates information about where and how to ingest and deliver
// content enabled for DAI (Dynamic Ad Insertion).
//

type CdnConfiguration struct {

	// Id
	//
	// The unique ID of the {@link CdnConfiguration}. This value is read-only and is assigned by
	// Google.
	//

	Id *int64 `xml:"id"`

	// Name
	//
	// The name of the {@link CdnConfiguration}. This value is required to create a CDN configuration
	// and has a maximum length of 255 characters.
	//

	Name *string `xml:"name"`

	// CdnConfigurationType
	//
	// The type of CDN configuration represented by this {@link CdnConfiguration}. This value is
	// required to create a CDN configuration
	//

	CdnConfigurationType *CdnConfigurationType `xml:"cdnConfigurationType"`

	// SourceContentConfiguration
	//
	// Parameters about this CDN configuration as a source of content. This facilitates fetching the
	// original content for conditioning and delivering the original content as part of a modified
	// stream.
	//

	SourceContentConfiguration *SourceContentConfiguration `xml:"sourceContentConfiguration"`

	// CdnConfigurationStatus
	//
	// The status of the CDN configuration.
	//

	CdnConfigurationStatus *CdnConfigurationStatus `xml:"cdnConfigurationStatus"`
}

// CdnConfigurationError
//
// Errors associated with {@link CdnConfiguration}s.
//

type CdnConfigurationError struct {
	Reason string `xml:"reason"`
}

// CdnConfigurationPage
//
// Captures a page of {@link CdnConfiguration} objects.
//

type CdnConfigurationPage struct {

	// TotalResultSetSize
	//
	// The size of the total result set to which this page belongs.
	//

	TotalResultSetSize *int `xml:"totalResultSetSize"`

	// StartIndex
	//
	// The absolute index in the total result set on which this page begins.
	//

	StartIndex *int `xml:"startIndex"`

	// Results
	//
	// The collection of CDN configurations contained within this page.
	//

	Results []*CdnConfiguration `xml:"results"`
}

// CollectionSizeError
//
// Error for the size of the collection being too large
//

type CollectionSizeError struct {
	Reason string `xml:"reason"`
}

// CommonError
//
// A place for common errors that can be used across services.
//

type CommonError struct {
	Reason string `xml:"reason"`
}

// Date
//
// Represents a date.
//

type Date struct {

	// Year
	//
	// Year (e.g., 2009)
	//

	Year *int `xml:"year"`

	// Month
	//
	// Month (1..12)
	//

	Month *int `xml:"month"`

	// Day
	//
	// Day (1..31)
	//

	Day *int `xml:"day"`
}

// DateTime
//
// Represents a date combined with the time of day.
//

type DateTime struct {

	// Date

	Date *Date `xml:"date"`

	// Hour

	Hour *int `xml:"hour"`

	// Minute

	Minute *int `xml:"minute"`

	// Second

	Second *int `xml:"second"`

	// TimeZoneId

	TimeZoneId *string `xml:"timeZoneId"`
}

// DateTimeValue
//
// Contains a date-time value.
//

type DateTimeValue struct {

	// Value
	//
	// The {@code DateTime} value.
	//

	Value *DateTime `xml:"value"`
}

// DateValue
//
// Contains a date value.
//

type DateValue struct {

	// Value
	//
	// The {@code Date} value.
	//

	Value *Date `xml:"value"`
}

// FeatureError
//
// Errors related to feature management.  If you attempt using a feature that is not available to
// the current network you'll receive a FeatureError with the missing feature as the trigger.
//

type FeatureError struct {
	Reason string `xml:"reason"`
}

// FieldPathElement
//
// A segment of a field path. Each dot in a field path defines a new segment.
//

type FieldPathElement struct {

	// Field
	//
	// The name of a field in lower camelcase. (e.g. "biddingStrategy")
	//

	Field *string `xml:"field"`

	// Index
	//
	// For list fields, this is a 0-indexed position in the list. Null for non-list fields.
	//

	Index *int `xml:"index"`
}

// InternalApiError
//
// Indicates that a server-side error has occured. {@code InternalApiError}s
// are generally not the result of an invalid request or message sent by the
// client.
//

type InternalApiError struct {
	Reason string `xml:"reason"`
}

// InvalidUrlError
//
// Lists all errors associated with URLs.
//

type InvalidUrlError struct {
	Reason string `xml:"reason"`
}

// MediaLocationSettings
//
// Configuration that associates a media location with a security policy and the authentication
// credentials needed to access the content.
//

type MediaLocationSettings struct {

	// Name
	//
	// The name of the media location. This value is read-only and is assigned by Google.
	//

	Name *string `xml:"name"`

	// UrlPrefix
	//
	// The url prefix of the media location. This value is required for a valid media location.
	//

	UrlPrefix *string `xml:"urlPrefix"`

	// SecurityPolicy
	//
	// The security policy and authentication credentials needed to access the content in this media
	// location. This value is required for a valid media location.
	//

	SecurityPolicy *SecurityPolicySettings `xml:"securityPolicy"`
}

// NotNullError
//
// Caused by supplying a null value for an attribute that cannot be null.
//

type NotNullError struct {
	Reason string `xml:"reason"`
}

// NumberValue
//
// Contains a numeric value.
//

type NumberValue struct {

	// Value
	//
	// The numeric value represented as a string.
	//

	Value *string `xml:"value"`
}

// ParseError
//
// Lists errors related to parsing.
//

type ParseError struct {
	Reason string `xml:"reason"`
}

// PermissionError
//
// Errors related to incorrect permission.
//

type PermissionError struct {
	Reason string `xml:"reason"`
}

// PublisherQueryLanguageContextError
//
// An error that occurs while executing a PQL query contained in
// a {@link Statement} object.
//

type PublisherQueryLanguageContextError struct {
	Reason string `xml:"reason"`
}

// PublisherQueryLanguageSyntaxError
//
// An error that occurs while parsing a PQL query contained in a
// {@link Statement} object.
//

type PublisherQueryLanguageSyntaxError struct {
	Reason string `xml:"reason"`
}

// QuotaError
//
// Describes a client-side error on which a user is attempting
// to perform an action to which they have no quota remaining.
//

type QuotaError struct {
	Reason string `xml:"reason"`
}

// RequiredCollectionError
//
// A list of all errors to be used for validating sizes of collections.
//

type RequiredCollectionError struct {
	Reason string `xml:"reason"`
}

// RequiredError
//
// Errors due to missing required field.
//

type RequiredError struct {
	Reason string `xml:"reason"`
}

// SecurityPolicySettings
//
// A set of security requirements to authenticate against in order to access video content.
// Different locations (e.g. different CDNs) can have different security policies.
//

type SecurityPolicySettings struct {

	// SecurityPolicyType
	//
	// Type of security policy. This determines which other fields should be populated. This value is
	// required for a valid security policy.
	//

	SecurityPolicyType *SecurityPolicyType `xml:"securityPolicyType"`

	// TokenAuthenticationKey
	//
	// Shared security key used to generate the Akamai HMAC token for authenticating requests. This
	// field is only applicable when the value of {@link #securityPolicyType} is equal to {@link
	// SecurityPolicyType#AKAMAI} and will be set to null otherwise.
	//
	// <p>This field is required when the {@link CdnConfiguration#cdnConfigurationType} is equal to
	// {@link CdnConfigurationType#LIVE_STREAM_SOURCE_CONTENT} and this {@link SecurityPolicyDto} is
	// being configured for {@link SourceContentConfiguration#ingestSettings}.
	//

	TokenAuthenticationKey *string `xml:"tokenAuthenticationKey"`

	// DisableServerSideUrlSigning
	//
	// Whether the segment URLs should be signed using the {@link #tokenAuthenticationKey} on the
	// server. This is only applicable for delivery media locations that have token authentication
	// enabled.
	//

	DisableServerSideUrlSigning *bool `xml:"disableServerSideUrlSigning"`

	// OriginForwardingType
	//
	// The type of origin forwarding used to support Akamai authentication policies for the master
	// playlist. This field is not applicable to ingest locations, and is only applicable to delivery
	// media locations with the {@link #securityPolicyType} set to {@link SecurityPolicyType#AKAMAI}.
	// If set elsewhere it will be reset to null.
	//

	OriginForwardingType *OriginForwardingType `xml:"originForwardingType"`

	// OriginPathPrefix
	//
	// The origin path prefix provided by the publisher for the master playlist. This field is only
	// applicable for delivery media locations with the value of {@link #originForwardingType} set to
	// {@link OriginForwardingType#CONVENTIONAL}, and will be set to null otherwise.
	//

	OriginPathPrefix *string `xml:"originPathPrefix"`

	// MediaPlaylistOriginForwardingType
	//
	// The type of origin forwarding used to support Akamai authentication policies for media
	// playlists. This setting can only be used with CDN configurations with a {@code
	// cdnConfigurationType} of {@link CdnConfigurationType#LIVE_STREAM_SOURCE_CONTENT}, is not
	// applicable to ingest locations, and is only applicable to delivery media locations with the
	// {@link #securityPolicyType} set to {@link SecurityPolicyType#AKAMAI}. Valid options are {@code
	// OriginForwardingType#NONE} or {@code OriginForwardingType#ORIGIN_PATH}.
	//
	// <p>This setting can only be used with CDN configurations with a {@code cdnConfigurationType} of
	// {@link CdnConfigurationType#LIVE_STREAM_SOURCE_CONTENT}.
	//

	MediaPlaylistOriginForwardingType *OriginForwardingType `xml:"mediaPlaylistOriginForwardingType"`

	// MediaPlaylistOriginPathPrefix
	//
	// The origin path prefix provided by the publisher for the media playlists. This field is only
	// applicable for delivery media locations with the value of {@link
	// #mediaPlaylistOriginForwardingType} set to {@link OriginForwardingType#CONVENTIONAL}, and will
	// be set to null otherwise.
	//

	MediaPlaylistOriginPathPrefix *string `xml:"mediaPlaylistOriginPathPrefix"`

	// KeysetName
	//
	// The name of the EdgeCacheKeyset on the Media CDN configuration that will be used to validate
	// signed requests from DAI to ingest content.
	//

	KeysetName *string `xml:"keysetName"`

	// SignedRequestExpirationTtlSeconds
	//
	// The amount of time in seconds for which a request signed with a short token will be valid. Only
	// required if signedRequestMaximumExpirationTtl has been set in the Media CDN configuration.
	//

	SignedRequestExpirationTtlSeconds *int64 `xml:"signedRequestExpirationTtlSeconds"`
}

// ServerError
//
// Errors related to the server.
//

type ServerError struct {
	Reason string `xml:"reason"`
}

// SetValue
//
// Contains a set of {@link Value Values}. May not contain duplicates.
//

type SetValue struct {

	// Value
	*Value

	// Values
	//
	// The values. They must all be the same type of {@code Value} and not contain duplicates.
	//

	Values []*Value `xml:"values"`
}

// SoapRequestHeader
//
// Represents the SOAP request header used by API requests.
//

type SoapRequestHeader struct {

	// NetworkCode
	//
	// The network code to use in the context of a request.
	//

	NetworkCode *string `xml:"networkCode"`

	// ApplicationName
	//
	// The name of client library application.
	//

	ApplicationName *string `xml:"applicationName"`
}

// SoapResponseHeader
//
// Represents the SOAP request header used by API responses.
//

type SoapResponseHeader struct {

	// RequestId

	RequestId *string `xml:"requestId"`

	// ResponseTime

	ResponseTime *int64 `xml:"responseTime"`
}

// SourceContentConfiguration
//
// Parameters about this CDN configuration as a source of content. This facilitates fetching the
// original content for conditioning and delivering the original content as part of a modified
// stream.
//

type SourceContentConfiguration struct {

	// IngestSettings
	//
	// Configuration for how DAI should ingest media. At ingest time, we match the url prefix of media
	// in a stream's playlist with an ingest location and use the authentication credentials from the
	// corresponding ingest settings to download the media. This value is required for a valid source
	// content configuration.
	//

	IngestSettings *MediaLocationSettings `xml:"ingestSettings"`

	// DefaultDeliverySettings
	//
	// Default configuration for how DAI should deliver the non-modified media segments. At delivery
	// time, we replace the ingest location's url prefix with the delivery location's URL prefix and
	// use the security policy from the delivery settings to determine how DAI needs to deliver the
	// media so that users can access it. This value is required for a valid source content
	// configuration.
	//

	DefaultDeliverySettings *MediaLocationSettings `xml:"defaultDeliverySettings"`
}

// Statement
//
// Captures the {@code WHERE}, {@code ORDER BY} and {@code LIMIT} clauses of a
// PQL query. Statements are typically used to retrieve objects of a predefined
// domain type, which makes SELECT clause unnecessary.
// <p>
// An example query text might be {@code "WHERE status = 'ACTIVE' ORDER BY id
// LIMIT 30"}.
// </p>
// <p>
// Statements support bind variables. These are substitutes for literals
// and can be thought of as input parameters to a PQL query.
// </p>
// <p>
// An example of such a query might be {@code "WHERE id = :idValue"}.
// </p>
// <p>
// Statements also support use of the LIKE keyword. This provides wildcard string matching.
// </p>
// <p>
// An example of such a query might be {@code "WHERE name LIKE '%searchString%'"}.
// </p>
// The value for the variable idValue must then be set with an object of type
// {@link Value}, e.g., {@link NumberValue}, {@link TextValue} or
// {@link BooleanValue}.
//

type Statement struct {

	// Query
	//
	// Holds the query in PQL syntax. The syntax is:<br>
	// <code>[WHERE <condition> {[AND | OR] <condition> ...}]</code><br>
	// <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	// <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>
	// <p>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <value></code><br>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <bind variable></code><br>
	// <code><condition> := <property> IN <list></code><br>
	// <code><condition> := <property> IS NULL</code><br>
	// <code><condition> := <property> LIKE <wildcard%match></code><br>
	// <code><bind variable> := :<name></code><br>
	// </p>
	//

	Query *string `xml:"query"`

	// Values
	//
	// Holds keys and values for bind variables and their values. The key is the
	// name of the bind variable. The value is the literal value of the variable.
	// <p>
	// In the example {@code "WHERE status = :bindStatus ORDER BY id LIMIT 30"},
	// the bind variable, represented by {@code :bindStatus} is named {@code
	// bindStatus}, which would also be the parameter map key. The bind variable's
	// value would be represented by a parameter map value of type
	// {@link TextValue}. The final result, for example, would be an entry of
	// {@code "bindStatus" => StringParam("ACTIVE")}.
	// </p>
	//

	Values []*String_ValueMapEntry `xml:"values"`
}

// StatementError
//
// An error that occurs while parsing {@link Statement} objects.
//

type StatementError struct {
	Reason string `xml:"reason"`
}

// StringFormatError
//
// A list of error code for reporting invalid content of input strings.
//

type StringFormatError struct {
	Reason string `xml:"reason"`
}

// StringLengthError
//
// Errors for Strings which do not meet given length constraints.
//

type StringLengthError struct {
	Reason string `xml:"reason"`
}

// String_ValueMapEntry
//
// This represents an entry in a map with a key of type String
// and value of type Value.
//

type String_ValueMapEntry struct {

	// Key

	Key *string `xml:"key"`

	// Value

	Value *Value `xml:"value"`
}

// TextValue
//
// Contains a string value.
//

type TextValue struct {

	// Value
	//
	// The string value.
	//

	Value *string `xml:"value"`
}

// UpdateResult
//
// Represents the result of performing an action on objects.
//

type UpdateResult struct {

	// NumChanges
	//
	// The number of objects that were changed as a result of performing the
	// action.
	//

	NumChanges *int `xml:"numChanges"`
}

// Value
//
// {@code Value} represents a value.
//

type Value struct {
}

// ApiVersionErrorReasonReason
const (

	// ApiVersionErrorReasonReasonUpdateToNewerVersion
	//
	// Indicates that the operation is not allowed in the version the request
	// was made in.
	//
	ApiVersionErrorReasonReasonUpdateToNewerVersion = "UPDATE_TO_NEWER_VERSION"

	// ApiVersionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ApiVersionErrorReasonReasonUnknown = "UNKNOWN"
)

// AuthenticationErrorReasonReason
const (

	// AuthenticationErrorReasonReasonAmbiguousSoapRequestHeader
	//
	// The SOAP message contains a request header with an ambiguous definition of the authentication
	// header fields. This means either the {@code authToken} and {@code oAuthToken} fields were
	// both null or both were specified. Exactly one value should be specified with each request.
	//
	AuthenticationErrorReasonReasonAmbiguousSoapRequestHeader = "AMBIGUOUS_SOAP_REQUEST_HEADER"

	// AuthenticationErrorReasonReasonInvalidEmail
	//
	// The login provided is invalid.
	//
	AuthenticationErrorReasonReasonInvalidEmail = "INVALID_EMAIL"

	// AuthenticationErrorReasonReasonAuthenticationFailed
	//
	// Tried to authenticate with provided information, but failed.
	//
	AuthenticationErrorReasonReasonAuthenticationFailed = "AUTHENTICATION_FAILED"

	// AuthenticationErrorReasonReasonInvalidOauthSignature
	//
	// The OAuth provided is invalid.
	//
	AuthenticationErrorReasonReasonInvalidOauthSignature = "INVALID_OAUTH_SIGNATURE"

	// AuthenticationErrorReasonReasonInvalidService
	//
	// The specified service to use was not recognized.
	//
	AuthenticationErrorReasonReasonInvalidService = "INVALID_SERVICE"

	// AuthenticationErrorReasonReasonMissingSoapRequestHeader
	//
	// The SOAP message is missing a request header with an {@code authToken} and optional {@code
	// networkCode}.
	//
	AuthenticationErrorReasonReasonMissingSoapRequestHeader = "MISSING_SOAP_REQUEST_HEADER"

	// AuthenticationErrorReasonReasonMissingAuthenticationHttpHeader
	//
	// The HTTP request is missing a request header with an {@code authToken}
	//
	AuthenticationErrorReasonReasonMissingAuthenticationHttpHeader = "MISSING_AUTHENTICATION_HTTP_HEADER"

	// AuthenticationErrorReasonReasonMissingAuthentication
	//
	// The request is missing an {@code authToken}
	//
	AuthenticationErrorReasonReasonMissingAuthentication = "MISSING_AUTHENTICATION"

	// AuthenticationErrorReasonReasonNetworkApiAccessDisabled
	//
	// The network does not have API access enabled.
	//
	AuthenticationErrorReasonReasonNetworkApiAccessDisabled = "NETWORK_API_ACCESS_DISABLED"

	// AuthenticationErrorReasonReasonNoNetworksToAccess
	//
	// The user is not associated with any network.
	//
	AuthenticationErrorReasonReasonNoNetworksToAccess = "NO_NETWORKS_TO_ACCESS"

	// AuthenticationErrorReasonReasonNetworkNotFound
	//
	// No network for the given {@code networkCode} was found.
	//
	AuthenticationErrorReasonReasonNetworkNotFound = "NETWORK_NOT_FOUND"

	// AuthenticationErrorReasonReasonNetworkCodeRequired
	//
	// The user has access to more than one network, but did not provide a {@code networkCode}.
	//
	AuthenticationErrorReasonReasonNetworkCodeRequired = "NETWORK_CODE_REQUIRED"

	// AuthenticationErrorReasonReasonConnectionError
	//
	// An error happened on the server side during connection to authentication service.
	//
	AuthenticationErrorReasonReasonConnectionError = "CONNECTION_ERROR"

	// AuthenticationErrorReasonReasonGoogleAccountAlreadyAssociatedWithNetwork
	//
	// The user tried to create a test network using an account that already is associated with a
	// network.
	//
	AuthenticationErrorReasonReasonGoogleAccountAlreadyAssociatedWithNetwork = "GOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK"

	// AuthenticationErrorReasonReasonUnderInvestigation
	//
	// The account is blocked and under investigation by the collections team. Please contact Google
	// for more information.
	//
	AuthenticationErrorReasonReasonUnderInvestigation = "UNDER_INVESTIGATION"

	// AuthenticationErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AuthenticationErrorReasonReasonUnknown = "UNKNOWN"
)

// CdnConfigurationErrorReasonReason
//
// The reasons for the {@link CdnConfigurationError}.
const (

	// CdnConfigurationErrorReasonReasonUrlShouldNotContainScheme
	//
	// URL prefixes should not contain schemes.
	//
	CdnConfigurationErrorReasonReasonUrlShouldNotContainScheme = "URL_SHOULD_NOT_CONTAIN_SCHEME"

	// CdnConfigurationErrorReasonReasonInvalidDeliveryLocationNames
	//
	// Invalid delivery setting name. Names for new delivery settings must be null or empty. Names
	// for existing delivery settings cannot be modified.
	//
	CdnConfigurationErrorReasonReasonInvalidDeliveryLocationNames = "INVALID_DELIVERY_LOCATION_NAMES"

	// CdnConfigurationErrorReasonReasonCannotArchiveIfUsedByActiveContentSources
	//
	// A CDN configuration cannot be archived if it is used by active content sources.
	//
	CdnConfigurationErrorReasonReasonCannotArchiveIfUsedByActiveContentSources = "CANNOT_ARCHIVE_IF_USED_BY_ACTIVE_CONTENT_SOURCES"

	// CdnConfigurationErrorReasonReasonCannotArchiveIfUsedByActiveLiveStreams
	//
	// A CDN configuration cannot be archived if it is used by active live streams.
	//
	CdnConfigurationErrorReasonReasonCannotArchiveIfUsedByActiveLiveStreams = "CANNOT_ARCHIVE_IF_USED_BY_ACTIVE_LIVE_STREAMS"

	// CdnConfigurationErrorReasonReasonUnsupportedSecurityPolicyType
	//
	// The security policy type is not supported for the current settings.
	//
	CdnConfigurationErrorReasonReasonUnsupportedSecurityPolicyType = "UNSUPPORTED_SECURITY_POLICY_TYPE"

	// CdnConfigurationErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CdnConfigurationErrorReasonReasonUnknown = "UNKNOWN"
)

// CdnConfigurationStatus
//
// Indicates the status of the {@link CdnConfiguration}.
type CdnConfigurationStatus string

const (

	// CdnConfigurationStatusUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CdnConfigurationStatusUnknown CdnConfigurationStatus = "UNKNOWN"

	// CdnConfigurationStatusActive
	//
	// The CDN configuration is in use.
	//
	CdnConfigurationStatusActive CdnConfigurationStatus = "ACTIVE"

	// CdnConfigurationStatusArchived
	//
	// The CDN configuration is no longer used.
	//
	CdnConfigurationStatusArchived CdnConfigurationStatus = "ARCHIVED"
)

// CdnConfigurationType
//
// Indicates the type of CDN configuration for {@link CdnConfiguration}.
type CdnConfigurationType string

const (

	// CdnConfigurationTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CdnConfigurationTypeUnknown CdnConfigurationType = "UNKNOWN"

	// CdnConfigurationTypeLiveStreamSourceContent
	//
	// A configuration that specifies where and how {@link LiveStreamEvent} content should be ingested
	// and delivered.
	//
	CdnConfigurationTypeLiveStreamSourceContent CdnConfigurationType = "LIVE_STREAM_SOURCE_CONTENT"
)

// CollectionSizeErrorReasonReason
const (

	// CollectionSizeErrorReasonReasonTooLarge
	CollectionSizeErrorReasonReasonTooLarge = "TOO_LARGE"

	// CollectionSizeErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CollectionSizeErrorReasonReasonUnknown = "UNKNOWN"
)

// CommonErrorReasonReason
//
// Describes reasons for common errors
const (

	// CommonErrorReasonReasonNotFound
	//
	// Indicates that an attempt was made to retrieve an entity that does not
	// exist.
	//
	CommonErrorReasonReasonNotFound = "NOT_FOUND"

	// CommonErrorReasonReasonAlreadyExists
	//
	// Indicates that an attempt was made to create an entity that already
	// exists.
	//
	CommonErrorReasonReasonAlreadyExists = "ALREADY_EXISTS"

	// CommonErrorReasonReasonNotApplicable
	//
	// Indicates that a value is not applicable for given use case.
	//
	CommonErrorReasonReasonNotApplicable = "NOT_APPLICABLE"

	// CommonErrorReasonReasonDuplicateObject
	//
	// Indicates that two elements in the collection were identical.
	//
	CommonErrorReasonReasonDuplicateObject = "DUPLICATE_OBJECT"

	// CommonErrorReasonReasonCannotUpdate
	//
	// Indicates that an attempt was made to change an immutable field.
	//
	CommonErrorReasonReasonCannotUpdate = "CANNOT_UPDATE"

	// CommonErrorReasonReasonUnsupportedOperation
	//
	// Indicates that the requested operation is not supported.
	//
	CommonErrorReasonReasonUnsupportedOperation = "UNSUPPORTED_OPERATION"

	// CommonErrorReasonReasonConcurrentModification
	//
	// Indicates that another request attempted to update the same data in the same network
	// at about the same time. Please wait and try the request again.
	//
	CommonErrorReasonReasonConcurrentModification = "CONCURRENT_MODIFICATION"

	// CommonErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CommonErrorReasonReasonUnknown = "UNKNOWN"
)

// FeatureErrorReasonReason
const (

	// FeatureErrorReasonReasonMissingFeature
	//
	// A feature is being used that is not enabled on the current network.
	//
	FeatureErrorReasonReasonMissingFeature = "MISSING_FEATURE"

	// FeatureErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FeatureErrorReasonReasonUnknown = "UNKNOWN"
)

// InternalApiErrorReasonReason
//
// The single reason for the internal API error.
const (

	// InternalApiErrorReasonReasonUnexpectedInternalApiError
	//
	// API encountered an unexpected internal error.
	//
	InternalApiErrorReasonReasonUnexpectedInternalApiError = "UNEXPECTED_INTERNAL_API_ERROR"

	// InternalApiErrorReasonReasonTransientError
	//
	// A temporary error occurred during the request. Please retry.
	//
	InternalApiErrorReasonReasonTransientError = "TRANSIENT_ERROR"

	// InternalApiErrorReasonReasonUnknown
	//
	// The cause of the error is not known or only defined in newer versions.
	//
	InternalApiErrorReasonReasonUnknown = "UNKNOWN"

	// InternalApiErrorReasonReasonDowntime
	//
	// The API is currently unavailable for a planned downtime.
	//
	InternalApiErrorReasonReasonDowntime = "DOWNTIME"

	// InternalApiErrorReasonReasonErrorGeneratingResponse
	//
	// Mutate succeeded but server was unable to build response. Client should not retry mutate.
	//
	InternalApiErrorReasonReasonErrorGeneratingResponse = "ERROR_GENERATING_RESPONSE"
)

// InvalidUrlErrorReasonReason
const (

	// InvalidUrlErrorReasonReasonIllegalCharacters
	//
	// The URL contains invalid characters.
	//
	InvalidUrlErrorReasonReasonIllegalCharacters = "ILLEGAL_CHARACTERS"

	// InvalidUrlErrorReasonReasonInvalidFormat
	//
	// The format of the URL is not allowed. This could occur for a number of
	// reasons. For example, if an invalid scheme is specified (like "ftp://")
	// or if a port is specified when not required, or if a query was specified
	// when not required.
	//
	InvalidUrlErrorReasonReasonInvalidFormat = "INVALID_FORMAT"

	// InvalidUrlErrorReasonReasonInsecureScheme
	//
	// URL contains insecure scheme.
	//
	InvalidUrlErrorReasonReasonInsecureScheme = "INSECURE_SCHEME"

	// InvalidUrlErrorReasonReasonNoScheme
	//
	// The URL does not contain a scheme.
	//
	InvalidUrlErrorReasonReasonNoScheme = "NO_SCHEME"

	// InvalidUrlErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InvalidUrlErrorReasonReasonUnknown = "UNKNOWN"
)

// NotNullErrorReasonReason
//
// The reasons for the target error.
const (

	// NotNullErrorReasonReasonArg1Null
	//
	// Assuming that a method will not have more than 3 arguments, if it does,
	// return NULL
	//
	NotNullErrorReasonReasonArg1Null = "ARG1_NULL"

	// NotNullErrorReasonReasonArg2Null
	NotNullErrorReasonReasonArg2Null = "ARG2_NULL"

	// NotNullErrorReasonReasonArg3Null
	NotNullErrorReasonReasonArg3Null = "ARG3_NULL"

	// NotNullErrorReasonReasonNull
	NotNullErrorReasonReasonNull = "NULL"

	// NotNullErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NotNullErrorReasonReasonUnknown = "UNKNOWN"
)

// OriginForwardingType
//
// Indicates the type of origin forwarding used to support Akamai authentication policies for
// {@link LiveStreamEvent}
type OriginForwardingType string

const (

	// OriginForwardingTypeOriginPath
	//
	// Indicates that origin forwarding is set up by passing an originpath query
	// string parameter (necessary for Akamai dynamic packaging to work)
	//
	OriginForwardingTypeOriginPath OriginForwardingType = "ORIGIN_PATH"

	// OriginForwardingTypeConventional
	//
	// Indicates that conventional origin forwarding is used.
	//
	OriginForwardingTypeConventional OriginForwardingType = "CONVENTIONAL"

	// OriginForwardingTypeNone
	//
	// Indicates that origin forwarding is not being used.
	//
	OriginForwardingTypeNone OriginForwardingType = "NONE"

	// OriginForwardingTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API
	// version.
	//
	OriginForwardingTypeUnknown OriginForwardingType = "UNKNOWN"
)

// ParseErrorReasonReason
//
// The reasons for the target error.
const (

	// ParseErrorReasonReasonUnparsable
	//
	// Indicates an error in parsing an attribute.
	//
	ParseErrorReasonReasonUnparsable = "UNPARSABLE"

	// ParseErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ParseErrorReasonReasonUnknown = "UNKNOWN"
)

// PermissionErrorReasonReason
//
// Describes reasons for permission errors.
const (

	// PermissionErrorReasonReasonPermissionDenied
	//
	// User does not have the required permission for the request.
	//
	PermissionErrorReasonReasonPermissionDenied = "PERMISSION_DENIED"

	// PermissionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PermissionErrorReasonReasonUnknown = "UNKNOWN"
)

// PublisherQueryLanguageContextErrorReasonReason
//
// The reasons for the target error.
const (

	// PublisherQueryLanguageContextErrorReasonReasonUnexecutable
	//
	// Indicates that there was an error executing the PQL.
	//
	PublisherQueryLanguageContextErrorReasonReasonUnexecutable = "UNEXECUTABLE"

	// PublisherQueryLanguageContextErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageContextErrorReasonReasonUnknown = "UNKNOWN"
)

// PublisherQueryLanguageSyntaxErrorReasonReason
//
// The reasons for the target error.
const (

	// PublisherQueryLanguageSyntaxErrorReasonReasonUnparsable
	//
	// Indicates that there was a PQL syntax error.
	//
	PublisherQueryLanguageSyntaxErrorReasonReasonUnparsable = "UNPARSABLE"

	// PublisherQueryLanguageSyntaxErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageSyntaxErrorReasonReasonUnknown = "UNKNOWN"
)

// QuotaErrorReasonReason
const (

	// QuotaErrorReasonReasonExceededQuota
	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>Another way to mitigate this error is to limit requests to 8 per second for Ad Manager
	// 360 accounts, or 2 per second for Ad Manager accounts. Once again
	// this does not guarantee that every request will succeed, but may help
	// reduce the number of times you receive this error.
	//
	QuotaErrorReasonReasonExceededQuota = "EXCEEDED_QUOTA"

	// QuotaErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	QuotaErrorReasonReasonUnknown = "UNKNOWN"

	// QuotaErrorReasonReasonReportJobLimit
	//
	// This user has exceeded the allowed number of new report requests per hour
	// (this includes both reports run via the UI and reports
	// run via {@link ReportService#runReportJob}).
	// The recommended approach to handle this error is to wait about 10 minutes
	// and then retry the request. Note that this does not guarantee the request
	// will succeed. If it fails again, try increasing the wait time.
	// <p>Another way to mitigate this error is to limit the number of new report
	// requests to 250 per hour per user. Once again, this does not guarantee that
	// every request will succeed, but may help reduce the number of times you
	// receive this error.
	//
	QuotaErrorReasonReasonReportJobLimit = "REPORT_JOB_LIMIT"

	// QuotaErrorReasonReasonSegmentPopulationLimit
	//
	// This network has exceeded the allowed number of identifiers uploaded within a 24 hour period.
	// The recommended approach to handle this error is to wait 30 minutes and then retry the
	// request. Note that this does not guarantee the request will succeed. If it fails again, try
	// increasing the wait time.
	//
	QuotaErrorReasonReasonSegmentPopulationLimit = "SEGMENT_POPULATION_LIMIT"
)

// RequiredCollectionErrorReasonReason
const (

	// RequiredCollectionErrorReasonReasonRequired
	//
	// A required collection is missing.
	//
	RequiredCollectionErrorReasonReasonRequired = "REQUIRED"

	// RequiredCollectionErrorReasonReasonTooLarge
	//
	// Collection size is too large.
	//
	RequiredCollectionErrorReasonReasonTooLarge = "TOO_LARGE"

	// RequiredCollectionErrorReasonReasonTooSmall
	//
	// Collection size is too small.
	//
	RequiredCollectionErrorReasonReasonTooSmall = "TOO_SMALL"

	// RequiredCollectionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredCollectionErrorReasonReasonUnknown = "UNKNOWN"
)

// RequiredErrorReasonReason
//
// The reasons for the target error.
const (

	// RequiredErrorReasonReasonRequired
	//
	// Missing required field.
	//
	RequiredErrorReasonReasonRequired = "REQUIRED"
)

// SecurityPolicyType
//
// Indicates the type of security policy associated with access to a CDN. Different security
// policies require different parameters in a {@link SecurityPolicy}.
type SecurityPolicyType string

const (

	// SecurityPolicyTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	SecurityPolicyTypeUnknown SecurityPolicyType = "UNKNOWN"

	// SecurityPolicyTypeNone
	//
	// Indicates that no authentication is necessary.
	//
	SecurityPolicyTypeNone SecurityPolicyType = "NONE"

	// SecurityPolicyTypeAkamai
	//
	// Security policy for accessing content on the Akamai CDN.
	//
	SecurityPolicyTypeAkamai SecurityPolicyType = "AKAMAI"

	// SecurityPolicyTypeCloudMedia
	//
	// Security policy for access content on Google Cloud Media CDN.
	//
	SecurityPolicyTypeCloudMedia SecurityPolicyType = "CLOUD_MEDIA"
)

// ServerErrorReasonReason
//
// Describes reasons for server errors
const (

	// ServerErrorReasonReasonServerError
	//
	// Indicates that an unexpected error occured.
	//
	ServerErrorReasonReasonServerError = "SERVER_ERROR"

	// ServerErrorReasonReasonServerBusy
	//
	// Indicates that the server is currently experiencing a high load. Please
	// wait and try your request again.
	//
	ServerErrorReasonReasonServerBusy = "SERVER_BUSY"

	// ServerErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ServerErrorReasonReasonUnknown = "UNKNOWN"
)

// StatementErrorReasonReason
const (

	// StatementErrorReasonReasonVariableNotBoundToValue
	//
	// A bind variable has not been bound to a value.
	//
	StatementErrorReasonReasonVariableNotBoundToValue = "VARIABLE_NOT_BOUND_TO_VALUE"

	// StatementErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StatementErrorReasonReasonUnknown = "UNKNOWN"
)

// StringFormatErrorReasonReason
//
// The reasons for the target error.
const (

	// StringFormatErrorReasonReasonUnknown
	StringFormatErrorReasonReasonUnknown = "UNKNOWN"

	// StringFormatErrorReasonReasonIllegalChars
	//
	// The input string value contains disallowed characters.
	//
	StringFormatErrorReasonReasonIllegalChars = "ILLEGAL_CHARS"

	// StringFormatErrorReasonReasonInvalidFormat
	//
	// The input string value is invalid for the associated field.
	//
	StringFormatErrorReasonReasonInvalidFormat = "INVALID_FORMAT"
)

// StringLengthErrorReasonReason
const (

	// StringLengthErrorReasonReasonTooLong
	StringLengthErrorReasonReasonTooLong = "TOO_LONG"

	// StringLengthErrorReasonReasonTooShort
	StringLengthErrorReasonReasonTooShort = "TOO_SHORT"

	// StringLengthErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StringLengthErrorReasonReasonUnknown = "UNKNOWN"
)

// createCdnConfigurations
//
// Creates new {@link CdnConfiguration} objects.
type CreateCdnConfigurations struct {
	CdnConfigurations []*CdnConfiguration `xml:"cdnConfigurations"`
}

// createCdnConfigurationsResponse
type CreateCdnConfigurationsResponse struct {
	Rval []*CdnConfiguration `xml:"rval"`
}

// getCdnConfigurationsByStatement
//
// Gets a {@link CdnConfigurationPage} of {@link CdnConfiguration} objects that satisfy the given
// {@link Statement#query}. Currently only CDN Configurations of type {@link
// CdnConfigurationType#LIVE_STREAM_SOURCE_CONTENT} will be returned. The following fields are
// supported for filtering:
//
// <table>
// <tr>
// <th scope="col">PQL Property</th> <th scope="col">Object Property</th>
// </tr>
// <tr>
// <td>{@code id}</td>
// <td>{@link CdnConfiguration#id}</td>
// </tr>
// <tr>
// <td>{@code name}</td>
// <td>{@link CdnConfiguration#name}</td>
// </tr>
// </table>
type GetCdnConfigurationsByStatement struct {
	Statement *Statement `xml:"statement"`
}

// getCdnConfigurationsByStatementResponse
type GetCdnConfigurationsByStatementResponse struct {
	Rval *CdnConfigurationPage `xml:"rval"`
}

// performCdnConfigurationAction
//
// Performs actions on {@link CdnConfiguration} objects that match the given {@link
// Statement#query}.
type PerformCdnConfigurationAction struct {
	CdnConfigurationAction *CdnConfigurationAction `xml:"cdnConfigurationAction"`

	FilterStatement *Statement `xml:"filterStatement"`
}

// performCdnConfigurationActionResponse
type PerformCdnConfigurationActionResponse struct {
	Rval *UpdateResult `xml:"rval"`
}

// updateCdnConfigurations
//
// Updates the specified {@link CdnConfiguration} objects.
type UpdateCdnConfigurations struct {
	CdnConfigurations []*CdnConfiguration `xml:"cdnConfigurations"`
}

// updateCdnConfigurationsResponse
type UpdateCdnConfigurationsResponse struct {
	Rval []*CdnConfiguration `xml:"rval"`
}

// RequestHeader
type RequestHeader struct {
}

// ResponseHeader
type ResponseHeader struct {
}
