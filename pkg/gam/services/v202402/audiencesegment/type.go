// Code generated by gamwsdl/main.go. DO NOT EDIT.
package audiencesegment

import (
	"github.com/knakazawa99/gam-sdk-go/pkg/gam/requestbody"
	gamxml "github.com/knakazawa99/gam-sdk-go/pkg/xml"
)

// ObjectValue
//
// Contains an object value.
// <p>
// <b>This object is experimental!
// <code>ObjectValue</code> is an experimental, innovative, and rapidly
// changing new feature for Ad Manager. Unfortunately, being on the bleeding edge means that
// we may make backwards-incompatible changes to
// <code>ObjectValue</code>. We will inform the community when this feature
// is no longer experimental.</b>
//

type ObjectValue struct {
}

// ActivateAudienceSegments
//
// Action that can be performed on {@link FirstPartyAudienceSegment} objects to activate them.
//

type ActivateAudienceSegments struct {
}

func NewActivateAudienceSegments() (requestbody.PerformAction, error) {
	return &ActivateAudienceSegments{}, nil
}
func (a ActivateAudienceSegments) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ActivateAudienceSegments) GetActionType() string {
	return "ActivateAudienceSegments"
}

// AdUnitTargeting
//
// Represents targeted or excluded ad units.
//

type AdUnitTargeting struct {

	// AdUnitId
	//
	// Included or excluded ad unit id.
	//

	AdUnitId *string `xml:"adUnitId"`

	// IncludeDescendants
	//
	// Whether or not all descendants are included (or excluded) as part of including (or excluding)
	// this ad unit. By default, the value is {@code true} which means targeting this ad unit will
	// target all of its descendants.
	//

	IncludeDescendants *bool `xml:"includeDescendants"`
}

// ApiError
//
// The API error base class that provides details about an error that occurred
// while processing a service request.
//
// <p>The OGNL field path is provided for parsers to identify the request data
// element that may have caused the error.</p>
//

type ApiError struct {
	Reason string `xml:"reason"`
}

// ApiException
//
// Exception class for holding a list of service errors.
//

type ApiException struct {
	Reason string `xml:"reason"`
}

// ApiVersionError
//
// Errors related to the usage of API versions.
//

type ApiVersionError struct {
	Reason string `xml:"reason"`
}

// ApplicationException
//
// Base class for exceptions.
//

type ApplicationException struct {
	Reason string `xml:"reason"`
}

// ApproveAudienceSegments
//
// Action that can be performed on {@link ThirdPartyAudienceSegment} objects to approve them.
//

type ApproveAudienceSegments struct {
}

func NewApproveAudienceSegments() (requestbody.PerformAction, error) {
	return &ApproveAudienceSegments{}, nil
}
func (a ApproveAudienceSegments) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a ApproveAudienceSegments) GetActionType() string {
	return "ApproveAudienceSegments"
}

// AudienceSegmentDataProvider
//
// Data provider that owns this segment. For a {@link FirstPartyAudienceSegment}, it would be the
// publisher network. For a {@link SharedAudienceSegment} or a {@link ThirdPartyAudienceSegment}, it
// would be the entity that provides that {@link AudienceSegment}.
//

type AudienceSegmentDataProvider struct {

	// Name
	//
	// Name of the data provider. This attribute is readonly and is assigned by Google.
	//

	Name *string `xml:"name"`
}

// AudienceSegmentPage
//
// Represents a page of {@link AudienceSegment} objects.
//

type AudienceSegmentPage struct {

	// TotalResultSetSize
	//
	// The size of the total result set to which this page belongs.
	//

	TotalResultSetSize *int `xml:"totalResultSetSize"`

	// StartIndex
	//
	// The absolute index in the total result set on which this page begins.
	//

	StartIndex *int `xml:"startIndex"`

	// Results
	//
	// The collection of audience segments contained within this page.
	//

	Results []*AudienceSegment `xml:"results"`
}

// AuthenticationError
//
// An error for an exception that occurred when authenticating.
//

type AuthenticationError struct {
	Reason string `xml:"reason"`
}

// FirstPartyAudienceSegment
//
// A {@link FirstPartyAudienceSegment} is an {@link AudienceSegment} owned by the publisher network.
//

type FirstPartyAudienceSegment struct {
}

// BooleanValue
//
// Contains a boolean value.
//

type BooleanValue struct {

	// Value
	//
	// The boolean value.
	//

	Value *bool `xml:"value"`
}

// CollectionSizeError
//
// Error for the size of the collection being too large
//

type CollectionSizeError struct {
	Reason string `xml:"reason"`
}

// CommonError
//
// A place for common errors that can be used across services.
//

type CommonError struct {
	Reason string `xml:"reason"`
}

// CustomCriteria
//
// A {@link CustomCriteria} object is used to perform custom criteria targeting on custom targeting
// keys of type {@link CustomTargetingKey.Type#PREDEFINED} or {@link
// CustomTargetingKey.Type#FREEFORM}.
//

type CustomCriteria struct {

	// CustomCriteriaLeaf
	*CustomCriteriaLeaf

	// KeyId
	//
	// The {@link CustomTargetingKey#id} of the {@link CustomTargetingKey} object that was created
	// using {@link CustomTargetingService}. This attribute is required.
	//

	KeyId *int64 `xml:"keyId"`

	// ValueIds
	//
	// The ids of {@link CustomTargetingValue} objects to target the custom targeting key with id
	// {@link CustomCriteria#keyId}. This attribute is required.
	//

	ValueIds []*int64 `xml:"valueIds"`

	// Operator
	//
	// The comparison operator. This attribute is required.
	//

	Operator *CustomCriteriaComparisonOperator `xml:"operator"`
}

// CustomCriteriaSet
//
// A {@link CustomCriteriaSet} comprises of a set of {@link CustomCriteriaNode} objects combined by
// the {@link CustomCriteriaSet.LogicalOperator#logicalOperator}. The custom criteria targeting tree
// is subject to the rules defined on {@link Targeting#customTargeting}.
//

type CustomCriteriaSet struct {

	// CustomCriteriaNode
	*CustomCriteriaNode

	// LogicalOperator
	//
	// The logical operator to be applied to {@link CustomCriteriaSet#children}. This attribute is
	// required.
	// <span class="constraint Required">This attribute is required.</span>
	//

	LogicalOperator *CustomCriteriaSetLogicalOperator `xml:"logicalOperator"`

	// Children
	//
	// The custom criteria. This attribute is required.
	//

	Children []*CustomCriteriaNode `xml:"children"`
}

// CmsMetadataCriteria
//
// A {@code CmsMetadataCriteria} object is used to target {@code CmsMetadataValue} objects.
//

type CmsMetadataCriteria struct {

	// CustomCriteriaLeaf
	*CustomCriteriaLeaf

	// Operator
	//
	// The comparison operator. This attribute is required.
	//

	Operator *CmsMetadataCriteriaComparisonOperator `xml:"operator"`

	// CmsMetadataValueIds
	//
	// The ids of {@link CmsMetadataValue} objects used to target CMS metadata. This attribute is
	// required.
	//

	CmsMetadataValueIds []*int64 `xml:"cmsMetadataValueIds"`
}

// CustomTargetingError
//
// Lists all errors related to {@link CustomTargetingKey} and
// {@link CustomTargetingValue} objects.
//

type CustomTargetingError struct {
	Reason string `xml:"reason"`
}

// CustomCriteriaLeaf
//
// A {@link CustomCriteriaLeaf} object represents a generic leaf of {@link CustomCriteria} tree
// structure.
//

type CustomCriteriaLeaf struct {
}

// CustomCriteriaNode
//
// A {@link CustomCriteriaNode} is a node in the custom targeting tree. A custom criteria node can
// either be a {@link CustomCriteriaSet} (a non-leaf node) or a {@link CustomCriteria} (a leaf
// node). The custom criteria targeting tree is subject to the rules defined on {@link
// Targeting#customTargeting}.
//

type CustomCriteriaNode struct {
}

// AudienceSegmentCriteria
//
// An {@link AudienceSegmentCriteria} object is used to target {@link AudienceSegment} objects.
//

type AudienceSegmentCriteria struct {

	// CustomCriteriaLeaf
	*CustomCriteriaLeaf

	// Operator
	//
	// The comparison operator. This attribute is required.
	//

	Operator *AudienceSegmentCriteriaComparisonOperator `xml:"operator"`

	// AudienceSegmentIds
	//
	// The ids of {@link AudienceSegment} objects used to target audience segments. This attribute is
	// required.
	//

	AudienceSegmentIds []*int64 `xml:"audienceSegmentIds"`
}

// Date
//
// Represents a date.
//

type Date struct {

	// Year
	//
	// Year (e.g., 2009)
	//

	Year *int `xml:"year"`

	// Month
	//
	// Month (1..12)
	//

	Month *int `xml:"month"`

	// Day
	//
	// Day (1..31)
	//

	Day *int `xml:"day"`
}

// DateTime
//
// Represents a date combined with the time of day.
//

type DateTime struct {

	// Date

	Date *Date `xml:"date"`

	// Hour

	Hour *int `xml:"hour"`

	// Minute

	Minute *int `xml:"minute"`

	// Second

	Second *int `xml:"second"`

	// TimeZoneId

	TimeZoneId *string `xml:"timeZoneId"`
}

// DateTimeValue
//
// Contains a date-time value.
//

type DateTimeValue struct {

	// Value
	//
	// The {@code DateTime} value.
	//

	Value *DateTime `xml:"value"`
}

// DateValue
//
// Contains a date value.
//

type DateValue struct {

	// Value
	//
	// The {@code Date} value.
	//

	Value *Date `xml:"value"`
}

// DeactivateAudienceSegments
//
// Action that can be performed on {@link FirstPartyAudienceSegment} objects to deactivate them.
//

type DeactivateAudienceSegments struct {
}

func NewDeactivateAudienceSegments() (requestbody.PerformAction, error) {
	return &DeactivateAudienceSegments{}, nil
}
func (a DeactivateAudienceSegments) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a DeactivateAudienceSegments) GetActionType() string {
	return "DeactivateAudienceSegments"
}

// EntityChildrenLimitReachedError
//
// Lists errors relating to having too many children on an entity.
//

type EntityChildrenLimitReachedError struct {
	Reason string `xml:"reason"`
}

// EntityLimitReachedError
//
// An error that occurs when creating an entity if the limit on the number of allowed entities for
// a network has already been reached.
//

type EntityLimitReachedError struct {
	Reason string `xml:"reason"`
}

// ThirdPartyAudienceSegment
//
// A {@link ThirdPartyAudienceSegment} is an {@link AudienceSegment} owned by a data provider and
// licensed to the Ad Manager publisher.
//

type ThirdPartyAudienceSegment struct {

	// AudienceSegment
	*AudienceSegment

	// ApprovalStatus
	//
	// Specifies if the publisher has approved or rejected the segment.
	//

	ApprovalStatus *AudienceSegmentApprovalStatus `xml:"approvalStatus"`

	// Cost
	//
	// Specifies CPM cost for the given segment. This attribute is readonly and is assigned by the
	// data provider.
	//
	// <p>The CPM cost comes from the active pricing, if there is one; otherwise it comes from the
	// latest pricing.
	//

	Cost *Money `xml:"cost"`

	// LicenseType
	//
	// Specifies the license type of the external segment. This attribute is read-only.
	//

	LicenseType *LicenseType `xml:"licenseType"`

	// StartDateTime
	//
	// Specifies the date and time at which this segment becomes available for use. This attribute is
	// readonly and is assigned by the data provider.
	//

	StartDateTime *DateTime `xml:"startDateTime"`

	// EndDateTime
	//
	// Specifies the date and time at which this segment ceases to be available for use. This
	// attribute is readonly and is assigned by the data provider.
	//

	EndDateTime *DateTime `xml:"endDateTime"`
}

// FeatureError
//
// Errors related to feature management.  If you attempt using a feature that is not available to
// the current network you'll receive a FeatureError with the missing feature as the trigger.
//

type FeatureError struct {
	Reason string `xml:"reason"`
}

// FieldPathElement
//
// A segment of a field path. Each dot in a field path defines a new segment.
//

type FieldPathElement struct {

	// Field
	//
	// The name of a field in lower camelcase. (e.g. "biddingStrategy")
	//

	Field *string `xml:"field"`

	// Index
	//
	// For list fields, this is a 0-indexed position in the list. Null for non-list fields.
	//

	Index *int `xml:"index"`
}

// InternalApiError
//
// Indicates that a server-side error has occured. {@code InternalApiError}s
// are generally not the result of an invalid request or message sent by the
// client.
//

type InternalApiError struct {
	Reason string `xml:"reason"`
}

// InventoryTargeting
//
// A collection of targeted and excluded ad units and placements.
//

type InventoryTargeting struct {

	// TargetedAdUnits
	//
	// A list of targeted {@link AdUnitTargeting}.
	//

	TargetedAdUnits []*AdUnitTargeting `xml:"targetedAdUnits"`

	// ExcludedAdUnits
	//
	// A list of excluded {@link AdUnitTargeting}.
	//

	ExcludedAdUnits []*AdUnitTargeting `xml:"excludedAdUnits"`

	// TargetedPlacementIds
	//
	// A list of targeted {@link Placement} ids.
	//

	TargetedPlacementIds []*int64 `xml:"targetedPlacementIds"`
}

// Money
//
// Represents a money amount.
//

type Money struct {

	// CurrencyCode
	//
	// Three letter currency code in string format.
	//

	CurrencyCode *string `xml:"currencyCode"`

	// MicroAmount
	//
	// Money values are always specified in terms of micros which are a millionth
	// of the fundamental currency unit. For US dollars, $1 is 1,000,000 micros.
	//

	MicroAmount *int64 `xml:"microAmount"`
}

// NonRuleBasedFirstPartyAudienceSegment
//
// A {@link NonRuleBasedFirstPartyAudienceSegment} is a {@link FirstPartyAudienceSegment} owned by
// the publisher network. It doesn't contain a rule. Cookies are usually added to this segment via
// cookie upload.
//

type NonRuleBasedFirstPartyAudienceSegment struct {

	// FirstPartyAudienceSegment
	*FirstPartyAudienceSegment

	// MembershipExpirationDays
	//
	// Specifies the number of days after which a user's cookie will be removed from the audience
	// segment due to inactivity. This attribute is required and can be between 1 and 540.
	//

	MembershipExpirationDays *int `xml:"membershipExpirationDays"`
}

// NotNullError
//
// Caused by supplying a null value for an attribute that cannot be null.
//

type NotNullError struct {
	Reason string `xml:"reason"`
}

// NumberValue
//
// Contains a numeric value.
//

type NumberValue struct {

	// Value
	//
	// The numeric value represented as a string.
	//

	Value *string `xml:"value"`
}

// ParseError
//
// Lists errors related to parsing.
//

type ParseError struct {
	Reason string `xml:"reason"`
}

// PermissionError
//
// Errors related to incorrect permission.
//

type PermissionError struct {
	Reason string `xml:"reason"`
}

// PopulateAudienceSegments
//
// Action that can be performed on {@link FirstPartyAudienceSegment} objects to populate them based
// on last 30 days of traffic.
//

type PopulateAudienceSegments struct {
}

func NewPopulateAudienceSegments() (requestbody.PerformAction, error) {
	return &PopulateAudienceSegments{}, nil
}
func (a PopulateAudienceSegments) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a PopulateAudienceSegments) GetActionType() string {
	return "PopulateAudienceSegments"
}

// PublisherQueryLanguageContextError
//
// An error that occurs while executing a PQL query contained in
// a {@link Statement} object.
//

type PublisherQueryLanguageContextError struct {
	Reason string `xml:"reason"`
}

// PublisherQueryLanguageSyntaxError
//
// An error that occurs while parsing a PQL query contained in a
// {@link Statement} object.
//

type PublisherQueryLanguageSyntaxError struct {
	Reason string `xml:"reason"`
}

// FirstPartyAudienceSegmentRule
//
// Rule of a {@link FirstPartyAudienceSegment} that defines user's eligibility criteria to be part
// of a segment.
//

type FirstPartyAudienceSegmentRule struct {

	// InventoryRule
	//
	// Specifies the inventory (i.e. ad units and placements) that are part of the rule of a {@link
	// FirstPartyAudienceSegment}. This attribute is required.
	//

	InventoryRule *InventoryTargeting `xml:"inventoryRule"`

	// CustomCriteriaRule
	//
	// Specifies the collection of custom criteria that are part of the rule of a {@link
	// FirstPartyAudienceSegment}.
	//
	// <p>Once the {@link FirstPartyAudienceSegment} is updated or modified with custom criteria, the
	// server may return a normalized, but equivalent representation of the custom criteria rule.
	//
	// <ul>
	// {@code customCriteriaRule} will have up to three levels including itself.
	// <li>The top level {@link CustomCriteriaSet} i.e. the {@code customTargeting} object can only
	// contain a {@link CustomCriteriaSet.LogicalOperator#OR} of all its children.
	// <li>The second level of {@link CustomCriteriaSet} objects can only contain {@link
	// CustomCriteriaSet.LogicalOperator#AND} of all their children. If a {@link CustomCriteria}
	// is placed on this level, the server will wrap it in a {@link CustomCriteriaSet}.
	// <li>The third level can only comprise of {@link CustomCriteria} objects.
	// </ul>
	//
	// <p>The resulting custom criteria rule would be of the form: <br>
	// <img
	// src="https://chart.apis.google.com/chart?cht=gv&chl=digraph{customTargeting_LogicalOperator_OR-%3ECustomCriteriaSet_LogicalOperator_AND_1-%3ECustomCriteria_1;CustomCriteriaSet_LogicalOperator_AND_1-%3Eellipsis1;customTargeting_LogicalOperator_OR-%3Eellipsis2;ellipsis1[label=%22...%22,shape=none,fontsize=32];ellipsis2[label=%22...%22,shape=none,fontsize=32]}&chs=450x200"/>
	//

	CustomCriteriaRule *CustomCriteriaSet `xml:"customCriteriaRule"`
}

// QuotaError
//
// Describes a client-side error on which a user is attempting
// to perform an action to which they have no quota remaining.
//

type QuotaError struct {
	Reason string `xml:"reason"`
}

// RejectAudienceSegments
//
// Action that can be performed on {@link ThirdPartyAudienceSegment} objects to reject them.
//

type RejectAudienceSegments struct {
}

func NewRejectAudienceSegments() (requestbody.PerformAction, error) {
	return &RejectAudienceSegments{}, nil
}
func (a RejectAudienceSegments) GetPerformActionBody() (string, error) {
	performActionXML, err := gamxml.DeepMarshal(a, true)
	if err != nil {
		return "", err
	}
	return string(performActionXML), nil
}

func (a RejectAudienceSegments) GetActionType() string {
	return "RejectAudienceSegments"
}

// RequiredCollectionError
//
// A list of all errors to be used for validating sizes of collections.
//

type RequiredCollectionError struct {
	Reason string `xml:"reason"`
}

// RequiredError
//
// Errors due to missing required field.
//

type RequiredError struct {
	Reason string `xml:"reason"`
}

// RuleBasedFirstPartyAudienceSegment
//
// A {@link RuleBasedFirstPartyAudienceSegment} is a {@link FirstPartyAudienceSegment} owned by the
// publisher network. It contains a rule.
//

type RuleBasedFirstPartyAudienceSegment struct {

	// RuleBasedFirstPartyAudienceSegmentSummary
	*RuleBasedFirstPartyAudienceSegmentSummary

	// Rule
	//
	// Specifies the rule of the segment which determines user's eligibility criteria to be part of
	// the segment. This attribute is required.
	//

	Rule *FirstPartyAudienceSegmentRule `xml:"rule"`
}

// RuleBasedFirstPartyAudienceSegmentSummary
//
// A {@link RuleBasedFirstPartyAudienceSegmentSummary} is a {@link FirstPartyAudienceSegment} owned
// by the publisher network.
//

type RuleBasedFirstPartyAudienceSegmentSummary struct {

	// FirstPartyAudienceSegment
	*FirstPartyAudienceSegment

	// PageViews
	//
	// Specifies the number of times a user's cookie must match the segment rule before it's
	// associated with the audience segment. This is used in combination with {@link
	// FirstPartyAudienceSegment#recencyDays} to determine eligibility of the association. This
	// attribute is required and can be between 1 and 12.
	//

	PageViews *int `xml:"pageViews"`

	// RecencyDays
	//
	// Specifies the number of days within which a user's cookie must match the segment rule before
	// it's associated with the audience segment. This is used in combination with {@link
	// FirstPartyAudienceSegment#pageViews} to determine eligibility of the association. This
	// attribute is required only if {@link FirstPartyAudienceSegment#pageViews} is greater than 1.
	// When required, it can be between 1 and 90.
	//

	RecencyDays *int `xml:"recencyDays"`

	// MembershipExpirationDays
	//
	// Specifies the number of days after which a user's cookie will be removed from the audience
	// segment due to inactivity. This attribute is required and can be between 1 and 540.
	//

	MembershipExpirationDays *int `xml:"membershipExpirationDays"`
}

// AudienceSegmentAction
//
// Action that can be performed on {@link AudienceSegment} objects.
//

type AudienceSegmentAction struct {
}

// AudienceSegment
//
// An {@link AudienceSegment} represents audience segment object.
//

type AudienceSegment struct {

	// Id
	//
	// Id of the {@link AudienceSegment}. This attribute is readonly and is populated by Google.
	//

	Id *int64 `xml:"id"`

	// Name
	//
	// Name of the {@link AudienceSegment}. This attribute is required and has a maximum length of 255
	// characters.
	//

	Name *string `xml:"name"`

	// CategoryIds
	//
	// The ids of the categories this segment belongs to. This field is optional, it may be empty.
	//

	CategoryIds []*int64 `xml:"categoryIds"`

	// Description
	//
	// Description of the {@link AudienceSegment}. This attribute is optional and has a maximum length
	// of 8192 characters.
	//

	Description *string `xml:"description"`

	// Status
	//
	// Status of the {@link AudienceSegment}. This controls whether the given segment is available for
	// targeting or not. During creation this attribute is optional and defaults to {@code ACTIVE}.
	// This attribute is readonly for updates.
	//

	Status *AudienceSegmentStatus `xml:"status"`

	// Size
	//
	// Number of unique identifiers in the {@link AudienceSegment}. This attribute is readonly and is
	// populated by Google.
	//

	Size *int64 `xml:"size"`

	// MobileWebSize
	//
	// Number of unique identifiers in the {@link AudienceSegment} for mobile web.
	// This attribute is read-only.
	//

	MobileWebSize *int64 `xml:"mobileWebSize"`

	// IdfaSize
	//
	// Number of unique IDFA identifiers in the {@link AudienceSegment}.
	// This attribute is read-only.
	//

	IdfaSize *int64 `xml:"idfaSize"`

	// AdIdSize
	//
	// Number of unique AdID identifiers in the {@link AudienceSegment}.
	// This attribute is read-only.
	//

	AdIdSize *int64 `xml:"adIdSize"`

	// PpidSize
	//
	// Number of unique PPID (publisher provided identifiers) in the {@link AudienceSegment}.
	// This attribute is read-only.
	//

	PpidSize *int64 `xml:"ppidSize"`

	// DataProvider
	//
	// Owner data provider of this segment. This attribute is readonly and is assigned by Google.
	//

	DataProvider *AudienceSegmentDataProvider `xml:"dataProvider"`

	// Type
	//
	// Type of the segment. This attribute is readonly and is assigned by Google.
	//

	Type *AudienceSegmentType `xml:"type"`
}

// AudienceSegmentError
//
// Errors that could occur on audience segment related requests.
//

type AudienceSegmentError struct {
	Reason string `xml:"reason"`
}

// ServerError
//
// Errors related to the server.
//

type ServerError struct {
	Reason string `xml:"reason"`
}

// SetValue
//
// Contains a set of {@link Value Values}. May not contain duplicates.
//

type SetValue struct {

	// Value
	*Value

	// Values
	//
	// The values. They must all be the same type of {@code Value} and not contain duplicates.
	//

	Values []*Value `xml:"values"`
}

// SharedAudienceSegment
//
// A {@link SharedAudienceSegment} is an {@link AudienceSegment} owned by another entity and shared
// with the publisher network.
//

type SharedAudienceSegment struct {
}

// SoapRequestHeader
//
// Represents the SOAP request header used by API requests.
//

type SoapRequestHeader struct {

	// NetworkCode
	//
	// The network code to use in the context of a request.
	//

	NetworkCode *string `xml:"networkCode"`

	// ApplicationName
	//
	// The name of client library application.
	//

	ApplicationName *string `xml:"applicationName"`
}

// SoapResponseHeader
//
// Represents the SOAP request header used by API responses.
//

type SoapResponseHeader struct {

	// RequestId

	RequestId *string `xml:"requestId"`

	// ResponseTime

	ResponseTime *int64 `xml:"responseTime"`
}

// Statement
//
// Captures the {@code WHERE}, {@code ORDER BY} and {@code LIMIT} clauses of a
// PQL query. Statements are typically used to retrieve objects of a predefined
// domain type, which makes SELECT clause unnecessary.
// <p>
// An example query text might be {@code "WHERE status = 'ACTIVE' ORDER BY id
// LIMIT 30"}.
// </p>
// <p>
// Statements support bind variables. These are substitutes for literals
// and can be thought of as input parameters to a PQL query.
// </p>
// <p>
// An example of such a query might be {@code "WHERE id = :idValue"}.
// </p>
// <p>
// Statements also support use of the LIKE keyword. This provides wildcard string matching.
// </p>
// <p>
// An example of such a query might be {@code "WHERE name LIKE '%searchString%'"}.
// </p>
// The value for the variable idValue must then be set with an object of type
// {@link Value}, e.g., {@link NumberValue}, {@link TextValue} or
// {@link BooleanValue}.
//

type Statement struct {

	// Query
	//
	// Holds the query in PQL syntax. The syntax is:<br>
	// <code>[WHERE <condition> {[AND | OR] <condition> ...}]</code><br>
	// <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	// <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>
	// <p>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <value></code><br>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <bind variable></code><br>
	// <code><condition> := <property> IN <list></code><br>
	// <code><condition> := <property> IS NULL</code><br>
	// <code><condition> := <property> LIKE <wildcard%match></code><br>
	// <code><bind variable> := :<name></code><br>
	// </p>
	//

	Query *string `xml:"query"`

	// Values
	//
	// Holds keys and values for bind variables and their values. The key is the
	// name of the bind variable. The value is the literal value of the variable.
	// <p>
	// In the example {@code "WHERE status = :bindStatus ORDER BY id LIMIT 30"},
	// the bind variable, represented by {@code :bindStatus} is named {@code
	// bindStatus}, which would also be the parameter map key. The bind variable's
	// value would be represented by a parameter map value of type
	// {@link TextValue}. The final result, for example, would be an entry of
	// {@code "bindStatus" => StringParam("ACTIVE")}.
	// </p>
	//

	Values []*String_ValueMapEntry `xml:"values"`
}

// StatementError
//
// An error that occurs while parsing {@link Statement} objects.
//

type StatementError struct {
	Reason string `xml:"reason"`
}

// StringFormatError
//
// A list of error code for reporting invalid content of input strings.
//

type StringFormatError struct {
	Reason string `xml:"reason"`
}

// StringLengthError
//
// Errors for Strings which do not meet given length constraints.
//

type StringLengthError struct {
	Reason string `xml:"reason"`
}

// String_ValueMapEntry
//
// This represents an entry in a map with a key of type String
// and value of type Value.
//

type String_ValueMapEntry struct {

	// Key

	Key *string `xml:"key"`

	// Value

	Value *Value `xml:"value"`
}

// TextValue
//
// Contains a string value.
//

type TextValue struct {

	// Value
	//
	// The string value.
	//

	Value *string `xml:"value"`
}

// TypeError
//
// An error for a field which is an invalid type.
//

type TypeError struct {
	Reason string `xml:"reason"`
}

// UpdateResult
//
// Represents the result of performing an action on objects.
//

type UpdateResult struct {

	// NumChanges
	//
	// The number of objects that were changed as a result of performing the
	// action.
	//

	NumChanges *int `xml:"numChanges"`
}

// Value
//
// {@code Value} represents a value.
//

type Value struct {
}

// ApiVersionErrorReasonReason
const (

	// ApiVersionErrorReasonReasonUpdateToNewerVersion
	//
	// Indicates that the operation is not allowed in the version the request
	// was made in.
	//
	ApiVersionErrorReasonReasonUpdateToNewerVersion = "UPDATE_TO_NEWER_VERSION"

	// ApiVersionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ApiVersionErrorReasonReasonUnknown = "UNKNOWN"
)

// AudienceSegmentApprovalStatus
//
// Approval status values for {@link ThirdPartyAudienceSegment} objects.
type AudienceSegmentApprovalStatus string

const (

	// AudienceSegmentApprovalStatusUnapproved
	//
	// Specifies that this segment is waiting to be approved or rejected. It cannot be targeted.
	//
	AudienceSegmentApprovalStatusUnapproved AudienceSegmentApprovalStatus = "UNAPPROVED"

	// AudienceSegmentApprovalStatusApproved
	//
	// Specifies that this segment is approved and can be targeted.
	//
	AudienceSegmentApprovalStatusApproved AudienceSegmentApprovalStatus = "APPROVED"

	// AudienceSegmentApprovalStatusRejected
	//
	// Specifies that this segment is rejected and cannot be targeted.
	//
	AudienceSegmentApprovalStatusRejected AudienceSegmentApprovalStatus = "REJECTED"

	// AudienceSegmentApprovalStatusUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegmentApprovalStatusUnknown AudienceSegmentApprovalStatus = "UNKNOWN"
)

// AuthenticationErrorReasonReason
const (

	// AuthenticationErrorReasonReasonAmbiguousSoapRequestHeader
	//
	// The SOAP message contains a request header with an ambiguous definition of the authentication
	// header fields. This means either the {@code authToken} and {@code oAuthToken} fields were
	// both null or both were specified. Exactly one value should be specified with each request.
	//
	AuthenticationErrorReasonReasonAmbiguousSoapRequestHeader = "AMBIGUOUS_SOAP_REQUEST_HEADER"

	// AuthenticationErrorReasonReasonInvalidEmail
	//
	// The login provided is invalid.
	//
	AuthenticationErrorReasonReasonInvalidEmail = "INVALID_EMAIL"

	// AuthenticationErrorReasonReasonAuthenticationFailed
	//
	// Tried to authenticate with provided information, but failed.
	//
	AuthenticationErrorReasonReasonAuthenticationFailed = "AUTHENTICATION_FAILED"

	// AuthenticationErrorReasonReasonInvalidOauthSignature
	//
	// The OAuth provided is invalid.
	//
	AuthenticationErrorReasonReasonInvalidOauthSignature = "INVALID_OAUTH_SIGNATURE"

	// AuthenticationErrorReasonReasonInvalidService
	//
	// The specified service to use was not recognized.
	//
	AuthenticationErrorReasonReasonInvalidService = "INVALID_SERVICE"

	// AuthenticationErrorReasonReasonMissingSoapRequestHeader
	//
	// The SOAP message is missing a request header with an {@code authToken} and optional {@code
	// networkCode}.
	//
	AuthenticationErrorReasonReasonMissingSoapRequestHeader = "MISSING_SOAP_REQUEST_HEADER"

	// AuthenticationErrorReasonReasonMissingAuthenticationHttpHeader
	//
	// The HTTP request is missing a request header with an {@code authToken}
	//
	AuthenticationErrorReasonReasonMissingAuthenticationHttpHeader = "MISSING_AUTHENTICATION_HTTP_HEADER"

	// AuthenticationErrorReasonReasonMissingAuthentication
	//
	// The request is missing an {@code authToken}
	//
	AuthenticationErrorReasonReasonMissingAuthentication = "MISSING_AUTHENTICATION"

	// AuthenticationErrorReasonReasonNetworkApiAccessDisabled
	//
	// The network does not have API access enabled.
	//
	AuthenticationErrorReasonReasonNetworkApiAccessDisabled = "NETWORK_API_ACCESS_DISABLED"

	// AuthenticationErrorReasonReasonNoNetworksToAccess
	//
	// The user is not associated with any network.
	//
	AuthenticationErrorReasonReasonNoNetworksToAccess = "NO_NETWORKS_TO_ACCESS"

	// AuthenticationErrorReasonReasonNetworkNotFound
	//
	// No network for the given {@code networkCode} was found.
	//
	AuthenticationErrorReasonReasonNetworkNotFound = "NETWORK_NOT_FOUND"

	// AuthenticationErrorReasonReasonNetworkCodeRequired
	//
	// The user has access to more than one network, but did not provide a {@code networkCode}.
	//
	AuthenticationErrorReasonReasonNetworkCodeRequired = "NETWORK_CODE_REQUIRED"

	// AuthenticationErrorReasonReasonConnectionError
	//
	// An error happened on the server side during connection to authentication service.
	//
	AuthenticationErrorReasonReasonConnectionError = "CONNECTION_ERROR"

	// AuthenticationErrorReasonReasonGoogleAccountAlreadyAssociatedWithNetwork
	//
	// The user tried to create a test network using an account that already is associated with a
	// network.
	//
	AuthenticationErrorReasonReasonGoogleAccountAlreadyAssociatedWithNetwork = "GOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK"

	// AuthenticationErrorReasonReasonUnderInvestigation
	//
	// The account is blocked and under investigation by the collections team. Please contact Google
	// for more information.
	//
	AuthenticationErrorReasonReasonUnderInvestigation = "UNDER_INVESTIGATION"

	// AuthenticationErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AuthenticationErrorReasonReasonUnknown = "UNKNOWN"
)

// CollectionSizeErrorReasonReason
const (

	// CollectionSizeErrorReasonReasonTooLarge
	CollectionSizeErrorReasonReasonTooLarge = "TOO_LARGE"

	// CollectionSizeErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CollectionSizeErrorReasonReasonUnknown = "UNKNOWN"
)

// CommonErrorReasonReason
//
// Describes reasons for common errors
const (

	// CommonErrorReasonReasonNotFound
	//
	// Indicates that an attempt was made to retrieve an entity that does not
	// exist.
	//
	CommonErrorReasonReasonNotFound = "NOT_FOUND"

	// CommonErrorReasonReasonAlreadyExists
	//
	// Indicates that an attempt was made to create an entity that already
	// exists.
	//
	CommonErrorReasonReasonAlreadyExists = "ALREADY_EXISTS"

	// CommonErrorReasonReasonNotApplicable
	//
	// Indicates that a value is not applicable for given use case.
	//
	CommonErrorReasonReasonNotApplicable = "NOT_APPLICABLE"

	// CommonErrorReasonReasonDuplicateObject
	//
	// Indicates that two elements in the collection were identical.
	//
	CommonErrorReasonReasonDuplicateObject = "DUPLICATE_OBJECT"

	// CommonErrorReasonReasonCannotUpdate
	//
	// Indicates that an attempt was made to change an immutable field.
	//
	CommonErrorReasonReasonCannotUpdate = "CANNOT_UPDATE"

	// CommonErrorReasonReasonUnsupportedOperation
	//
	// Indicates that the requested operation is not supported.
	//
	CommonErrorReasonReasonUnsupportedOperation = "UNSUPPORTED_OPERATION"

	// CommonErrorReasonReasonConcurrentModification
	//
	// Indicates that another request attempted to update the same data in the same network
	// at about the same time. Please wait and try the request again.
	//
	CommonErrorReasonReasonConcurrentModification = "CONCURRENT_MODIFICATION"

	// CommonErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CommonErrorReasonReasonUnknown = "UNKNOWN"
)

// CustomCriteriaComparisonOperatorType
//
// Specifies the available comparison operators.
type CustomCriteriaComparisonOperator string

const (

	// CustomCriteriaComparisonOperatorTypeIs
	CustomCriteriaComparisonOperatorTypeIs CustomCriteriaComparisonOperator = "IS"

	// CustomCriteriaComparisonOperatorTypeIsNot
	CustomCriteriaComparisonOperatorTypeIsNot CustomCriteriaComparisonOperator = "IS_NOT"
)

// CustomCriteriaSetLogicalOperatorType
//
// Specifies the available logical operators.
type CustomCriteriaSetLogicalOperator string

const (

	// CustomCriteriaSetLogicalOperatorTypeAnd
	CustomCriteriaSetLogicalOperatorTypeAnd CustomCriteriaSetLogicalOperator = "AND"

	// CustomCriteriaSetLogicalOperatorTypeOr
	CustomCriteriaSetLogicalOperatorTypeOr CustomCriteriaSetLogicalOperator = "OR"
)

// CmsMetadataCriteriaComparisonOperatorType
//
// Specifies the available comparison operators.
type CmsMetadataCriteriaComparisonOperator string

const (

	// CmsMetadataCriteriaComparisonOperatorTypeEquals
	CmsMetadataCriteriaComparisonOperatorTypeEquals CmsMetadataCriteriaComparisonOperator = "EQUALS"

	// CmsMetadataCriteriaComparisonOperatorTypeNotEquals
	CmsMetadataCriteriaComparisonOperatorTypeNotEquals CmsMetadataCriteriaComparisonOperator = "NOT_EQUALS"
)

// CustomTargetingErrorReasonReason
//
// The reasons for the target error.
const (

	// CustomTargetingErrorReasonReasonKeyNotFound
	//
	// Requested {@link CustomTargetingKey} is not found.
	//
	CustomTargetingErrorReasonReasonKeyNotFound = "KEY_NOT_FOUND"

	// CustomTargetingErrorReasonReasonKeyCountTooLarge
	//
	// Number of {@link CustomTargetingKey} objects created exceeds the limit
	// allowed for the network.
	//
	CustomTargetingErrorReasonReasonKeyCountTooLarge = "KEY_COUNT_TOO_LARGE"

	// CustomTargetingErrorReasonReasonKeyNameDuplicate
	//
	// {@link CustomTargetingKey} with the same {@link CustomTargetingKey#name}
	// already exists.
	//
	CustomTargetingErrorReasonReasonKeyNameDuplicate = "KEY_NAME_DUPLICATE"

	// CustomTargetingErrorReasonReasonKeyNameEmpty
	//
	// {@link CustomTargetingKey#name} is empty.
	//
	CustomTargetingErrorReasonReasonKeyNameEmpty = "KEY_NAME_EMPTY"

	// CustomTargetingErrorReasonReasonKeyNameInvalidLength
	//
	// {@link CustomTargetingKey#name} is too long.
	//
	CustomTargetingErrorReasonReasonKeyNameInvalidLength = "KEY_NAME_INVALID_LENGTH"

	// CustomTargetingErrorReasonReasonKeyNameInvalidChars
	//
	// {@link CustomTargetingKey#name} contains unsupported or reserved
	// characters.
	//
	CustomTargetingErrorReasonReasonKeyNameInvalidChars = "KEY_NAME_INVALID_CHARS"

	// CustomTargetingErrorReasonReasonKeyNameReserved
	//
	// {@link CustomTargetingKey#name} matches one of the reserved custom
	// targeting key names.
	//
	CustomTargetingErrorReasonReasonKeyNameReserved = "KEY_NAME_RESERVED"

	// CustomTargetingErrorReasonReasonKeyDisplayNameInvalidLength
	//
	// {@link CustomTargetingKey#displayName} is too long.
	//
	CustomTargetingErrorReasonReasonKeyDisplayNameInvalidLength = "KEY_DISPLAY_NAME_INVALID_LENGTH"

	// CustomTargetingErrorReasonReasonKeyStatusNotActive
	//
	// Key is not active.
	//
	CustomTargetingErrorReasonReasonKeyStatusNotActive = "KEY_STATUS_NOT_ACTIVE"

	// CustomTargetingErrorReasonReasonValueNotFound
	//
	// Requested {@link CustomTargetingValue} is not found.
	//
	CustomTargetingErrorReasonReasonValueNotFound = "VALUE_NOT_FOUND"

	// CustomTargetingErrorReasonReasonGetValuesByStatementMustContainKeyId
	//
	// The {@code WHERE} clause in the {@link Statement#query} must always
	// contain {@link CustomTargetingValue#customTargetingKeyId} as one of its
	// columns in a way that it is AND'ed with the rest of the query.
	//
	CustomTargetingErrorReasonReasonGetValuesByStatementMustContainKeyId = "GET_VALUES_BY_STATEMENT_MUST_CONTAIN_KEY_ID"

	// CustomTargetingErrorReasonReasonValueCountForKeyTooLarge
	//
	// The number of {@link CustomTargetingValue} objects associated with a
	// {@link CustomTargetingKey} exceeds the network limit. This is only
	// applicable for keys of type {@code CustomTargetingKey.Type#PREDEFINED}.
	//
	CustomTargetingErrorReasonReasonValueCountForKeyTooLarge = "VALUE_COUNT_FOR_KEY_TOO_LARGE"

	// CustomTargetingErrorReasonReasonValueNameDuplicate
	//
	// {@link CustomTargetingValue} with the same
	// {@link CustomTargetingValue#name} already exists.
	//
	CustomTargetingErrorReasonReasonValueNameDuplicate = "VALUE_NAME_DUPLICATE"

	// CustomTargetingErrorReasonReasonValueNameEmpty
	//
	// {@link CustomTargetingValue#name} is empty.
	//
	CustomTargetingErrorReasonReasonValueNameEmpty = "VALUE_NAME_EMPTY"

	// CustomTargetingErrorReasonReasonValueNameInvalidLength
	//
	// {@link CustomTargetingValue#name} is too long.
	//
	CustomTargetingErrorReasonReasonValueNameInvalidLength = "VALUE_NAME_INVALID_LENGTH"

	// CustomTargetingErrorReasonReasonValueNameInvalidChars
	//
	// {@link CustomTargetingValue#name} contains unsupported or reserved
	// characters.
	//
	CustomTargetingErrorReasonReasonValueNameInvalidChars = "VALUE_NAME_INVALID_CHARS"

	// CustomTargetingErrorReasonReasonValueDisplayNameInvalidLength
	//
	// {@link CustomTargetingValue#displayName} is too long.
	//
	CustomTargetingErrorReasonReasonValueDisplayNameInvalidLength = "VALUE_DISPLAY_NAME_INVALID_LENGTH"

	// CustomTargetingErrorReasonReasonValueMatchTypeNotAllowed
	//
	// Only Ad Manager 360 networks can have {@link CustomTargetingValue#matchType}
	// other than {@link CustomTargetingValue.MatchType#EXACT}.
	//
	CustomTargetingErrorReasonReasonValueMatchTypeNotAllowed = "VALUE_MATCH_TYPE_NOT_ALLOWED"

	// CustomTargetingErrorReasonReasonValueMatchTypeNotExactForPredefinedKey
	//
	// You can only create {@link CustomTargetingValue} objects with match type
	// {@link CustomTargetingValue.MatchType#EXACT} when associating
	// with {@link CustomTargetingKey} objects of type
	// {@link CustomTargetingKey.Type#PREDEFINED}
	//
	CustomTargetingErrorReasonReasonValueMatchTypeNotExactForPredefinedKey = "VALUE_MATCH_TYPE_NOT_EXACT_FOR_PREDEFINED_KEY"

	// CustomTargetingErrorReasonReasonSuffixMatchTypeNotAllowed
	//
	// {@link CustomTargetingValue} object cannot have match type of
	// {@link CustomTargetingValue.MatchType#SUFFIX} when adding a
	// {@link CustomTargetingValue} to a line item.
	//
	CustomTargetingErrorReasonReasonSuffixMatchTypeNotAllowed = "SUFFIX_MATCH_TYPE_NOT_ALLOWED"

	// CustomTargetingErrorReasonReasonContainsMatchTypeNotAllowed
	//
	// {@link CustomTargetingValue} object cannot have match type of
	// {@link CustomTargetingValue.MatchType#CONTAINS} when adding a
	// {@link CustomTargetingValue} to targeting expression of a line item.
	//
	CustomTargetingErrorReasonReasonContainsMatchTypeNotAllowed = "CONTAINS_MATCH_TYPE_NOT_ALLOWED"

	// CustomTargetingErrorReasonReasonValueStatusNotActive
	//
	// Value is not active.
	//
	CustomTargetingErrorReasonReasonValueStatusNotActive = "VALUE_STATUS_NOT_ACTIVE"

	// CustomTargetingErrorReasonReasonKeyWithMissingValues
	//
	// The {@link CustomTargetingKey} does not have any
	// {@link CustomTargetingValue} associated with it.
	//
	CustomTargetingErrorReasonReasonKeyWithMissingValues = "KEY_WITH_MISSING_VALUES"

	// CustomTargetingErrorReasonReasonInvalidValueForKey
	//
	// The {@link CustomTargetingKey} has a {@link CustomTargetingValue} specified for which the
	// value is not a valid child.
	//
	CustomTargetingErrorReasonReasonInvalidValueForKey = "INVALID_VALUE_FOR_KEY"

	// CustomTargetingErrorReasonReasonCannotOrDifferentKeys
	//
	// {@link CustomCriteriaSet.LogicalOperator#OR} operation cannot be applied
	// to values with different keys.
	//
	CustomTargetingErrorReasonReasonCannotOrDifferentKeys = "CANNOT_OR_DIFFERENT_KEYS"

	// CustomTargetingErrorReasonReasonInvalidTargetingExpression
	//
	// Targeting expression is invalid. This can happen if the sequence of
	// operators is wrong, or a node contains invalid number of children.
	//
	CustomTargetingErrorReasonReasonInvalidTargetingExpression = "INVALID_TARGETING_EXPRESSION"

	// CustomTargetingErrorReasonReasonDeletedKeyCannotBeUsedForTargeting
	//
	// The key has been deleted. {@link CustomCriteria} cannot have deleted
	// keys.
	//
	CustomTargetingErrorReasonReasonDeletedKeyCannotBeUsedForTargeting = "DELETED_KEY_CANNOT_BE_USED_FOR_TARGETING"

	// CustomTargetingErrorReasonReasonDeletedValueCannotBeUsedForTargeting
	//
	// The value has been deleted. {@link CustomCriteria} cannot have deleted
	// values.
	//
	CustomTargetingErrorReasonReasonDeletedValueCannotBeUsedForTargeting = "DELETED_VALUE_CANNOT_BE_USED_FOR_TARGETING"

	// CustomTargetingErrorReasonReasonVideoBrowseByKeyCannotBeUsedForCustomTargeting
	//
	// The key is set as the video browse-by key, which cannot be used for
	// custom targeting.
	//
	CustomTargetingErrorReasonReasonVideoBrowseByKeyCannotBeUsedForCustomTargeting = "VIDEO_BROWSE_BY_KEY_CANNOT_BE_USED_FOR_CUSTOM_TARGETING"

	// CustomTargetingErrorReasonReasonCannotDeleteCustomKeyUsedInContentMetadataMapping
	//
	// Only active custom-criteria keys are supported in content metadata mapping.
	//
	CustomTargetingErrorReasonReasonCannotDeleteCustomKeyUsedInContentMetadataMapping = "CANNOT_DELETE_CUSTOM_KEY_USED_IN_CONTENT_METADATA_MAPPING"

	// CustomTargetingErrorReasonReasonCannotDeleteCustomValueUsedInContentMetadataMapping
	//
	// Only active custom-criteria values are supported in content metadata mapping.
	//
	CustomTargetingErrorReasonReasonCannotDeleteCustomValueUsedInContentMetadataMapping = "CANNOT_DELETE_CUSTOM_VALUE_USED_IN_CONTENT_METADATA_MAPPING"

	// CustomTargetingErrorReasonReasonCannotDeleteCustomKeyUsedInPartnerAssignmentTargeting
	//
	// Cannot delete a custom criteria key that is targeted by an active partner assignment.
	//
	CustomTargetingErrorReasonReasonCannotDeleteCustomKeyUsedInPartnerAssignmentTargeting = "CANNOT_DELETE_CUSTOM_KEY_USED_IN_PARTNER_ASSIGNMENT_TARGETING"

	// CustomTargetingErrorReasonReasonCannotDeleteCustomValueUsedInPartnerAssignmentTargeting
	//
	// Cannot delete a custom criteria value that is targeted by an active partner assignment.
	//
	CustomTargetingErrorReasonReasonCannotDeleteCustomValueUsedInPartnerAssignmentTargeting = "CANNOT_DELETE_CUSTOM_VALUE_USED_IN_PARTNER_ASSIGNMENT_TARGETING"

	// CustomTargetingErrorReasonReasonCannotTargetAudienceSegment
	//
	// {@link AudienceSegment} object cannot be targeted.
	//
	CustomTargetingErrorReasonReasonCannotTargetAudienceSegment = "CANNOT_TARGET_AUDIENCE_SEGMENT"

	// CustomTargetingErrorReasonReasonCannotTargetThirdPartyAudienceSegment
	//
	// Third party {@link AudienceSegment} cannot be targeted.
	//
	CustomTargetingErrorReasonReasonCannotTargetThirdPartyAudienceSegment = "CANNOT_TARGET_THIRD_PARTY_AUDIENCE_SEGMENT"

	// CustomTargetingErrorReasonReasonCannotTargetInactiveAudienceSegment
	//
	// Inactive {@link AudienceSegment} object cannot be targeted.
	//
	CustomTargetingErrorReasonReasonCannotTargetInactiveAudienceSegment = "CANNOT_TARGET_INACTIVE_AUDIENCE_SEGMENT"

	// CustomTargetingErrorReasonReasonInvalidAudienceSegments
	//
	// Targeted {@link AudienceSegment} object is not valid.
	//
	CustomTargetingErrorReasonReasonInvalidAudienceSegments = "INVALID_AUDIENCE_SEGMENTS"

	// CustomTargetingErrorReasonReasonCannotTargetMappedMetadata
	//
	// Mapped metadata key-values are deprecated and cannot be targeted.
	//
	CustomTargetingErrorReasonReasonCannotTargetMappedMetadata = "CANNOT_TARGET_MAPPED_METADATA"

	// CustomTargetingErrorReasonReasonOnlyApprovedAudienceSegmentsCanBeTargeted
	//
	// Targeted {@link AudienceSegment} objects have not been approved.
	//
	CustomTargetingErrorReasonReasonOnlyApprovedAudienceSegmentsCanBeTargeted = "ONLY_APPROVED_AUDIENCE_SEGMENTS_CAN_BE_TARGETED"

	// CustomTargetingErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CustomTargetingErrorReasonReasonUnknown = "UNKNOWN"
)

// AudienceSegmentCriteriaComparisonOperatorType
//
// Specifies the available comparison operators.
type AudienceSegmentCriteriaComparisonOperator string

const (

	// AudienceSegmentCriteriaComparisonOperatorTypeIs
	AudienceSegmentCriteriaComparisonOperatorTypeIs AudienceSegmentCriteriaComparisonOperator = "IS"

	// AudienceSegmentCriteriaComparisonOperatorTypeIsNot
	AudienceSegmentCriteriaComparisonOperatorTypeIsNot AudienceSegmentCriteriaComparisonOperator = "IS_NOT"
)

// EntityChildrenLimitReachedErrorReasonReason
//
// The reasons for the entity children limit reached error.
const (

	// EntityChildrenLimitReachedErrorReasonReasonLineItemLimitForOrderReached
	//
	// The number of line items on the order exceeds the max number of line items allowed per order
	// in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonLineItemLimitForOrderReached = "LINE_ITEM_LIMIT_FOR_ORDER_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonCreativeAssociationLimitForLineItemReached
	//
	// The number of creatives associated with the line item exceeds the max number of creatives
	// allowed to be associated with a line item in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonCreativeAssociationLimitForLineItemReached = "CREATIVE_ASSOCIATION_LIMIT_FOR_LINE_ITEM_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForPlacementReached
	//
	// The number of ad units on the placement exceeds the max number of ad units
	// allowed per placement in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForPlacementReached = "AD_UNIT_LIMIT_FOR_PLACEMENT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForLineItemReached
	//
	// The number of targeting expressions on the line item exceeds the max number of targeting
	// expressions allowed per line item in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForLineItemReached = "TARGETING_EXPRESSION_LIMIT_FOR_LINE_ITEM_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionSizeLimitReached
	//
	// The size of a single targeting expression tree exceeds the max size allowed by the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionSizeLimitReached = "TARGETING_EXPRESSION_SIZE_LIMIT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonCustomTargetingValuesForKeyLimitReached
	//
	// The number of custom targeting values for the free-form or predefined custom targeting key
	// exceeds the max number allowed.
	//
	EntityChildrenLimitReachedErrorReasonReasonCustomTargetingValuesForKeyLimitReached = "CUSTOM_TARGETING_VALUES_FOR_KEY_LIMIT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForCreativesOnLineItemReached
	//
	// The total number of targeting expressions on the creatives for the line item exceeds
	// the max number allowed per line item in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForCreativesOnLineItemReached = "TARGETING_EXPRESSION_LIMIT_FOR_CREATIVES_ON_LINE_ITEM_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonAttachmentLimitForProposalReached
	//
	// The number of attachments added to the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonAttachmentLimitForProposalReached = "ATTACHMENT_LIMIT_FOR_PROPOSAL_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProposalLineItemLimitForProposalReached
	//
	// The number of proposal line items on the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProposalLineItemLimitForProposalReached = "PROPOSAL_LINE_ITEM_LIMIT_FOR_PROPOSAL_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProductLimitForProductPackageReached
	//
	// The number of product package items on the product package exceeds the max number
	// allowed per product package in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProductLimitForProductPackageReached = "PRODUCT_LIMIT_FOR_PRODUCT_PACKAGE_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProductTemplateAndProductBaseRateLimitForRateCardReached
	//
	// The number of product template and product base rates on the rate card (including excluded
	// product base rates) exceeds the max number allowed per rate card in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProductTemplateAndProductBaseRateLimitForRateCardReached = "PRODUCT_TEMPLATE_AND_PRODUCT_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonProductPackageItemBaseRateLimitForRateCardReached
	//
	// The number of product package item base rates on the rate card exceeds the max number
	// allowed per rate card in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonProductPackageItemBaseRateLimitForRateCardReached = "PRODUCT_PACKAGE_ITEM_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonPremiumLimitForRateCardReached
	//
	// The number of premiums of the rate card exceeds the max number allowed per rate card
	// in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonPremiumLimitForRateCardReached = "PREMIUM_LIMIT_FOR_RATE_CARD_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForAdExclusionRuleTargetingReached
	//
	// The number of ad units on {@link AdExclusionRule#inventoryTargeting} exceeds the max number
	// of ad units allowed per ad exclusion rule inventory targeting in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonAdUnitLimitForAdExclusionRuleTargetingReached = "AD_UNIT_LIMIT_FOR_AD_EXCLUSION_RULE_TARGETING_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonNativeStyleLimitForNativeAdFormatReached
	//
	// The number of native styles under the native creative template exceeds the
	// max number of native styles allowed per native creative template in the
	// network.
	//
	EntityChildrenLimitReachedErrorReasonReasonNativeStyleLimitForNativeAdFormatReached = "NATIVE_STYLE_LIMIT_FOR_NATIVE_AD_FORMAT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForPresentationAssignmentReached
	//
	// The number of targeting expressions on the native style exceeds the max number of targeting
	// expressions allowed per native style in the network.
	//
	EntityChildrenLimitReachedErrorReasonReasonTargetingExpressionLimitForPresentationAssignmentReached = "TARGETING_EXPRESSION_LIMIT_FOR_PRESENTATION_ASSIGNMENT_REACHED"

	// EntityChildrenLimitReachedErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityChildrenLimitReachedErrorReasonReasonUnknown = "UNKNOWN"
)

// EntityLimitReachedErrorReasonReason
//
// The reasons for the entity limit reached error.
const (

	// EntityLimitReachedErrorReasonReasonCustomTargetingValuesLimitReached
	//
	// The number of custom targeting values exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonCustomTargetingValuesLimitReached = "CUSTOM_TARGETING_VALUES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonAdExclusionRulesLimitReached
	//
	// The number of ad exclusion rules exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonAdExclusionRulesLimitReached = "AD_EXCLUSION_RULES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonFirstPartyAudienceSegmentsLimitReached
	//
	// The number of first party audience segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonFirstPartyAudienceSegmentsLimitReached = "FIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonPlacementsLimitReached
	//
	// The number of active placements exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonPlacementsLimitReached = "PLACEMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonLineItemsLimitReached
	//
	// The number of line items excceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonLineItemsLimitReached = "LINE_ITEMS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonActiveLineItemsLimitReached
	//
	// The number of active line items exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonActiveLineItemsLimitReached = "ACTIVE_LINE_ITEMS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonDaiEncodingProfilesLimitReached
	//
	// The number of not-archived encoding profiles exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonDaiEncodingProfilesLimitReached = "DAI_ENCODING_PROFILES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonTrafficForecastSegmentsLimitReached
	//
	// The number of traffic forecast segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonTrafficForecastSegmentsLimitReached = "TRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonForecastAdjustmentsLimitReached
	//
	// The number of forecast adjustments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonForecastAdjustmentsLimitReached = "FORECAST_ADJUSTMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonActiveExperimentsLimitReached
	//
	// The number of active experiments exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonActiveExperimentsLimitReached = "ACTIVE_EXPERIMENTS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonSitesLimitReached
	//
	// The number of sites exceeds the max number allowed in the network.
	//
	EntityLimitReachedErrorReasonReasonSitesLimitReached = "SITES_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonUserTeamsLimitReached
	//
	// The number of teams on the user exceeds the max number allowed.
	//
	EntityLimitReachedErrorReasonReasonUserTeamsLimitReached = "USER_TEAMS_LIMIT_REACHED"

	// EntityLimitReachedErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityLimitReachedErrorReasonReasonUnknown = "UNKNOWN"
)

// FeatureErrorReasonReason
const (

	// FeatureErrorReasonReasonMissingFeature
	//
	// A feature is being used that is not enabled on the current network.
	//
	FeatureErrorReasonReasonMissingFeature = "MISSING_FEATURE"

	// FeatureErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FeatureErrorReasonReasonUnknown = "UNKNOWN"
)

// InternalApiErrorReasonReason
//
// The single reason for the internal API error.
const (

	// InternalApiErrorReasonReasonUnexpectedInternalApiError
	//
	// API encountered an unexpected internal error.
	//
	InternalApiErrorReasonReasonUnexpectedInternalApiError = "UNEXPECTED_INTERNAL_API_ERROR"

	// InternalApiErrorReasonReasonTransientError
	//
	// A temporary error occurred during the request. Please retry.
	//
	InternalApiErrorReasonReasonTransientError = "TRANSIENT_ERROR"

	// InternalApiErrorReasonReasonUnknown
	//
	// The cause of the error is not known or only defined in newer versions.
	//
	InternalApiErrorReasonReasonUnknown = "UNKNOWN"

	// InternalApiErrorReasonReasonDowntime
	//
	// The API is currently unavailable for a planned downtime.
	//
	InternalApiErrorReasonReasonDowntime = "DOWNTIME"

	// InternalApiErrorReasonReasonErrorGeneratingResponse
	//
	// Mutate succeeded but server was unable to build response. Client should not retry mutate.
	//
	InternalApiErrorReasonReasonErrorGeneratingResponse = "ERROR_GENERATING_RESPONSE"
)

// LicenseType
//
// Specifies the license type of a {@link ThirdPartyAudienceSegment}.
type LicenseType string

const (

	// LicenseTypeDirectLicense
	//
	// A direct license is the result of a direct contract between the data provider and the
	// publisher.
	//
	LicenseTypeDirectLicense LicenseType = "DIRECT_LICENSE"

	// LicenseTypeGlobalLicense
	//
	// A global license is the result of an agreement between Google and the data provider, which
	// agrees to license their audience segments to all the publishers and/or advertisers of the
	// Google ecosystem.
	//
	LicenseTypeGlobalLicense LicenseType = "GLOBAL_LICENSE"

	// LicenseTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LicenseTypeUnknown LicenseType = "UNKNOWN"
)

// NotNullErrorReasonReason
//
// The reasons for the target error.
const (

	// NotNullErrorReasonReasonArg1Null
	//
	// Assuming that a method will not have more than 3 arguments, if it does,
	// return NULL
	//
	NotNullErrorReasonReasonArg1Null = "ARG1_NULL"

	// NotNullErrorReasonReasonArg2Null
	NotNullErrorReasonReasonArg2Null = "ARG2_NULL"

	// NotNullErrorReasonReasonArg3Null
	NotNullErrorReasonReasonArg3Null = "ARG3_NULL"

	// NotNullErrorReasonReasonNull
	NotNullErrorReasonReasonNull = "NULL"

	// NotNullErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NotNullErrorReasonReasonUnknown = "UNKNOWN"
)

// ParseErrorReasonReason
//
// The reasons for the target error.
const (

	// ParseErrorReasonReasonUnparsable
	//
	// Indicates an error in parsing an attribute.
	//
	ParseErrorReasonReasonUnparsable = "UNPARSABLE"

	// ParseErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ParseErrorReasonReasonUnknown = "UNKNOWN"
)

// PermissionErrorReasonReason
//
// Describes reasons for permission errors.
const (

	// PermissionErrorReasonReasonPermissionDenied
	//
	// User does not have the required permission for the request.
	//
	PermissionErrorReasonReasonPermissionDenied = "PERMISSION_DENIED"

	// PermissionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PermissionErrorReasonReasonUnknown = "UNKNOWN"
)

// PublisherQueryLanguageContextErrorReasonReason
//
// The reasons for the target error.
const (

	// PublisherQueryLanguageContextErrorReasonReasonUnexecutable
	//
	// Indicates that there was an error executing the PQL.
	//
	PublisherQueryLanguageContextErrorReasonReasonUnexecutable = "UNEXECUTABLE"

	// PublisherQueryLanguageContextErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageContextErrorReasonReasonUnknown = "UNKNOWN"
)

// PublisherQueryLanguageSyntaxErrorReasonReason
//
// The reasons for the target error.
const (

	// PublisherQueryLanguageSyntaxErrorReasonReasonUnparsable
	//
	// Indicates that there was a PQL syntax error.
	//
	PublisherQueryLanguageSyntaxErrorReasonReasonUnparsable = "UNPARSABLE"

	// PublisherQueryLanguageSyntaxErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageSyntaxErrorReasonReasonUnknown = "UNKNOWN"
)

// QuotaErrorReasonReason
const (

	// QuotaErrorReasonReasonExceededQuota
	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>Another way to mitigate this error is to limit requests to 8 per second for Ad Manager
	// 360 accounts, or 2 per second for Ad Manager accounts. Once again
	// this does not guarantee that every request will succeed, but may help
	// reduce the number of times you receive this error.
	//
	QuotaErrorReasonReasonExceededQuota = "EXCEEDED_QUOTA"

	// QuotaErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	QuotaErrorReasonReasonUnknown = "UNKNOWN"

	// QuotaErrorReasonReasonReportJobLimit
	//
	// This user has exceeded the allowed number of new report requests per hour
	// (this includes both reports run via the UI and reports
	// run via {@link ReportService#runReportJob}).
	// The recommended approach to handle this error is to wait about 10 minutes
	// and then retry the request. Note that this does not guarantee the request
	// will succeed. If it fails again, try increasing the wait time.
	// <p>Another way to mitigate this error is to limit the number of new report
	// requests to 250 per hour per user. Once again, this does not guarantee that
	// every request will succeed, but may help reduce the number of times you
	// receive this error.
	//
	QuotaErrorReasonReasonReportJobLimit = "REPORT_JOB_LIMIT"

	// QuotaErrorReasonReasonSegmentPopulationLimit
	//
	// This network has exceeded the allowed number of identifiers uploaded within a 24 hour period.
	// The recommended approach to handle this error is to wait 30 minutes and then retry the
	// request. Note that this does not guarantee the request will succeed. If it fails again, try
	// increasing the wait time.
	//
	QuotaErrorReasonReasonSegmentPopulationLimit = "SEGMENT_POPULATION_LIMIT"
)

// RequiredCollectionErrorReasonReason
const (

	// RequiredCollectionErrorReasonReasonRequired
	//
	// A required collection is missing.
	//
	RequiredCollectionErrorReasonReasonRequired = "REQUIRED"

	// RequiredCollectionErrorReasonReasonTooLarge
	//
	// Collection size is too large.
	//
	RequiredCollectionErrorReasonReasonTooLarge = "TOO_LARGE"

	// RequiredCollectionErrorReasonReasonTooSmall
	//
	// Collection size is too small.
	//
	RequiredCollectionErrorReasonReasonTooSmall = "TOO_SMALL"

	// RequiredCollectionErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredCollectionErrorReasonReasonUnknown = "UNKNOWN"
)

// RequiredErrorReasonReason
//
// The reasons for the target error.
const (

	// RequiredErrorReasonReasonRequired
	//
	// Missing required field.
	//
	RequiredErrorReasonReasonRequired = "REQUIRED"
)

// AudienceSegmentTypeType
//
// Specifies services for {@link AudienceSegment} objects.
type AudienceSegmentType string

const (

	// AudienceSegmentTypeTypeFirstParty
	//
	// First party segments created and owned by the publisher.
	//
	AudienceSegmentTypeTypeFirstParty AudienceSegmentType = "FIRST_PARTY"

	// AudienceSegmentTypeTypeShared
	//
	// First party segments shared by other clients.
	//
	AudienceSegmentTypeTypeShared AudienceSegmentType = "SHARED"

	// AudienceSegmentTypeTypeThirdParty
	//
	// Third party segments licensed by the publisher from data providers. This doesn't include
	// Google-provided licensed segments.
	//
	AudienceSegmentTypeTypeThirdParty AudienceSegmentType = "THIRD_PARTY"

	// AudienceSegmentTypeTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegmentTypeTypeUnknown AudienceSegmentType = "UNKNOWN"
)

// AudienceSegmentStatusType
//
// Specifies the statuses for {@link AudienceSegment} objects.
type AudienceSegmentStatus string

const (

	// AudienceSegmentStatusTypeUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegmentStatusTypeUnknown AudienceSegmentStatus = "UNKNOWN"

	// AudienceSegmentStatusTypeActive
	//
	// Active status means this audience segment is available for targeting.
	//
	AudienceSegmentStatusTypeActive AudienceSegmentStatus = "ACTIVE"

	// AudienceSegmentStatusTypeInactive
	//
	// Inactive status means this audience segment is not available for targeting.
	//
	AudienceSegmentStatusTypeInactive AudienceSegmentStatus = "INACTIVE"

	// AudienceSegmentStatusTypeUnused
	//
	// Unused status means this audience segment was deactivated by Google because it is unused.
	//
	AudienceSegmentStatusTypeUnused AudienceSegmentStatus = "UNUSED"
)

// AudienceSegmentErrorReasonReason
//
// Reason of the given {@link AudienceSegmentError}.
const (

	// AudienceSegmentErrorReasonReasonFirstPartyAudienceSegmentNotSupported
	//
	// First party audience segment is not supported.
	//
	AudienceSegmentErrorReasonReasonFirstPartyAudienceSegmentNotSupported = "FIRST_PARTY_AUDIENCE_SEGMENT_NOT_SUPPORTED"

	// AudienceSegmentErrorReasonReasonOnlyRuleBasedFirstPartyAudienceSegmentsCanBeCreated
	//
	// Only rule-based first-party audience segments can be created.
	//
	AudienceSegmentErrorReasonReasonOnlyRuleBasedFirstPartyAudienceSegmentsCanBeCreated = "ONLY_RULE_BASED_FIRST_PARTY_AUDIENCE_SEGMENTS_CAN_BE_CREATED"

	// AudienceSegmentErrorReasonReasonAudienceSegmentIdNotFound
	//
	// Audience segment for the given id is not found.
	//
	AudienceSegmentErrorReasonReasonAudienceSegmentIdNotFound = "AUDIENCE_SEGMENT_ID_NOT_FOUND"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentRule
	//
	// Audience segment rule is invalid.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentRule = "INVALID_AUDIENCE_SEGMENT_RULE"

	// AudienceSegmentErrorReasonReasonAudienceSegmentRuleTooLong
	//
	// Audience segment rule contains too many ad units and/or custom criteria.
	//
	AudienceSegmentErrorReasonReasonAudienceSegmentRuleTooLong = "AUDIENCE_SEGMENT_RULE_TOO_LONG"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentName
	//
	// Audience segment name is invalid.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentName = "INVALID_AUDIENCE_SEGMENT_NAME"

	// AudienceSegmentErrorReasonReasonDuplicateAudienceSegmentName
	//
	// Audience segment with this name already exists.
	//
	AudienceSegmentErrorReasonReasonDuplicateAudienceSegmentName = "DUPLICATE_AUDIENCE_SEGMENT_NAME"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentDescription
	//
	// Audience segment description is invalid.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentDescription = "INVALID_AUDIENCE_SEGMENT_DESCRIPTION"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentPageviews
	//
	// Audience segment pageviews value is invalid. It must be between 1 and 12.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentPageviews = "INVALID_AUDIENCE_SEGMENT_PAGEVIEWS"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentRecency
	//
	// Audience segment recency value is invalid. It must be between 1 and 90 if pageviews > 1.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentRecency = "INVALID_AUDIENCE_SEGMENT_RECENCY"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentMembershipExpiration
	//
	// Audience segment membership expiration value is invalid. It must be between 1 and 180.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentMembershipExpiration = "INVALID_AUDIENCE_SEGMENT_MEMBERSHIP_EXPIRATION"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomKeyName
	//
	// The given custom key cannot be part of audience segment rule due to unsupported characters.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomKeyName = "INVALID_AUDIENCE_SEGMENT_CUSTOM_KEY_NAME"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomValueName
	//
	// The given custom value cannot be part of audience segment rule due to unsupported characters.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomValueName = "INVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_NAME"

	// AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomValueMatchType
	//
	// Broad-match custom value cannot be part of audience segment rule.
	//
	AudienceSegmentErrorReasonReasonInvalidAudienceSegmentCustomValueMatchType = "INVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_MATCH_TYPE"

	// AudienceSegmentErrorReasonReasonInvalidNestedFirstPartyAudienceSegment
	//
	// Audience segment rule cannot contain itself.
	//
	AudienceSegmentErrorReasonReasonInvalidNestedFirstPartyAudienceSegment = "INVALID_NESTED_FIRST_PARTY_AUDIENCE_SEGMENT"

	// AudienceSegmentErrorReasonReasonSharedSellingPartnerRootCannotBeIncluded
	//
	// Audience segment rule cannot contain shared selling inventory unit.
	//
	AudienceSegmentErrorReasonReasonSharedSellingPartnerRootCannotBeIncluded = "SHARED_SELLING_PARTNER_ROOT_CANNOT_BE_INCLUDED"

	// AudienceSegmentErrorReasonReasonInvalidNestedThirdPartyAudienceSegment
	//
	// Audience segment rule cannot contain a nested third-party segment.
	//
	AudienceSegmentErrorReasonReasonInvalidNestedThirdPartyAudienceSegment = "INVALID_NESTED_THIRD_PARTY_AUDIENCE_SEGMENT"

	// AudienceSegmentErrorReasonReasonInactiveNestedAudienceSegment
	//
	// Audience segment rule cannot contain a nested inactive segment.
	//
	AudienceSegmentErrorReasonReasonInactiveNestedAudienceSegment = "INACTIVE_NESTED_AUDIENCE_SEGMENT"

	// AudienceSegmentErrorReasonReasonAudienceSegmentGlobalLicenseError
	//
	// An error occurred when purchasing global licenses.
	//
	AudienceSegmentErrorReasonReasonAudienceSegmentGlobalLicenseError = "AUDIENCE_SEGMENT_GLOBAL_LICENSE_ERROR"

	// AudienceSegmentErrorReasonReasonSegmentViolatedPolicy
	//
	// Segment cannot be activated as it violates Google's Platform Policy.
	//
	AudienceSegmentErrorReasonReasonSegmentViolatedPolicy = "SEGMENT_VIOLATED_POLICY"

	// AudienceSegmentErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegmentErrorReasonReasonUnknown = "UNKNOWN"
)

// ServerErrorReasonReason
//
// Describes reasons for server errors
const (

	// ServerErrorReasonReasonServerError
	//
	// Indicates that an unexpected error occured.
	//
	ServerErrorReasonReasonServerError = "SERVER_ERROR"

	// ServerErrorReasonReasonServerBusy
	//
	// Indicates that the server is currently experiencing a high load. Please
	// wait and try your request again.
	//
	ServerErrorReasonReasonServerBusy = "SERVER_BUSY"

	// ServerErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ServerErrorReasonReasonUnknown = "UNKNOWN"
)

// StatementErrorReasonReason
const (

	// StatementErrorReasonReasonVariableNotBoundToValue
	//
	// A bind variable has not been bound to a value.
	//
	StatementErrorReasonReasonVariableNotBoundToValue = "VARIABLE_NOT_BOUND_TO_VALUE"

	// StatementErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StatementErrorReasonReasonUnknown = "UNKNOWN"
)

// StringFormatErrorReasonReason
//
// The reasons for the target error.
const (

	// StringFormatErrorReasonReasonUnknown
	StringFormatErrorReasonReasonUnknown = "UNKNOWN"

	// StringFormatErrorReasonReasonIllegalChars
	//
	// The input string value contains disallowed characters.
	//
	StringFormatErrorReasonReasonIllegalChars = "ILLEGAL_CHARS"

	// StringFormatErrorReasonReasonInvalidFormat
	//
	// The input string value is invalid for the associated field.
	//
	StringFormatErrorReasonReasonInvalidFormat = "INVALID_FORMAT"
)

// StringLengthErrorReasonReason
const (

	// StringLengthErrorReasonReasonTooLong
	StringLengthErrorReasonReasonTooLong = "TOO_LONG"

	// StringLengthErrorReasonReasonTooShort
	StringLengthErrorReasonReasonTooShort = "TOO_SHORT"

	// StringLengthErrorReasonReasonUnknown
	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StringLengthErrorReasonReasonUnknown = "UNKNOWN"
)

// createAudienceSegments
//
// Creates new {@link FirstPartyAudienceSegment} objects.
type CreateAudienceSegments struct {
	Segments []*FirstPartyAudienceSegment `xml:"segments"`
}

// createAudienceSegmentsResponse
type CreateAudienceSegmentsResponse struct {
	Rval []*FirstPartyAudienceSegment `xml:"rval"`
}

// getAudienceSegmentsByStatement
//
// Gets an {@link AudienceSegmentPage} of {@link AudienceSegment} objects that satisfy the given
// {@link Statement#query}. The following fields are supported for filtering:
//
// <table>
// <tr>
// <th scope="col">PQL Property</th>
// <th scope="col">Object Property</th>
// </tr>
// <tr>
// <td>{@code id}</td>
// <td>{@link AudienceSegment#id}</td>
// </tr>
// <tr>
// <td>{@code name}</td>
// <td>{@link AudienceSegment#name}</td>
// </tr>
// <tr>
// <td>{@code status}</td>
// <td>{@link AudienceSegment#status}</td>
// </tr>
// <tr>
// <td>{@code type}</td>
// <td>{@link AudienceSegment#type}</td>
// </tr>
// <tr>
// <td>{@code size}</td>
// <td>{@link AudienceSegment#size}</td>
// </tr>
// <tr>
// <td>{@code dataProviderName}</td>
// <td>{@link AudienceSegmentDataProvider#name}</td>
// </tr>
// <tr>
// <td>{@code segmentType}</td>
// <td>{@link AudienceSegment#type}</td>
// </tr>
// <tr>
// <td>{@code approvalStatus}</td>
// <td>{@link ThirdPartyAudienceSegment#approvalStatus}</td>
// </tr>
// <tr>
// <td>{@code cost}</td>
// <td>{@link ThirdPartyAudienceSegment#cost}</td>
// </tr>
// <tr>
// <td>{@code startDateTime}</td>
// <td>{@link ThirdPartyAudienceSegment#startDateTime}</td>
// </tr>
// <tr>
// <td>{@code endDateTime}</td>
// <td>{@link ThirdPartyAudienceSegment#endDateTime}</td>
// </tr>
// </table>
type GetAudienceSegmentsByStatement struct {
	FilterStatement *Statement `xml:"filterStatement"`
}

// getAudienceSegmentsByStatementResponse
type GetAudienceSegmentsByStatementResponse struct {
	Rval *AudienceSegmentPage `xml:"rval"`
}

// performAudienceSegmentAction
//
// Performs the given {@link AudienceSegmentAction} on the set of segments identified by the given
// statement.
type PerformAudienceSegmentAction struct {
	Action *AudienceSegmentAction `xml:"action"`

	FilterStatement *Statement `xml:"filterStatement"`
}

// performAudienceSegmentActionResponse
type PerformAudienceSegmentActionResponse struct {
	Rval *UpdateResult `xml:"rval"`
}

// updateAudienceSegments
//
// Updates the given {@link FirstPartyAudienceSegment} objects.
type UpdateAudienceSegments struct {
	Segments []*FirstPartyAudienceSegment `xml:"segments"`
}

// updateAudienceSegmentsResponse
type UpdateAudienceSegmentsResponse struct {
	Rval []*FirstPartyAudienceSegment `xml:"rval"`
}

// RequestHeader
type RequestHeader struct {
}

// ResponseHeader
type ResponseHeader struct {
}
