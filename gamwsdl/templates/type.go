package gamtemplates

var GamTypeTemplate = `// Code generated by gamwsdl/main.go. DO NOT EDIT.
package {{ generatePackageName .Definition.Service.Name }}

import (
	"context"
	"errors"
	"encoding/xml"
	"fmt"

	"github.com/knakazawa99/gam-sdk-go/pkg/gam/requestbody"
	"github.com/knakazawa99/gam-sdk-go/pkg/gam/soap"
	gamxml "github.com/knakazawa99/gam-sdk-go/pkg/xml"
)

{{/* Generate Types */}}
{{ range .Definition.Types.Schema.ComplexTypes }}
	// {{ .Name }} {{ if .Annotation }} {{ .Annotation.Documentation | makeComment }}{{ end }}
	{{ if isNameIncludeError .Name }}
		type {{ .Name }} struct {
			Reason string ` + "`" + `xml:"reason"` + "`" + `
		}
	{{ else }}
		type {{ removeDotFromString .Name }} struct {
			{{ if ne .ComplexContent nil }}
				{{ $baseName := getTypeFromElementType .ComplexContent.Extension.Base }}
				{{ $isBaseTypeHasAttribute := false }}	
				
				{{/* Check if base type has attribute */}}
				{{ range .ComplexContent.Extension.Sequence.Elements }}
					{{ if ne $baseName (.Name | toUpperCamelFromCamelCase) }} 
						{{ $isBaseTypeHasAttribute = true }}
					{{ end }}
				{{ end }}

				{{/* Generate base type if it has attribute(should always be before the other attribute) */}}
				{{ if and (ne .ComplexContent.Extension.Base nil) (ne $isBaseTypeHasAttribute false) }}
					// {{ $baseName }}
                    *{{ $baseName }}
				{{ end }}
			
				{{ range .ComplexContent.Extension.Sequence.Elements }}
					{{ $typeName := getTypeFromElementType .Type }}  
					{{ if isElementTypeError $typeName }}
						// {{ .Name | toUpperCamelFromCamelCase }}  {{ if .Annotation }} {{ .Annotation.Documentation | makeComment }}{{ end }}
						{{ .Name | toUpperCamelFromCamelCase }} string  ` + "`" + `xml:"{{.Name}}"` + "`" + `
					{{ else }}
						// {{ .Name | toUpperCamelFromCamelCase }}  {{ if .Annotation }} {{ .Annotation.Documentation | makeComment }}{{ end }}
						{{ if eq (ptrStrToStr .MaxOccurs) "unbounded" }}	
							{{ .Name | toUpperCamelFromCamelCase }} []*{{ getGoBuiltinType $typeName }}  ` + "`" + `xml:"{{.Name}}"` + "`" + `
						{{ else }}
							{{ .Name | toUpperCamelFromCamelCase }} *{{ getGoBuiltinType $typeName }}  ` + "`" + `xml:"{{.Name}}"` + "`" + `
						{{ end }}
					{{ end }}
				{{ end }}
			{{ end }} 
	
			{{ if and (ne .Sequence nil) (ne .Sequence.Elements nil) }}
				{{ range .Sequence.Elements }}
					{{ $typeName := getTypeFromElementType .Type }}
					// {{ .Name | toUpperCamelFromCamelCase }}  {{ if .Annotation }} {{ .Annotation.Documentation | makeComment }}{{ end }}
					{{ if eq "unbounded" (ptrStrToStr .MaxOccurs) }}
						{{ .Name | toUpperCamelFromCamelCase }} []*{{ getGoBuiltinType $typeName }}  ` + "`" + `xml:"{{.Name}}"` + "`" + `
					{{ else }}
						{{ .Name | toUpperCamelFromCamelCase }} *{{ getGoBuiltinType $typeName }}  ` + "`" + `xml:"{{.Name}}"` + "`" + `
					{{ end }}
				{{ end }}
			{{ end }}
		}

		{{ if and (ne .ComplexContent nil) (ne .ComplexContent.Extension.Base nil) }}
			{{ $baseName := getTypeFromElementType .ComplexContent.Extension.Base }}
			{{ if $baseName | isPerformActionBase }}
				func New{{ removeDotFromString .Name }}(	
					{{ range .ComplexContent.Extension.Sequence.Elements }}
						{{ $typeName := getTypeFromElementType .Type }}  
						{{ .Name }} *{{ getGoBuiltinType $typeName }},
					{{end}}
				) (requestbody.PerformAction, error) {
					return &{{ removeDotFromString .Name }} {
						{{ range .ComplexContent.Extension.Sequence.Elements }}
							{{ $typeName := getTypeFromElementType .Type }}  
							{{ .Name | toUpperCamelFromCamelCase }}: {{ .Name }},
						{{ end }}
					}, nil
				}
				func (a {{ removeDotFromString .Name }}) GetPerformActionBody() (string, error) {
					performActionXML, err := gamxml.DeepMarshal(a, true)
					if err != nil {
						return "", err
					}
					return string(performActionXML), nil
				}
				
				func (a {{ removeDotFromString .Name }}) GetActionType() string {
					return "{{ removeDotFromString .Name }}"
				}
			{{ end }}
		{{ end }}
	{{ end }}
	
{{ end }}

{{/* Generate Constants like a Enum */}}
{{ range .Definition.Types.Schema.SimpleTypes }}
	{{ $name := .Name }}
	{{ $type := getTypeKind $name }}
	{{ if eq $type "Enum" }}
	// {{  $name | removeDotFromString }} {{ if .Annotation }}{{ .Annotation.Documentation | makeComment }}{{ end }}
	type {{ $name | removeDotFromString }} string
	const (
		{{ range .Restriction.Enumerations }}
		// {{  $name | removeDotFromString }}{{.Value | toUpperCamelFromUpperSnakeCase }} {{ if .Annotation }}{{ .Annotation.Documentation | makeComment }}{{ end }}
		{{  $name | removeDotFromString }}{{.Value | toUpperCamelFromUpperSnakeCase }} {{  $name | removeDotFromString }} = "{{ .Value }}"
		{{ end }}
	)
	{{ else if eq $type "Type" }}
	// {{ removeDotFromString $name }}Type {{ if .Annotation }}{{ .Annotation.Documentation | makeComment }}{{ end }}
	type {{ $name | removeDotFromString }} string
	const (
		{{ range .Restriction.Enumerations }}
		// {{ removeDotFromString $name }}Type{{.Value | toUpperCamelFromUpperSnakeCase }} {{ if .Annotation }}{{ .Annotation.Documentation | makeComment }}{{ end }}
		{{ removeDotFromString $name }}Type{{.Value | toUpperCamelFromUpperSnakeCase }} {{ $name | removeDotFromString }} = "{{ .Value }}"
		{{ end }}
	)
	{{ else if eq $type "Error" }}
	// {{ removeDotFromString $name }}Reason {{ if .Annotation }}{{ .Annotation.Documentation | makeComment }}{{ end }}
	const (
		{{ range .Restriction.Enumerations }}
		// {{ removeDotFromString $name }}Reason{{.Value | toUpperCamelFromUpperSnakeCase }} {{ if .Annotation }}{{ .Annotation.Documentation | makeComment }}{{ end }}
		{{ removeDotFromString $name }}Reason{{.Value | toUpperCamelFromUpperSnakeCase }} = "{{ .Value }}"
		{{ end }}
	)
	{{ end }}
{{ end }}

{{ range .Definition.Types.Schema.Elements }}
	{{ if isNameIncludeError .Name }}
	{{ else }}
		// {{ removeDotFromString .Name }} {{ if .Annotation }}{{ .Annotation.Documentation | makeComment }}{{ end }}
		type {{ .Name | toUpperCamelFromCamelCase }} struct {
			{{ if ne .ComplexType nil }}
				{{ if ne .ComplexType.Sequence nil }}
					{{ range .ComplexType.Sequence.Elements }}
						{{ $typeName := getTypeFromElementType .Type }}
						{{ if eq (ptrStrToStr .MaxOccurs) "unbounded" }}	
							{{ .Name | toUpperCamelFromCamelCase }} []*{{ getGoBuiltinType $typeName }}  ` + "`" + `xml:"{{.Name}}"` + "`" + `
						{{ else }}
							{{ .Name | toUpperCamelFromCamelCase }} *{{ getGoBuiltinType $typeName }}  ` + "`" + `xml:"{{.Name}}"` + "`" + `
						{{ end }}
					{{ end }}
				{{ end }}
			{{ end }}
		}
	{{ end }}
{{ end }}
`
